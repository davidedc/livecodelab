<!doctype html>

<!-- Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc) -->

<html>
<head>
  <title>CoffeeDoc | graphics-commands.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" media="all" href="../../../../resources/base.css" />
</head>
<body>
  <header>
    <h1>graphics-commands.coffee</h1>
  </header>
  <div class="container">
    <div class="sidebar column">
      
      <h4>Classes</h4>
      <ul class="classlist">
        
        <li><a href="#GraphicsCommands">GraphicsCommands</a></li>
        
      </ul>
      
      
    </div>
    <div class="content column">
      
      <div id="module-docstring">
        <p>Please reference the colour-functions.js file for all colour-related
functions and lights-functions.js for lights, which use a similar
structure for caching and counting of light instances.</p>
<h1>Fundamentals</h1>
<p>There are a couple of fundamentals of LiveCodeLab and a couple of
complications of Three.js that shape the way
graphic primitives work in this file.</p>
<h2>LiveCodeLab uses immediate mode graphics</h2>
<p>First off, like Processing, LiveCodeLab shies away from &quot;retained&quot; graphics
and instead uses &quot;immediate mode&quot; graphics.
For context, &quot;immediate mode&quot; graphics means that when the user uses a graphic
primitive, he is
NOT given a handle that he can use to modify properties of that element at a
later stage, contrarily to flash, DOM, CSS, openGL and Three.JS
(to different degrees).
Retained graphic modes keep structures in memory that make easy for example
to do event handling (which object did I click?), hierarchy management
(parent/child relationships, container/content, etc), property tweaking
(change property X of object Y), and sometimes animation ( CoreAnimation from
Apple for example), collision/overlap detection. Note that openGL is retained
in that there are handles to geometry and textures, but little else is given
(no events, no input, no physics/overlap/collision/animation).
Also, retained graphics mode usually is smart about updating
only minimal parts of the screen that need updating rather than redrawing the
whole screen (again, openGL doesn&#39;t do that apart from basic frustum culling, but
for example there is nothing to detect occlusions and avoid painting occluded
objects).
There are a few drawbacks in retained modes: a) programs that manage
handles are more lengthy than programs that don&#39;t
b) they are often not needed for example in
2d sprites-based videogames c) most importantly,
they require deeper understanding of the underlying
model (e.g. which property can I change? What are those called? How do I change
parent/child relationship? How do events bubble up and where should I catch them?).
Processing and LiveCodeLab go for immediate mode. Once the primitive is invoked, it
becomes pixels and there is no built-in way to do input/event/hierarchies...
Rather, there are a few properties that are set as a global state and apply to all
objects. Examples are &quot;fill&quot; and &quot;stroke&quot;.</p>
<h2>Relationship between objects, meshes, geometry, materials...</h2>
<p>A Three.js object (or to be more precise, Object3D) can be a line or a mesh. A line
is a line, a mesh can be anything else depending on what the geometry of the mesh
is. There are more possible types such as particles, etc. but they are not currently
used in LiveCodeLab. An object needs one more thing: a material.</p>
<h2>Caching of objects</h2>
<p>Once created, objects are kept cached together with all possible materials that can be
associated with it. Each object has to have its own set of materials because
one can decide to draw one object in solid fill, one in normal color, one with
an ambient light (i.e. lambert material), etc.</p>
<h2>Objects are kept in the scene</h2>
<p>Once an object is added to the scene, it&#39;s never removed. Rather, it&#39;s hidden if it&#39;s
not used, but it&#39;s never removed. This is because adding/removing objects from the
scene is rather expensive. Note that Mr Doob mentioned via email that subsequent
versions of three.js have improved performance a lot, so it&#39;s worth trying another
approach.</p>
<h2>Strokes are managed via separate objects for stroke and fill</h2>
<p>There is a particular flag in Three.js materials for drawing wireframes. But materials
cannot be combined, i.e. only one is associated at any time with a geometry. So one
can either draw a wireframe or a fill. In previous versions of Three.js more than
one material could be associated, but that has been deprecated, see
<a href="https://github.com/mrdoob/three.js/issues/751">https://github.com/mrdoob/three.js/issues/751</a> and instead a
createMultiMaterialObject utility was put in place, which basically creates multiple
objects one for each material, see
<a href="https://github.com/mrdoob/three.js/blob/dev/src/extras/SceneUtils.js#L29">https://github.com/mrdoob/three.js/blob/dev/src/extras/SceneUtils.js#L29</a>
So the solution here is to create two disting objects.
One for the fills and one, slightly &quot;larger&quot;, for the strokes. In that way, the
strokes are visible &quot;in front&quot; of the fills, and the fills cover the strokes &quot;at
the back&quot;</p>
<h2>The order of materials matters</h2>
<p>When an object is created, it must be first rendered with the most complex material,
because internally in Three.js/WebGL memory is allocated only once. So a special
mechanism is put in place by which new objects are drawn with the normalMaterial
with scale 0, so they are rendered but they are invisible. In the next frame (i.e.
after the first render) the correct material is used.</p>
<h2>&quot;Spinning&quot;</h2>
<p>&quot;Spinning&quot; applies to all objects added to an empty frame: it makes all objects spin
for a few frames. This has been implemented for two reasons a) cosmetic b) the user
is likely to first use &quot;box&quot;, and without spinning that would look like a boring
square that appears without animation. Spinning gives many more cues: the environment
is 3d, the lighting is special by default and all faces have primary colors, things
animate. Without spinning, all those cues need to be further explained and demonstra
ted.</p>

      </div>
      
      
      <div id="classes">
        <h2>Classes</h2>
        
        <div class="class">
          <div class="header">
            <a id="GraphicsCommands"><h3>GraphicsCommands</h3></a>
            
          </div>
          <div class="class-content">
            
            <div class="methods">
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>constructor(@liveCodeLabCore_three, @liveCodeLabCoreInstance)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>createObjectIfNeededAndDressWithCorrectMaterial(a, b, c, primitiveProperties, strokeTime, colorToBeUsed, alphaToBeUsed, applyDefaultNormalColor)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>commonPrimitiveDrawingLogic(a, b, c, primitiveProperties)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>reset()</h4>
                  
                </div>
                
                <div class="method">
                  <h4>line(a, b, c)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>rect(a, b, c)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>box(a, b, c)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>peg(a, b, c)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>ballDetail(a)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>ball(a, b, c)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>fill(r, g, b, a)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>noFill()</h4>
                  
                </div>
                
                <div class="method">
                  <h4>stroke(r, g, b, a)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>noStroke()</h4>
                  
                </div>
                
                <div class="method">
                  <h4>strokeSize(a)</h4>
                  
                </div>
                
              </div>
              
              
            </div>
          </div>
        </div>
        
      </div>
      
      
    </div>
  </div>
</body>
</html>
