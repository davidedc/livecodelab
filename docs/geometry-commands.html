<!DOCTYPE html>  <html> <head>   <title>geometry-commands.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>            <div id="jump_to">         Jump To &hellip;         <div id="jump_wrapper">           <div id="jump_page">                                           <a class="source" href="autocode.html">                 autocode.js               </a>                                           <a class="source" href="background-painting.html">                 background-painting.js               </a>                                           <a class="source" href="big-cursor-animation.html">                 big-cursor-animation.js               </a>                                           <a class="source" href="code-transformations.html">                 code-transformations.js               </a>                                           <a class="source" href="demos-and-tutorials.html">                 demos-and-tutorials.js               </a>                                           <a class="source" href="coffeescript-livecodelab-mode.html">                 coffeescript-livecodelab-mode.js               </a>                                           <a class="source" href="editor.html">                 editor.js               </a>                                           <a class="source" href="mousewheel.html">                 mousewheel.js               </a>                                           <a class="source" href="from-processing.html">                 from-processing.js               </a>                                           <a class="source" href="geometry-commands.html">                 geometry-commands.js               </a>                                           <a class="source" href="init-threejs.html">                 init-threejs.js               </a>                                           <a class="source" href="init.html">                 init.js               </a>                                           <a class="source" href="lights-functions.html">                 lights-functions.js               </a>                                           <a class="source" href="livecodelab.html">                 livecodelab.js               </a>                                           <a class="source" href="math.html">                 math.js               </a>                                           <a class="source" href="matrix-commands.html">                 matrix-commands.js               </a>                                           <a class="source" href="menu.html">                 menu.js               </a>                                           <a class="source" href="sound-functions.html">                 sound-functions.js               </a>                                           <a class="source" href="text-dimming.html">                 text-dimming.js               </a>                                           <a class="source" href="var-definitions.html">                 var-definitions.js               </a>                        </div>         </div>       </div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               geometry-commands.js             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>               <p>TODO Note that lines have a "solid fill" mode
and something similar to the normalMaterial mode
but there is no equivalent to the lambert material
mode.
That could be done by somehow mixing the color of
an ambient light to the color of the stroke
(although which ambient light do you pick if there
is more than one?)</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="keyword">var</span> line = <span class="keyword">function</span>(a) {

  <span class="keyword">if</span> (!doStroke) {
    <span class="keyword">return</span>;
  }

  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) {
    a = <span class="number">1</span>;
  }


  <span class="keyword">var</span> mesh = linesPool[usedLines];
  <span class="keyword">if</span> (mesh === <span class="literal">undefined</span>) {
    <span class="keyword">var</span> lineBasicMaterialCOL = <span class="keyword">new</span> THREE.LineBasicMaterial({
</pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p>color: currentStrokeColor,</p>             </td>             <td class="code">               <div class="highlight"><pre>      opacity: currentStrokeAlpha,
      linewidth: currentStrokeSize
    });

    mesh = <span class="keyword">new</span> THREE.Line(lineGeometry, lineBasicMaterialCOL);
    mesh.isLine = <span class="literal">true</span>;
    mesh.isRectangle = <span class="literal">false</span>;
    mesh.isBox = <span class="literal">false</span>;
    mesh.isCylinder = <span class="literal">false</span>;
    mesh.isAmbientLight = <span class="literal">false</span>;
    mesh.isPointLight = <span class="literal">false</span>;
    mesh.isSphere = <span class="number">0</span>;
    linesPool.push(mesh);
    scene.add(mesh);
  } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>mesh.geometry = lineGeometry;
mesh.material = lineBasicMaterialCOL;
mesh.material.color.setHex(currentStrokeColor);</p>             </td>             <td class="code">               <div class="highlight"><pre>    mesh.material.opacity = currentStrokeAlpha;
    mesh.material.linewidth = currentStrokeSize;
  }
  usedLines++;

</pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p>old unpooled mechanism
var mesh = new THREE.Line(lineGeometry, lineBasicMaterialCOL);</p>             </td>             <td class="code">               <div class="highlight"><pre>  mesh.matrixAutoUpdate = <span class="literal">false</span>;
  mesh.matrix.copy(worldMatrix);
  mesh.matrixWorldNeedsUpdate = <span class="literal">true</span>;
  <span class="keyword">if</span> (a !== <span class="number">1</span>) {
    mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, a, <span class="number">1</span>));
</pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>in theory the docs say that we should change the boundradius
but I don't think that we need it...
mesh.boundRadiusScale = Math.max(a,b,c);</p>             </td>             <td class="code">               <div class="highlight"><pre>  }

</pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>setting the color after the geometry has been dealt with
because in case we use the angleColor then we
need to know the geometry.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">if</span> (currentStrokeColor === angleColor || defaultNormalStroke) {
    <span class="keyword">var</span> sasaas = mesh.matrix.multiplyVector3(<span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)).normalize();
    log(sasaas.x+ <span class="string">" "</span> + sasaas.y + <span class="string">" "</span> + sasaas.z);
    mesh.material.color.setHex(color(((sasaas.x + <span class="number">1</span>) / <span class="number">2</span>) * <span class="number">255</span>, ((sasaas.y + <span class="number">1</span>) / <span class="number">2</span>) * <span class="number">255</span>, ((sasaas.z + <span class="number">1</span>) / <span class="number">2</span>) * <span class="number">255</span>));
  } <span class="keyword">else</span> {
    mesh.material.color.setHex(currentStrokeColor);
  }

}


<span class="keyword">var</span> rect = <span class="keyword">function</span>(a, b) {

</pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p>simple case - if there is no fill and
no stroke then there is nothing to do.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">var</span> startIndex = <span class="number">0</span>;
  <span class="keyword">var</span> endIndex = <span class="number">0</span>;

  <span class="keyword">if</span> (!doFill &amp;&amp; !doStroke) {
    <span class="keyword">return</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p>if the wireframe is not going to be visible on top of the
fill then don't draw it</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">else</span> <span class="keyword">if</span> ((doFill &amp;&amp; (currentStrokeSize === <span class="number">0</span> || !doStroke || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; !defaultNormalFill &amp;&amp; !defaultNormalStroke &amp;&amp; currentStrokeColor === currentFillColor &amp;&amp; currentFillAlpha === <span class="number">1</span> &amp;&amp; currentStrokeAlpha === <span class="number">1</span>))) || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; defaultNormalFill &amp;&amp; defaultNormalStroke)) {
</pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>if (doStroke) log('smart optimisation, was supposed to do the stroke but not doing it!!');</p>             </td>             <td class="code">               <div class="highlight"><pre>    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">1</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (!doFill &amp;&amp; doStroke) {
    startIndex = <span class="number">1</span>;
    endIndex = <span class="number">2</span>;
  } <span class="keyword">else</span> {
    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">2</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>log("si: " + startIndex + " endI: " + endIndex );</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) {
    a = <span class="number">1</span>;
    b = <span class="number">1</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    b = a;
  }

  <span class="keyword">var</span> strokeTime = <span class="literal">false</span>;
  <span class="keyword">var</span> colorToBeUsed;
  <span class="keyword">var</span> alphaToBeUsed;
  <span class="keyword">var</span> newRectCreated = <span class="literal">false</span>;

</pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p>this is to run the code twice. This should be neater
and turned into a function call really.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">for</span> (<span class="keyword">var</span> fillAndStroke = startIndex; fillAndStroke &lt; endIndex; fillAndStroke++) {
    <span class="keyword">if</span> (fillAndStroke === <span class="number">1</span>) {
      strokeTime = <span class="literal">true</span>;
      colorToBeUsed = currentStrokeColor;
      alphaToBeUsed = currentStrokeAlpha;
    } <span class="keyword">else</span> {
      colorToBeUsed = currentFillColor;
      alphaToBeUsed = currentFillAlpha;
    }
    <span class="keyword">var</span> pooledRectangle = rectanglesPool[usedRectangles];
    <span class="keyword">if</span> (pooledRectangle === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <p>each pooled rectangle contains a geometry,
a basic material and a lambert material.</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledRectangle = {
        basicMaterial: <span class="literal">undefined</span>,
        lambertMaterial: <span class="literal">undefined</span>,
        normalMaterial: <span class="literal">undefined</span>,
</pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, otherwise the
more complicated materials won't show
up, see:
https://github.com/mrdoob/three.js/issues/1051
so we always need to create a normalmaterial
and render that material first, in case
the user will ever want to use it.
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>        neverUsed: <span class="literal">true</span>,
        mesh: <span class="literal">undefined</span>
      };
      newRectCreated = <span class="literal">true</span>;
      rectanglesPool.push(pooledRectangle);
    }
    <span class="keyword">var</span> applyDefaultNormalColor = <span class="literal">false</span>;
    <span class="keyword">if</span> (!strokeTime) {
      <span class="keyword">if</span> (defaultNormalFill) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (defaultNormalStroke) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    }
    log(<span class="string">"rect: default normal color: "</span> + applyDefaultNormalColor);
    log(<span class="string">"rect: alphaToBeUsed: "</span> + alphaToBeUsed);
    <span class="keyword">if</span> (pooledRectangle.neverUsed || (colorToBeUsed === angleColor || applyDefaultNormalColor)) {
</pre></div>             </td>           </tr>                               <tr id="section-14">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-14">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, see:
https://github.com/mrdoob/three.js/issues/1051
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledRectangle.neverUsed = <span class="literal">false</span>;
      <span class="keyword">if</span> (pooledRectangle.normalMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating normal material"</span>);
        pooledRectangle.normalMaterial = <span class="keyword">new</span> THREE.MeshNormalMaterial({
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize
        });
      } <span class="keyword">else</span> {
        pooledRectangle.normalMaterial.opacity = alphaToBeUsed;
        pooledRectangle.normalMaterial.wireframe = strokeTime;
        pooledRectangle.normalMaterial.doubleSided = <span class="literal">true</span>;
        pooledRectangle.normalMaterial.wireframeLinewidth = currentStrokeSize;
      }
      <span class="keyword">if</span> (pooledRectangle.mesh === <span class="literal">undefined</span>) {
        pooledRectangle.mesh = <span class="keyword">new</span> THREE.Mesh(planeGeometry, pooledRectangle.normalMaterial);
        pooledRectangle.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-15">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-15">&#182;</a>               </div>               <pre><code>   log("associating normal material to existing mesh");
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>        pooledRectangle.mesh.material = pooledRectangle.normalMaterial;
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (!lightsAreOn) {
      log(<span class="string">"rect: lights are not on"</span>);
      <span class="keyword">if</span> (pooledRectangle.basicMaterial === <span class="literal">undefined</span>) {
        pooledRectangle.basicMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize
        });
      } <span class="keyword">else</span> {
        pooledRectangle.basicMaterial.color.setHex(colorToBeUsed);
        pooledRectangle.basicMaterial.opacity = alphaToBeUsed;
        pooledRectangle.basicMaterial.wireframe = strokeTime;
        pooledRectangle.basicMaterial.doubleSided = <span class="literal">true</span>;
        pooledRectangle.basicMaterial.wireframeLinewidth = currentStrokeSize;
      }
      <span class="keyword">if</span> (pooledRectangle.mesh === <span class="literal">undefined</span>) {
        pooledRectangle.mesh = <span class="keyword">new</span> THREE.Mesh(planeGeometry, pooledRectangle.basicMaterial);
        pooledRectangle.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledRectangle.mesh.material = pooledRectangle.basicMaterial;
      }

    }
</pre></div>             </td>           </tr>                               <tr id="section-16">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-16">&#182;</a>               </div>               <p>lights are on</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">else</span> {
      log(<span class="string">"rect: lights are on"</span>);
      <span class="keyword">if</span> (pooledRectangle.lambertMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating lambert:"</span>+currentFillColor+<span class="string">" "</span>+currentFillAlpha+<span class="string">" "</span>+ambientColor+<span class="string">" "</span>+reflectValue+<span class="string">" "</span>+refractValue);
        pooledRectangle.lambertMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          ambient: ambientColor,
          reflectivity: reflectValue,
          refractionRatio: refractValue,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize
        });
      } <span class="keyword">else</span> {
        pooledRectangle.lambertMaterial.color.setHex(colorToBeUsed);
        pooledRectangle.lambertMaterial.opacity = alphaToBeUsed;
        pooledRectangle.lambertMaterial.wireframe = strokeTime;
        pooledRectangle.lambertMaterial.wireframeLinewidth = currentStrokeSize;
        pooledRectangle.lambertMaterial.doubleSided = <span class="literal">true</span>;
        pooledRectangle.lambertMaterial.ambient.setHex(ambientColor);
        pooledRectangle.lambertMaterial.reflectivity = reflectValue;
        pooledRectangle.lambertMaterial.refractionRatio = refractValue;
      }
      <span class="keyword">if</span> (pooledRectangle.mesh === <span class="literal">undefined</span>) {
        pooledRectangle.mesh = <span class="keyword">new</span> THREE.Mesh(planeGeometry, pooledRectangle.lambertMaterial);
        pooledRectangle.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledRectangle.mesh.material = pooledRectangle.lambertMaterial;
      }
    }

    <span class="keyword">if</span> (resetTheSpinThingy) {
      pooledRectangle.startCountdown = SPINFRAMES;
      resetTheSpinThingy = <span class="literal">false</span>;
      doTheSpinThingy = <span class="literal">true</span>;
    }
    <span class="keyword">if</span> (doTheSpinThingy) pooledRectangle.startCountdown--;
    <span class="keyword">if</span> (pooledRectangle.startCountdown === -<span class="number">1</span>) doTheSpinThingy = <span class="literal">false</span>;

    pooledRectangle.mesh.isLine = <span class="literal">false</span>;
    pooledRectangle.mesh.isRectangle = <span class="literal">true</span>;
    pooledRectangle.mesh.isBox = <span class="literal">false</span>;
    pooledRectangle.mesh.isCylinder = <span class="literal">false</span>;
    pooledRectangle.mesh.isAmbientLight = <span class="literal">false</span>;
    pooledRectangle.mesh.isPointLight = <span class="literal">false</span>;
    pooledRectangle.mesh.isSphere = <span class="number">0</span>;
    pooledRectangle.mesh.doubleSided = <span class="literal">true</span>;


    usedRectangles++;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledRectangle.startCountdown &gt; <span class="number">0</span>) {
      pushMatrix();
      rotate(pooledRectangle.startCountdown / <span class="number">50</span>);
      log(<span class="string">""</span>+pooledRectangle.startCountdown);
    }

    pooledRectangle.mesh.matrixAutoUpdate = <span class="literal">false</span>;
    pooledRectangle.mesh.matrix.copy(worldMatrix);
    pooledRectangle.mesh.matrixWorldNeedsUpdate = <span class="literal">true</span>;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledRectangle.startCountdown &gt; <span class="number">0</span>) {
      popMatrix();
    }

    <span class="keyword">if</span> (a !== <span class="number">1</span> || b !== <span class="number">1</span>) {
      pooledRectangle.mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(a, b, <span class="number">1</span>));
    }

    <span class="keyword">if</span> (newRectCreated) scene.add(pooledRectangle.mesh);

  }

}


<span class="keyword">var</span> box = <span class="keyword">function</span>(a, b, c) {
</pre></div>             </td>           </tr>                               <tr id="section-17">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-17">&#182;</a>               </div>               <p>simple case - if there is no fill and
no stroke then there is nothing to do.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">var</span> startIndex = <span class="number">0</span>;
  <span class="keyword">var</span> endIndex = <span class="number">0</span>;

  <span class="keyword">if</span> (!doFill &amp;&amp; !doStroke) {
    <span class="keyword">return</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-18">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-18">&#182;</a>               </div>               <p>if the wireframe is not going to be visible on top of the
fill then don't draw it</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">else</span> <span class="keyword">if</span> ((doFill &amp;&amp; (currentStrokeSize === <span class="number">0</span> || !doStroke || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; !defaultNormalFill &amp;&amp; !defaultNormalStroke &amp;&amp; currentStrokeColor === currentFillColor &amp;&amp; currentFillAlpha === <span class="number">1</span> &amp;&amp; currentStrokeAlpha === <span class="number">1</span>))) || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; defaultNormalFill &amp;&amp; defaultNormalStroke)) {
</pre></div>             </td>           </tr>                               <tr id="section-19">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-19">&#182;</a>               </div>               <p>if (doStroke) log('smart optimisation, was supposed to do the stroke but not doing it!!');</p>             </td>             <td class="code">               <div class="highlight"><pre>    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">1</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (!doFill &amp;&amp; doStroke) {
    startIndex = <span class="number">1</span>;
    endIndex = <span class="number">2</span>;
  } <span class="keyword">else</span> {
    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">2</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-20">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-20">&#182;</a>               </div>               <p>log("si: " + startIndex + " endI: " + endIndex );</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-21">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-21">&#182;</a>               </div>               <p>alert('cube!')</p>             </td>             <td class="code">               <div class="highlight"><pre>    a = <span class="number">1</span>;
    b = <span class="number">1</span>;
    c = <span class="number">1</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    b = a;
    c = a;
  }

  <span class="keyword">var</span> strokeTime = <span class="literal">false</span>;
  <span class="keyword">var</span> colorToBeUsed;
  <span class="keyword">var</span> alphaToBeUsed;
  <span class="keyword">var</span> newBoxCreated = <span class="literal">false</span>;


</pre></div>             </td>           </tr>                               <tr id="section-22">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-22">&#182;</a>               </div>               <p>this is to run the code twice. This should be neater
and turned into a function call really.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">for</span> (<span class="keyword">var</span> fillAndStroke = startIndex; fillAndStroke &lt; endIndex; fillAndStroke++) {
    <span class="keyword">if</span> (fillAndStroke === <span class="number">1</span>) {
      strokeTime = <span class="literal">true</span>;
      colorToBeUsed = currentStrokeColor;
      alphaToBeUsed = currentStrokeAlpha;
    } <span class="keyword">else</span> {
      colorToBeUsed = currentFillColor;
      alphaToBeUsed = currentFillAlpha;
    }
    <span class="keyword">var</span> pooledBox = boxesPool[usedBoxes];
    <span class="keyword">if</span> (pooledBox === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-23">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-23">&#182;</a>               </div>               <p>each pooled box contains a geometry,
a basic material and a lambert material.</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledBox = {
        basicMaterial: <span class="literal">undefined</span>,
        lambertMaterial: <span class="literal">undefined</span>,
        normalMaterial: <span class="literal">undefined</span>,
</pre></div>             </td>           </tr>                               <tr id="section-24">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-24">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, otherwise the
more complicated materials won't show
up, see:
https://github.com/mrdoob/three.js/issues/1051
so we always need to create a normalmaterial
and render that material first, in case
the user will ever want to use it.
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>        neverUsed: <span class="literal">true</span>,
        mesh: <span class="literal">undefined</span>
      };
      newBoxCreated = <span class="literal">true</span>;
      boxesPool.push(pooledBox);
    }
    <span class="keyword">var</span> applyDefaultNormalColor = <span class="literal">false</span>;
    <span class="keyword">if</span> (!strokeTime) {
      <span class="keyword">if</span> (defaultNormalFill) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (defaultNormalStroke) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    }
    <span class="keyword">if</span> (pooledBox.neverUsed || (colorToBeUsed === angleColor || applyDefaultNormalColor)) {
</pre></div>             </td>           </tr>                               <tr id="section-25">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-25">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, see:
https://github.com/mrdoob/three.js/issues/1051
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledBox.neverUsed = <span class="literal">false</span>;
      <span class="keyword">if</span> (pooledBox.normalMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating normal material"</span>);
        pooledBox.normalMaterial = <span class="keyword">new</span> THREE.MeshNormalMaterial({
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize
        });
      } <span class="keyword">else</span> {
        pooledBox.normalMaterial.opacity = alphaToBeUsed;
        pooledBox.normalMaterial.wireframe = strokeTime;
        pooledBox.normalMaterial.wireframeLinewidth = currentStrokeSize;
        pooledBox.normalMaterial.doubleSided = <span class="literal">false</span>;
      }
      <span class="keyword">if</span> (pooledBox.mesh === <span class="literal">undefined</span>) {
        pooledBox.mesh = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, pooledBox.normalMaterial);
        pooledBox.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-26">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-26">&#182;</a>               </div>               <pre><code>   log("associating normal material to existing mesh");
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>        pooledBox.mesh.material = pooledBox.normalMaterial;
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (!lightsAreOn) {
      <span class="keyword">if</span> (pooledBox.basicMaterial === <span class="literal">undefined</span>) {
        pooledBox.basicMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize
        });
      } <span class="keyword">else</span> {
        pooledBox.basicMaterial.color.setHex(colorToBeUsed);
        pooledBox.basicMaterial.opacity = alphaToBeUsed;
        pooledBox.basicMaterial.wireframe = strokeTime;
        pooledBox.basicMaterial.wireframeLinewidth = currentStrokeSize;
        pooledBox.basicMaterial.doubleSided = <span class="literal">false</span>;
      }
      <span class="keyword">if</span> (pooledBox.mesh === <span class="literal">undefined</span>) {
        pooledBox.mesh = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, pooledBox.basicMaterial);
        pooledBox.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledBox.mesh.material = pooledBox.basicMaterial;
      }

    }
</pre></div>             </td>           </tr>                               <tr id="section-27">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-27">&#182;</a>               </div>               <p>lights are on</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">else</span> {
      <span class="keyword">if</span> (pooledBox.lambertMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating lambert:"</span>+currentFillColor+<span class="string">" "</span>+currentFillAlpha+<span class="string">" "</span>+ambientColor+<span class="string">" "</span>+reflectValue+<span class="string">" "</span>+refractValue);
        pooledBox.lambertMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          ambient: ambientColor,
          reflectivity: reflectValue,
          refractionRatio: refractValue,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize
        });
      } <span class="keyword">else</span> {
        pooledBox.lambertMaterial.color.setHex(colorToBeUsed);
        pooledBox.lambertMaterial.opacity = alphaToBeUsed;
        pooledBox.lambertMaterial.wireframe = strokeTime;
        pooledBox.lambertMaterial.wireframeLinewidth = currentStrokeSize;
        pooledBox.lambertMaterial.doubleSided = <span class="literal">false</span>;
        pooledBox.lambertMaterial.ambient.setHex(ambientColor);
        pooledBox.lambertMaterial.reflectivity = reflectValue;
        pooledBox.lambertMaterial.refractionRatio = refractValue;
      }
      <span class="keyword">if</span> (pooledBox.mesh === <span class="literal">undefined</span>) {
        pooledBox.mesh = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, pooledBox.lambertMaterial);
        pooledBox.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledBox.mesh.material = pooledBox.lambertMaterial;
      }
    }

    <span class="keyword">if</span> (resetTheSpinThingy) {
      pooledBox.startCountdown = SPINFRAMES;
      resetTheSpinThingy = <span class="literal">false</span>;
      doTheSpinThingy = <span class="literal">true</span>;
    }
    <span class="keyword">if</span> (doTheSpinThingy) pooledBox.startCountdown--;
    <span class="keyword">if</span> (pooledBox.startCountdown === -<span class="number">1</span>) doTheSpinThingy = <span class="literal">false</span>;

    pooledBox.mesh.isLine = <span class="literal">false</span>;
    pooledBox.mesh.isRectangle = <span class="literal">false</span>;
    pooledBox.mesh.isBox = <span class="literal">true</span>;
    pooledBox.mesh.isCylinder = <span class="literal">false</span>;
    pooledBox.mesh.isAmbientLight = <span class="literal">false</span>;
    pooledBox.mesh.isPointLight = <span class="literal">false</span>;
    pooledBox.mesh.isSphere = <span class="number">0</span>;
    pooledBox.mesh.doubleSided = <span class="literal">false</span>;


    usedBoxes++;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledBox.startCountdown &gt; <span class="number">0</span>) {
      pushMatrix();
      rotate(pooledBox.startCountdown / <span class="number">50</span>);
      log(<span class="string">""</span>+pooledBox.startCountdown);
    }

    pooledBox.mesh.matrixAutoUpdate = <span class="literal">false</span>;
    pooledBox.mesh.matrix.copy(worldMatrix);
    pooledBox.mesh.matrixWorldNeedsUpdate = <span class="literal">true</span>;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledBox.startCountdown &gt; <span class="number">0</span>) {
      popMatrix();
    }

</pre></div>             </td>           </tr>                               <tr id="section-28">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-28">&#182;</a>               </div>               <p>TODO: meshes should be built from geometries that are
ever so slight larger than the "fill" mesh so there
is no z-fighting...
constant 0.001 below is to avoid z-fighting</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (a !== <span class="number">1</span> || b !== <span class="number">1</span> || c !== <span class="number">1</span>) {
      <span class="keyword">if</span> (!strokeTime) pooledBox.mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(a, b, c));
      <span class="keyword">else</span> pooledBox.mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(a + <span class="number">0.001</span>, b + <span class="number">0.001</span>, c + <span class="number">0.001</span>));
    }

    <span class="keyword">if</span> (newBoxCreated) scene.add(pooledBox.mesh);
  }


}


<span class="keyword">var</span> peg = <span class="keyword">function</span>(a, b, c) {
</pre></div>             </td>           </tr>                               <tr id="section-29">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-29">&#182;</a>               </div>               <p>simple case - if there is no fill and
no stroke then there is nothing to do.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">var</span> startIndex = <span class="number">0</span>;
  <span class="keyword">var</span> endIndex = <span class="number">0</span>;

  <span class="keyword">if</span> (!doFill &amp;&amp; !doStroke) {
    <span class="keyword">return</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-30">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-30">&#182;</a>               </div>               <p>if the wireframe is not going to be visible on top of the
fill then don't draw it</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">else</span> <span class="keyword">if</span> ((doFill &amp;&amp; (currentStrokeSize === <span class="number">0</span> || !doStroke || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; !defaultNormalFill &amp;&amp; !defaultNormalStroke &amp;&amp; currentStrokeColor === currentFillColor &amp;&amp; currentFillAlpha === <span class="number">1</span> &amp;&amp; currentStrokeAlpha === <span class="number">1</span>))) || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; defaultNormalFill &amp;&amp; defaultNormalStroke)) {
</pre></div>             </td>           </tr>                               <tr id="section-31">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-31">&#182;</a>               </div>               <p>if (doStroke) log('smart optimisation, was supposed to do the stroke but not doing it!!');</p>             </td>             <td class="code">               <div class="highlight"><pre>    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">1</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (!doFill &amp;&amp; doStroke) {
    startIndex = <span class="number">1</span>;
    endIndex = <span class="number">2</span>;
  } <span class="keyword">else</span> {
    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">2</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-32">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-32">&#182;</a>               </div>               <p>log("si: " + startIndex + " endI: " + endIndex );</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-33">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-33">&#182;</a>               </div>               <p>alert('cube!')</p>             </td>             <td class="code">               <div class="highlight"><pre>    a = <span class="number">1</span>;
    b = <span class="number">1</span>;
    c = <span class="number">1</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    b = a;
    c = a;
  }

  <span class="keyword">var</span> strokeTime = <span class="literal">false</span>;
  <span class="keyword">var</span> colorToBeUsed;
  <span class="keyword">var</span> alphaToBeUsed;
  <span class="keyword">var</span> newCylinderCreated = <span class="literal">false</span>;


</pre></div>             </td>           </tr>                               <tr id="section-34">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-34">&#182;</a>               </div>               <p>this is to run the code twice. This should be neater
and turned into a function call really.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">for</span> (<span class="keyword">var</span> fillAndStroke = startIndex; fillAndStroke &lt; endIndex; fillAndStroke++) {
    <span class="keyword">if</span> (fillAndStroke === <span class="number">1</span>) {
      strokeTime = <span class="literal">true</span>;
      colorToBeUsed = currentStrokeColor;
      alphaToBeUsed = currentStrokeAlpha;
    } <span class="keyword">else</span> {
      colorToBeUsed = currentFillColor;
      alphaToBeUsed = currentFillAlpha;
    }
    <span class="keyword">var</span> pooledCylinder = cylindersPool[usedCylinders];
    <span class="keyword">if</span> (pooledCylinder === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-35">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-35">&#182;</a>               </div>               <p>each pooled cylinder contains a geometry,
a basic material and a lambert material.</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledCylinder = {
        basicMaterial: <span class="literal">undefined</span>,
        lambertMaterial: <span class="literal">undefined</span>,
        normalMaterial: <span class="literal">undefined</span>,
</pre></div>             </td>           </tr>                               <tr id="section-36">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-36">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, otherwise the
more complicated materials won't show
up, see:
https://github.com/mrdoob/three.js/issues/1051
so we always need to create a normalmaterial
and render that material first, in case
the user will ever want to use it.
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>        neverUsed: <span class="literal">true</span>,
        mesh: <span class="literal">undefined</span>
      };
      newCylinderCreated = <span class="literal">true</span>;
      cylindersPool.push(pooledCylinder);
    }
    <span class="keyword">var</span> applyDefaultNormalColor = <span class="literal">false</span>;
    <span class="keyword">if</span> (!strokeTime) {
      <span class="keyword">if</span> (defaultNormalFill) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (defaultNormalStroke) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    }
    <span class="keyword">if</span> (pooledCylinder.neverUsed || (colorToBeUsed === angleColor || applyDefaultNormalColor)) {
</pre></div>             </td>           </tr>                               <tr id="section-37">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-37">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, see:
https://github.com/mrdoob/three.js/issues/1051
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledCylinder.neverUsed = <span class="literal">false</span>;
      <span class="keyword">if</span> (pooledCylinder.normalMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating normal material"</span>);
        pooledCylinder.normalMaterial = <span class="keyword">new</span> THREE.MeshNormalMaterial({
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize,
        });
      } <span class="keyword">else</span> {
        pooledCylinder.normalMaterial.opacity = alphaToBeUsed;
        pooledCylinder.normalMaterial.wireframe = strokeTime;
        pooledCylinder.normalMaterial.wireframeLinewidth = currentStrokeSize;
        pooledCylinder.normalMaterial.doubleSided = <span class="literal">false</span>;
      }
      <span class="keyword">if</span> (pooledCylinder.mesh === <span class="literal">undefined</span>) {
        pooledCylinder.mesh = <span class="keyword">new</span> THREE.Mesh(cylinderGeometry, pooledCylinder.normalMaterial);
        pooledCylinder.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-38">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-38">&#182;</a>               </div>               <p>//        log("associating normal material to existing mesh");</p>             </td>             <td class="code">               <div class="highlight"><pre>        pooledCylinder.mesh.material = pooledCylinder.normalMaterial;
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (!lightsAreOn) {
      <span class="keyword">if</span> (pooledCylinder.basicMaterial === <span class="literal">undefined</span>) {
        pooledCylinder.basicMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize,
        });
      } <span class="keyword">else</span> {
        pooledCylinder.basicMaterial.color.setHex(colorToBeUsed);
        pooledCylinder.basicMaterial.opacity = alphaToBeUsed;
        pooledCylinder.basicMaterial.wireframe = strokeTime;
        pooledCylinder.basicMaterial.wireframeLinewidth = currentStrokeSize;
        pooledCylinder.basicMaterial.doubleSided = <span class="literal">false</span>;
      }
      <span class="keyword">if</span> (pooledCylinder.mesh === <span class="literal">undefined</span>) {
        pooledCylinder.mesh = <span class="keyword">new</span> THREE.Mesh(cylinderGeometry, pooledCylinder.basicMaterial);
        pooledCylinder.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledCylinder.mesh.material = pooledCylinder.basicMaterial;
      }

    }
</pre></div>             </td>           </tr>                               <tr id="section-39">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-39">&#182;</a>               </div>               <p>lights are on</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">else</span> {
      <span class="keyword">if</span> (pooledCylinder.lambertMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating lambert:"</span>+currentFillColor+<span class="string">" "</span>+currentFillAlpha+<span class="string">" "</span>+ambientColor+<span class="string">" "</span>+reflectValue+<span class="string">" "</span>+refractValue);
        pooledCylinder.lambertMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          ambient: ambientColor,
          reflectivity: reflectValue,
          refractionRatio: refractValue,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize,
        });
      } <span class="keyword">else</span> {
        pooledCylinder.lambertMaterial.color.setHex(colorToBeUsed);
        pooledCylinder.lambertMaterial.opacity = alphaToBeUsed;
        pooledCylinder.lambertMaterial.wireframe = strokeTime;
        pooledCylinder.lambertMaterial.wireframeLinewidth = currentStrokeSize;
        pooledCylinder.lambertMaterial.doubleSided = <span class="literal">false</span>;
        pooledCylinder.lambertMaterial.ambient.setHex(ambientColor);
        pooledCylinder.lambertMaterial.reflectivity = reflectValue;
        pooledCylinder.lambertMaterial.refractionRatio = refractValue;
      }
      <span class="keyword">if</span> (pooledCylinder.mesh === <span class="literal">undefined</span>) {
        pooledCylinder.mesh = <span class="keyword">new</span> THREE.Mesh(cylinderGeometry, pooledCylinder.lambertMaterial);
        pooledCylinder.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledCylinder.mesh.material = pooledCylinder.lambertMaterial;
      }
    }

    <span class="keyword">if</span> (resetTheSpinThingy) {
      pooledCylinder.startCountdown = SPINFRAMES;
      resetTheSpinThingy = <span class="literal">false</span>;
      doTheSpinThingy = <span class="literal">true</span>;
    }
    <span class="keyword">if</span> (doTheSpinThingy) pooledCylinder.startCountdown--;
    <span class="keyword">if</span> (pooledCylinder.startCountdown === -<span class="number">1</span>) doTheSpinThingy = <span class="literal">false</span>;

    pooledCylinder.mesh.isLine = <span class="literal">false</span>;
    pooledCylinder.mesh.isRectangle = <span class="literal">false</span>;
    pooledCylinder.mesh.isBox = <span class="literal">false</span>;
    pooledCylinder.mesh.isCylinder = <span class="literal">true</span>;
    pooledCylinder.mesh.isAmbientLight = <span class="literal">false</span>;
    pooledCylinder.mesh.isPointLight = <span class="literal">false</span>;
    pooledCylinder.mesh.isSphere = <span class="number">0</span>;
    pooledCylinder.mesh.doubleSided = <span class="literal">false</span>;


    usedCylinders++;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledCylinder.startCountdown &gt; <span class="number">0</span>) {
      pushMatrix();
      rotate(pooledCylinder.startCountdown / <span class="number">50</span>);
      log(<span class="string">""</span>+pooledCylinder.startCountdown);      
    }

    pooledCylinder.mesh.matrixAutoUpdate = <span class="literal">false</span>;
    pooledCylinder.mesh.matrix.copy(worldMatrix);
    pooledCylinder.mesh.matrixWorldNeedsUpdate = <span class="literal">true</span>;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledCylinder.startCountdown &gt; <span class="number">0</span>) {
      popMatrix();
    }

</pre></div>             </td>           </tr>                               <tr id="section-40">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-40">&#182;</a>               </div>               <p>TODO: meshes should be built from geometries that are
ever so slight larger than the "fill" mesh so there
is no z-fighting...
constant 0.001 below is to avoid z-fighting</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (a !== <span class="number">1</span> || b !== <span class="number">1</span> || c !== <span class="number">1</span>) {
      <span class="keyword">if</span> (!strokeTime) pooledCylinder.mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(a, b, c));
      <span class="keyword">else</span> pooledCylinder.mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(a + <span class="number">0.001</span>, b + <span class="number">0.001</span>, c + <span class="number">0.001</span>));
    }

    <span class="keyword">if</span> (newCylinderCreated) scene.add(pooledCylinder.mesh);
  }


}


<span class="keyword">var</span> ballDetail = <span class="keyword">function</span>(a) {
  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) <span class="keyword">return</span>;
  <span class="keyword">if</span> (a &lt; <span class="number">2</span>) a = <span class="number">2</span>;
  <span class="keyword">if</span> (a &gt; <span class="number">30</span>) a = <span class="number">30</span>;
  ballDetLevel = a;
}

<span class="keyword">var</span> ball = <span class="keyword">function</span>(a) {
  <span class="keyword">var</span> pooledSphereGeometry;
</pre></div>             </td>           </tr>                               <tr id="section-41">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-41">&#182;</a>               </div>               <p>simple case - if there is no fill and
no stroke then there is nothing to do.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">var</span> startIndex = <span class="number">0</span>;
  <span class="keyword">var</span> endIndex = <span class="number">0</span>;

  log(<span class="string">"fill: "</span>+doFill+<span class="string">" stroke: "</span>+doStroke+<span class="string">" fillCol "</span> + currentFillColor + <span class="string">" stroke col "</span> + currentStrokeColor + <span class="string">" fill alpha "</span> + currentFillAlpha);
  <span class="keyword">if</span> (!doFill &amp;&amp; !doStroke) {
    <span class="keyword">return</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-42">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-42">&#182;</a>               </div>               <p>if the wireframe is not going to be visible on top of the
fill then don't draw it</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">else</span> <span class="keyword">if</span> ((doFill &amp;&amp; (currentStrokeSize === <span class="number">0</span> || !doStroke || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; !defaultNormalFill &amp;&amp; !defaultNormalStroke &amp;&amp; currentStrokeColor === currentFillColor &amp;&amp; currentFillAlpha === <span class="number">1</span> &amp;&amp; currentStrokeAlpha === <span class="number">1</span>))) || (currentStrokeSize &lt;= <span class="number">1</span> &amp;&amp; defaultNormalFill &amp;&amp; defaultNormalStroke)) {
</pre></div>             </td>           </tr>                               <tr id="section-43">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-43">&#182;</a>               </div>               <p>if (doStroke) log('smart optimisation, was supposed to do the stroke but not doing it!!');</p>             </td>             <td class="code">               <div class="highlight"><pre>    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">1</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (!doFill &amp;&amp; doStroke) {
    startIndex = <span class="number">1</span>;
    endIndex = <span class="number">2</span>;
  } <span class="keyword">else</span> {
    startIndex = <span class="number">0</span>;
    endIndex = <span class="number">2</span>;
  }
</pre></div>             </td>           </tr>                               <tr id="section-44">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-44">&#182;</a>               </div>               <p>log("si: " + startIndex + " endI: " + endIndex );</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-45">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-45">&#182;</a>               </div>               <p>alert('ball!')</p>             </td>             <td class="code">               <div class="highlight"><pre>    a = <span class="number">1</span>;
  }

  <span class="keyword">var</span> strokeTime = <span class="literal">false</span>;
  <span class="keyword">var</span> colorToBeUsed;
  <span class="keyword">var</span> alphaToBeUsed;
  <span class="keyword">var</span> newSphereCreated = <span class="literal">false</span>;


</pre></div>             </td>           </tr>                               <tr id="section-46">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-46">&#182;</a>               </div>               <p>this is to run the code twice. This should be neater
and turned into a function call really.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="keyword">for</span> (<span class="keyword">var</span> fillAndStroke = startIndex; fillAndStroke &lt; endIndex; fillAndStroke++) {
    <span class="keyword">if</span> (fillAndStroke === <span class="number">1</span>) {
      strokeTime = <span class="literal">true</span>;
      colorToBeUsed = currentStrokeColor;
      alphaToBeUsed = currentStrokeAlpha;
    } <span class="keyword">else</span> {
      colorToBeUsed = currentFillColor;
      alphaToBeUsed = currentFillAlpha;
    }
    <span class="keyword">if</span> (spheresPool[<span class="string">''</span> + ballDetLevel] === <span class="literal">undefined</span>) {
      spheresPool[<span class="string">''</span> + ballDetLevel] = [];
      log(<span class="string">'creating pool for ball det level '</span> + ballDetLevel);
    }
    <span class="keyword">if</span> (usedSpheres[<span class="string">''</span> + ballDetLevel] === <span class="literal">undefined</span>) {
      usedSpheres[<span class="string">''</span> + ballDetLevel] = <span class="number">0</span>;
      log(<span class="string">'creating counter for ball det level '</span> + ballDetLevel);
    }
    <span class="keyword">var</span> pooledSphere = spheresPool[<span class="string">''</span> + ballDetLevel][usedSpheres[<span class="string">''</span> + ballDetLevel]];
    <span class="keyword">if</span> (pooledSphere === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-47">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-47">&#182;</a>               </div>               <p>each pooled sphere contains a geometry,
a basic material and a lambert material.</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledSphere = {
        basicMaterial: <span class="literal">undefined</span>,
        lambertMaterial: <span class="literal">undefined</span>,
        normalMaterial: <span class="literal">undefined</span>,
</pre></div>             </td>           </tr>                               <tr id="section-48">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-48">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, otherwise the
more complicated materials won't show
up, see:
https://github.com/mrdoob/three.js/issues/1051
so we always need to create a normalmaterial
and render that material first, in case
the user will ever want to use it.
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>        neverUsed: <span class="literal">true</span>,
        mesh: <span class="literal">undefined</span>
      };
      newSphereCreated = <span class="literal">true</span>;
      spheresPool[<span class="string">''</span> + ballDetLevel].push(pooledSphere);
      log(<span class="string">'making space for pool for sphere , size of pool for spheres of detail '</span> + ballDetLevel + <span class="string">' is '</span> + spheresPool[<span class="string">''</span>+ballDetLevel].length);
    }
    <span class="keyword">var</span> applyDefaultNormalColor = <span class="literal">false</span>;
    <span class="keyword">if</span> (!strokeTime) {
      <span class="keyword">if</span> (defaultNormalFill) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (defaultNormalStroke) {
        applyDefaultNormalColor = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        applyDefaultNormalColor = <span class="literal">false</span>;
      }
    }
    <span class="keyword">if</span> (pooledSphere.neverUsed || (colorToBeUsed === angleColor || applyDefaultNormalColor)) {
</pre></div>             </td>           </tr>                               <tr id="section-49">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-49">&#182;</a>               </div>               <p>the first time we render a mesh we need to
render it with the material that takes the
bigger buffer space, see:
https://github.com/mrdoob/three.js/issues/1051
Another workaround would be to create a mesh
for each different type of material</p>             </td>             <td class="code">               <div class="highlight"><pre>      pooledSphere.neverUsed = <span class="literal">false</span>;
      <span class="keyword">if</span> (pooledSphere.normalMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating normal material"</span>);
        pooledSphere.normalMaterial = <span class="keyword">new</span> THREE.MeshNormalMaterial({
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize,
        });
      } <span class="keyword">else</span> {
        pooledSphere.normalMaterial.opacity = alphaToBeUsed;
        pooledSphere.normalMaterial.wireframe = strokeTime;
        pooledSphere.normalMaterial.wireframeLinewidth = currentStrokeSize;
        pooledSphere.normalMaterial.doubleSided = <span class="literal">false</span>;
      }
      <span class="keyword">if</span> (pooledSphere.mesh === <span class="literal">undefined</span>) {
        pooledSphereGeometry = sphereGeometriesPool[<span class="string">''</span> + ballDetLevel];
        <span class="keyword">if</span> (pooledSphereGeometry === <span class="literal">undefined</span>) {
          pooledSphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">1</span>, ballDetLevel, ballDetLevel);
          sphereGeometriesPool[<span class="string">''</span> + ballDetLevel] = pooledSphereGeometry;
          log(<span class="string">'creating ball geometry of detail '</span> + ballDetLevel);
        }
        pooledSphere.mesh = <span class="keyword">new</span> THREE.Mesh(pooledSphereGeometry, pooledSphere.normalMaterial);
        pooledSphere.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
</pre></div>             </td>           </tr>                               <tr id="section-50">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-50">&#182;</a>               </div>               <pre><code>   log("associating normal material to existing mesh");
</code></pre>             </td>             <td class="code">               <div class="highlight"><pre>        pooledSphere.mesh.material = pooledSphere.normalMaterial;
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (!lightsAreOn) {
      <span class="keyword">if</span> (pooledSphere.basicMaterial === <span class="literal">undefined</span>) {
        pooledSphere.basicMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize,
        });
      } <span class="keyword">else</span> {
        pooledSphere.basicMaterial.color.setHex(colorToBeUsed);
        pooledSphere.basicMaterial.opacity = alphaToBeUsed;
        pooledSphere.basicMaterial.wireframe = strokeTime;
        pooledSphere.basicMaterial.wireframeLinewidth = currentStrokeSize;
        pooledSphere.basicMaterial.doubleSided = <span class="literal">false</span>;
      }
      <span class="keyword">if</span> (pooledSphere.mesh === <span class="literal">undefined</span>) {
        pooledSphereGeometry = sphereGeometriesPool[<span class="string">''</span> + ballDetLevel];
        <span class="keyword">if</span> (pooledSphereGeometry === <span class="literal">undefined</span>) {
          pooledSphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">1</span>, ballDetLevel, ballDetLevel);
          sphereGeometriesPool[<span class="string">''</span> + ballDetLevel] = pooledSphereGeometry;
          log(<span class="string">'creating ball geometry of detail '</span> + ballDetLevel);
        }
        pooledSphere.mesh = <span class="keyword">new</span> THREE.Mesh(pooledSphereGeometry, pooledSphere.basicMaterial);
        pooledSphere.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledSphere.mesh.material = pooledSphere.basicMaterial;
      }

    }
</pre></div>             </td>           </tr>                               <tr id="section-51">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-51">&#182;</a>               </div>               <p>lights are on</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">else</span> {
      <span class="keyword">if</span> (pooledSphere.lambertMaterial === <span class="literal">undefined</span>) {
        log(<span class="string">"creating lambert:"</span>+currentFillColor+<span class="string">" "</span>+currentFillAlpha+<span class="string">" "</span>+ambientColor+<span class="string">" "</span>+reflectValue+<span class="string">" "</span>+refractValue);
        pooledSphere.lambertMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial({
          color: colorToBeUsed,
          opacity: alphaToBeUsed,
          ambient: ambientColor,
          reflectivity: reflectValue,
          refractionRatio: refractValue,
          wireframe: strokeTime,
          wireframeLinewidth: currentStrokeSize,
        });
      } <span class="keyword">else</span> {
        pooledSphere.lambertMaterial.color.setHex(colorToBeUsed);
        pooledSphere.lambertMaterial.opacity = alphaToBeUsed;
        pooledSphere.lambertMaterial.wireframe = strokeTime;
        pooledSphere.lambertMaterial.wireframeLinewidth = currentStrokeSize;
        pooledSphere.lambertMaterial.doubleSided = <span class="literal">false</span>;
        pooledSphere.lambertMaterial.ambient.setHex(ambientColor);
        pooledSphere.lambertMaterial.reflectivity = reflectValue;
        pooledSphere.lambertMaterial.refractionRatio = refractValue;
      }
      <span class="keyword">if</span> (pooledSphere.mesh === <span class="literal">undefined</span>) {
        pooledSphereGeometry = sphereGeometriesPool[<span class="string">''</span> + ballDetLevel];
        <span class="keyword">if</span> (pooledSphereGeometry === <span class="literal">undefined</span>) {
          pooledSphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">1</span>, ballDetLevel, ballDetLevel);
          sphereGeometriesPool[<span class="string">''</span> + ballDetLevel] = pooledSphereGeometry;
          log(<span class="string">'creating ball geometry of detail '</span> + ballDetLevel);
        }
        pooledSphere.mesh = <span class="keyword">new</span> THREE.Mesh(pooledSphereGeometry, pooledSphere.lambertMaterial);
        pooledSphere.startCountdown = SPINFRAMES;
      } <span class="keyword">else</span> {
        pooledSphere.mesh.material = pooledSphere.lambertMaterial;
      }
    }

    <span class="keyword">if</span> (resetTheSpinThingy) {
      pooledSphere.startCountdown = SPINFRAMES;
      resetTheSpinThingy = <span class="literal">false</span>;
      doTheSpinThingy = <span class="literal">true</span>;
    }
    <span class="keyword">if</span> (doTheSpinThingy) pooledSphere.startCountdown--;
    <span class="keyword">if</span> (pooledSphere.startCountdown === -<span class="number">1</span>) doTheSpinThingy = <span class="literal">false</span>;

    pooledSphere.mesh.isLine = <span class="literal">false</span>;
    pooledSphere.mesh.isRectangle = <span class="literal">false</span>;
    pooledSphere.mesh.isBox = <span class="literal">false</span>;
    pooledSphere.mesh.isCylinder = <span class="literal">false</span>;
    pooledSphere.mesh.isAmbientLight = <span class="literal">false</span>;
    pooledSphere.mesh.isPointLight = <span class="literal">false</span>;
    pooledSphere.mesh.isSphere = ballDetLevel;
    pooledSphere.mesh.doubleSided = <span class="literal">false</span>;


    usedSpheres[<span class="string">''</span> + ballDetLevel] = usedSpheres[<span class="string">''</span> + ballDetLevel] + <span class="number">1</span>;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledSphere.startCountdown &gt; <span class="number">0</span>) {
      pushMatrix();
      rotate(pooledSphere.startCountdown / <span class="number">50</span>);
      log(<span class="string">""</span>+pooledSphere.startCountdown);
    }

    pooledSphere.mesh.matrixAutoUpdate = <span class="literal">false</span>;
    pooledSphere.mesh.matrix.copy(worldMatrix);
    pooledSphere.mesh.matrixWorldNeedsUpdate = <span class="literal">true</span>;

    <span class="keyword">if</span> (doTheSpinThingy &amp;&amp; pooledSphere.startCountdown &gt; <span class="number">0</span>) {
      popMatrix();
    }

</pre></div>             </td>           </tr>                               <tr id="section-52">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-52">&#182;</a>               </div>               <p>TODO: meshes should be built from geometries that are
ever so slight larger than the "fill" mesh so there
is no z-fighting...
constant 0.001 below is to avoid z-fighting</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="keyword">if</span> (a !== <span class="number">1</span>) {
      <span class="keyword">if</span> (!strokeTime) pooledSphere.mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(a, a, a));
      <span class="keyword">else</span> pooledSphere.mesh.matrix.scale(<span class="keyword">new</span> THREE.Vector3(a + <span class="number">0.001</span>, a + <span class="number">0.001</span>, a + <span class="number">0.001</span>));
    }

    <span class="keyword">if</span> (newSphereCreated) scene.add(pooledSphere.mesh);
  }


}

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 