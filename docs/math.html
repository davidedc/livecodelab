<!DOCTYPE html>  <html> <head>   <title>math.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>            <div id="jump_to">         Jump To &hellip;         <div id="jump_wrapper">           <div id="jump_page">                                           <a class="source" href="animation-controls.html">                 animation-controls.js               </a>                                           <a class="source" href="background-painting.html">                 background-painting.js               </a>                                           <a class="source" href="big-cursor-animation.html">                 big-cursor-animation.js               </a>                                           <a class="source" href="blend-style.html">                 blend-style.js               </a>                                           <a class="source" href="code-transformations.html">                 code-transformations.js               </a>                                           <a class="source" href="colour-definitions.html">                 colour-definitions.js               </a>                                           <a class="source" href="colour-functions.html">                 colour-functions.js               </a>                                           <a class="source" href="demos-and-tutorials.html">                 demos-and-tutorials.js               </a>                                           <a class="source" href="coffeescript-livecodelab-mode.html">                 coffeescript-livecodelab-mode.js               </a>                                           <a class="source" href="editor.html">                 editor.js               </a>                                           <a class="source" href="mousewheel.html">                 mousewheel.js               </a>                                           <a class="source" href="events.html">                 events.js               </a>                                           <a class="source" href="globals.html">                 globals.js               </a>                                           <a class="source" href="graphic-primitives.html">                 graphic-primitives.js               </a>                                           <a class="source" href="init-threejs.html">                 init-threejs.js               </a>                                           <a class="source" href="init.html">                 init.js               </a>                                           <a class="source" href="lights-functions.html">                 lights-functions.js               </a>                                           <a class="source" href="math.html">                 math.js               </a>                                           <a class="source" href="matrix-commands.html">                 matrix-commands.js               </a>                                           <a class="source" href="text-dimming.html">                 text-dimming.js               </a>                                           <a class="source" href="time-keeper.html">                 time-keeper.js               </a>                                           <a class="source" href="ui.html">                 ui.js               </a>                        </div>         </div>       </div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               math.js             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>               <p>Functions adapted from processing.js</p>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p>//////////////////////////////////////////////////////////////////////////
Math functions
//////////////////////////////////////////////////////////////////////////</p>             </td>             <td class="code">               <div class="highlight"><pre>
</pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>Calculation</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="comment">/**
* Calculates the absolute value (magnitude) of a number. The absolute value of a number is always positive.
*
* @param {int|float} value   int or float
*
* @returns {int|float}
*/</span>
<span class="keyword">var</span> abs = Math.abs;

<span class="comment">/**
* Calculates the closest int value that is greater than or equal to the value of the parameter.
* For example, ceil(9.03) returns the value 10.
*
* @param {float} value   float
*
* @returns {int}
*
* @see floor
* @see round
*/</span>
<span class="keyword">var</span> ceil = Math.ceil;

<span class="comment">/**
* Constrains a value to not exceed a maximum and minimum value.
*
* @param {int|float} value   the value to constrain
* @param {int|float} value   minimum limit
* @param {int|float} value   maximum limit
*
* @returns {int|float}
*
* @see max
* @see min
*/</span>
<span class="keyword">var</span> constrain = <span class="keyword">function</span>(aNumber, aMin, aMax) {
	<span class="keyword">return</span> aNumber &gt; aMax ? aMax : aNumber &lt; aMin ? aMin : aNumber;
};

<span class="comment">/**
* Calculates the distance between two points.
*
* @param {int|float} x1     int or float: x-coordinate of the first point
* @param {int|float} y1     int or float: y-coordinate of the first point
* @param {int|float} z1     int or float: z-coordinate of the first point
* @param {int|float} x2     int or float: x-coordinate of the second point
* @param {int|float} y2     int or float: y-coordinate of the second point
* @param {int|float} z2     int or float: z-coordinate of the second point
*
* @returns {float}
*/</span>
<span class="keyword">var</span> dist = <span class="keyword">function</span>() {
	<span class="keyword">var</span> dx, dy, dz;
	<span class="keyword">if</span> (arguments.length === <span class="number">4</span>) {
		dx = arguments[<span class="number">0</span>] - arguments[<span class="number">2</span>];
		dy = arguments[<span class="number">1</span>] - arguments[<span class="number">3</span>];
		<span class="keyword">return</span> Math.sqrt(dx * dx + dy * dy);
	}
	<span class="keyword">if</span> (arguments.length === <span class="number">6</span>) {
		dx = arguments[<span class="number">0</span>] - arguments[<span class="number">3</span>];
		dy = arguments[<span class="number">1</span>] - arguments[<span class="number">4</span>];
		dz = arguments[<span class="number">2</span>] - arguments[<span class="number">5</span>];
		<span class="keyword">return</span> Math.sqrt(dx * dx + dy * dy + dz * dz);
	}
};

<span class="comment">/**
* Returns Euler's number e (2.71828...) raised to the power of the value parameter.
*
* @param {int|float} value   int or float: the exponent to raise e to
*
* @returns {float}
*/</span>
<span class="keyword">var</span> exp = Math.exp;

<span class="comment">/**
* Calculates the closest int value that is less than or equal to the value of the parameter.
*
* @param {int|float} value        the value to floor
*
* @returns {int|float}
*
* @see ceil
* @see round
*/</span>
<span class="keyword">var</span> floor = Math.floor;

<span class="comment">/**
* Calculates a number between two numbers at a specific increment. The amt  parameter is the
* amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very
* near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for
* creating motion along a straight path and for drawing dotted lines.
*
* @param {int|float} value1       float or int: first value
* @param {int|float} value2       float or int: second value
* @param {int|float} amt          float: between 0.0 and 1.0
*
* @returns {float}
*
* @see curvePoint
* @see bezierPoint
*/</span>
<span class="keyword">var</span> lerp = <span class="keyword">function</span>(value1, value2, amt) {
	<span class="keyword">return</span> ((value2 - value1) * amt) + value1;
};

<span class="comment">/**
* Calculates the natural logarithm (the base-e logarithm) of a number. This function
* expects the values greater than 0.0.
*
* @param {int|float} value        int or float: number must be greater then 0.0
*
* @returns {float}
*/</span>
<span class="keyword">var</span> log = Math.log;

<span class="comment">/**
* Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly
* used in computer graphics and linear algebra. Because it has no "start" position, the magnitude
* of a vector can be thought of as the distance from coordinate (0,0) to its (x,y) value.
* Therefore, mag() is a shortcut for writing "dist(0, 0, x, y)".
*
* @param {int|float} a       float or int: first value
* @param {int|float} b       float or int: second value
* @param {int|float} c       float or int: third value
*
* @returns {float}
*
* @see dist
*/</span>
<span class="keyword">var</span> mag = <span class="keyword">function</span>(a, b, c) {
	<span class="keyword">if</span> (c) {
		<span class="keyword">return</span> Math.sqrt(a * a + b * b + c * c);
	}

	<span class="keyword">return</span> Math.sqrt(a * a + b * b);
};

<span class="comment">/**
* Re-maps a number from one range to another. In the example above, the number '25' is converted from
* a value in the range 0..100 into a value that ranges from the left edge (0) to the right edge (width) of the screen.
* Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.
*
* @param {float} value        The incoming value to be converted
* @param {float} istart       Lower bound of the value's current range
* @param {float} istop        Upper bound of the value's current range
* @param {float} ostart       Lower bound of the value's target range
* @param {float} ostop        Upper bound of the value's target range
*
* @returns {float}
*
* @see norm
* @see lerp
*/</span>
<span class="keyword">var</span> map = <span class="keyword">function</span>(value, istart, istop, ostart, ostop) {
	<span class="keyword">return</span> ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
};

<span class="comment">/**
* Determines the largest value in a sequence of numbers.
*
* @param {int|float} value1         int or float
* @param {int|float} value2         int or float
* @param {int|float} value3         int or float
* @param {int|float} array          int or float array
*
* @returns {int|float}
*
* @see min
*/</span>
<span class="keyword">var</span> max = <span class="keyword">function</span>() {
	<span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
		<span class="keyword">return</span> arguments[<span class="number">0</span>] &lt; arguments[<span class="number">1</span>] ? arguments[<span class="number">1</span>] : arguments[<span class="number">0</span>];
	}
	<span class="keyword">var</span> numbers = arguments.length === <span class="number">1</span> ? arguments[<span class="number">0</span>] : arguments; <span class="comment">// if single argument, array is used</span>
	<span class="keyword">if</span> (! (<span class="string">"length"</span> <span class="keyword">in</span> numbers &amp;&amp; numbers.length &gt; <span class="number">0</span>)) {
		<span class="keyword">throw</span> <span class="string">"Non-empty array is expected"</span>;
	}
	<span class="keyword">var</span> max = numbers[<span class="number">0</span>],
		count = numbers.length;
	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; count; ++i) {
		<span class="keyword">if</span> (max &lt; numbers[i]) {
			max = numbers[i];
		}
	}
	<span class="keyword">return</span> max;
};

<span class="comment">/**
* Determines the smallest value in a sequence of numbers.
*
* @param {int|float} value1         int or float
* @param {int|float} value2         int or float
* @param {int|float} value3         int or float
* @param {int|float} array          int or float array
*
* @returns {int|float}
*
* @see max
*/</span>
<span class="keyword">var</span> min = <span class="keyword">function</span>() {
	<span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
		<span class="keyword">return</span> arguments[<span class="number">0</span>] &lt; arguments[<span class="number">1</span>] ? arguments[<span class="number">0</span>] : arguments[<span class="number">1</span>];
	}
	<span class="keyword">var</span> numbers = arguments.length === <span class="number">1</span> ? arguments[<span class="number">0</span>] : arguments; <span class="comment">// if single argument, array is used</span>
	<span class="keyword">if</span> (! (<span class="string">"length"</span> <span class="keyword">in</span> numbers &amp;&amp; numbers.length &gt; <span class="number">0</span>)) {
		<span class="keyword">throw</span> <span class="string">"Non-empty array is expected"</span>;
	}
	<span class="keyword">var</span> min = numbers[<span class="number">0</span>],
		count = numbers.length;
	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; count; ++i) {
		<span class="keyword">if</span> (min &gt; numbers[i]) {
			min = numbers[i];
		}
	}
	<span class="keyword">return</span> min;
};

<span class="comment">/**
* Normalizes a number from another range into a value between 0 and 1.
* Identical to map(value, low, high, 0, 1);
* Numbers outside the range are not clamped to 0 and 1, because out-of-range
* values are often intentional and useful.
*
* @param {float} aNumber    The incoming value to be converted
* @param {float} low        Lower bound of the value's current range
* @param {float} high       Upper bound of the value's current range
*
* @returns {float}
*
* @see map
* @see lerp
*/</span>
<span class="keyword">var</span> norm = <span class="keyword">function</span>(aNumber, low, high) {
	<span class="keyword">return</span> (aNumber - low) / (high - low);
};

<span class="comment">/**
* Facilitates exponential expressions. The pow() function is an efficient way of
* multiplying numbers by themselves (or their reciprocal) in large quantities.
* For example, pow(3, 5) is equivalent to the expression 3*3*3*3*3 and pow(3, -5)
* is equivalent to 1 / 3*3*3*3*3.
*
* @param {int|float} num        base of the exponential expression
* @param {int|float} exponent   power of which to raise the base
*
* @returns {float}
*
* @see sqrt
*/</span>
<span class="keyword">var</span> pow = Math.pow;

<span class="comment">/**
* Calculates the integer closest to the value parameter. For example, round(9.2) returns the value 9.
*
* @param {float} value        number to round
*
* @returns {int}
*
* @see floor
* @see ceil
*/</span>
<span class="keyword">var</span> round = Math.round;

<span class="comment">/**
* Squares a number (multiplies a number by itself). The result is always a positive number,
* as multiplying two negative numbers always yields a positive result. For example, -1 * -1 = 1.
*
* @param {float} value        int or float
*
* @returns {float}
*
* @see sqrt
*/</span>
<span class="keyword">var</span> sq = <span class="keyword">function</span>(aNumber) {
	<span class="keyword">return</span> aNumber * aNumber;
};

<span class="comment">/**
* Calculates the square root of a number. The square root of a number is always positive,
* even though there may be a valid negative root. The square root s of number a is such
* that s*s = a. It is the opposite of squaring.
*
* @param {float} value        int or float, non negative
*
* @returns {float}
*
* @see pow
* @see sq
*/</span>
<span class="keyword">var</span> sqrt = Math.sqrt;

</pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p>Trigonometry</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="comment">/**
* The inverse of cos(), returns the arc cosine of a value. This function expects the
* values in the range of -1 to 1 and values are returned in the range 0 to PI (3.1415927).
*
* @param {float} value        the value whose arc cosine is to be returned
*
* @returns {float}
*
* @see cos
* @see asin
* @see atan
*/</span>
<span class="keyword">var</span> acos = Math.acos;

<span class="comment">/**
* The inverse of sin(), returns the arc sine of a value. This function expects the values
* in the range of -1 to 1 and values are returned in the range -PI/2 to PI/2.
*
* @param {float} value        the value whose arc sine is to be returned
*
* @returns {float}
*
* @see sin
* @see acos
* @see atan
*/</span>
<span class="keyword">var</span> asin = Math.asin;

<span class="comment">/**
* The inverse of tan(), returns the arc tangent of a value. This function expects the values
* in the range of -Infinity to Infinity (exclusive) and values are returned in the range -PI/2 to PI/2 .
*
* @param {float} value        -Infinity to Infinity (exclusive)
*
* @returns {float}
*
* @see tan
* @see asin
* @see acos
*/</span>
<span class="keyword">var</span> atan = Math.atan;

<span class="comment">/**
* Calculates the angle (in radians) from a specified point to the coordinate origin as measured from
* the positive x-axis. Values are returned as a float in the range from PI to -PI. The atan2() function
* is most often used for orienting geometry to the position of the cursor. Note: The y-coordinate of the
* point is the first parameter and the x-coordinate is the second due the the structure of calculating the tangent.
*
* @param {float} y        y-coordinate of the point
* @param {float} x        x-coordinate of the point
*
* @returns {float}
*
* @see tan
*/</span>
<span class="keyword">var</span> atan2 = Math.atan2;

<span class="comment">/**
* Calculates the cosine of an angle. This function expects the values of the angle parameter to be provided
* in radians (values from 0 to PI*2). Values are returned in the range -1 to 1.
*
* @param {float} value        an angle in radians
*
* @returns {float}
*
* @see tan
* @see sin
*/</span>
<span class="keyword">var</span> cos = Math.cos;

<span class="comment">/**
* Converts a radian measurement to its corresponding value in degrees. Radians and degrees are two ways of
* measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,
* 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.
*
* @param {int|float} value        an angle in radians
*
* @returns {float}
*
* @see radians
*/</span>
<span class="keyword">var</span> degrees = <span class="keyword">function</span>(aAngle) {
	<span class="keyword">return</span> (aAngle * <span class="number">180</span>) / Math.PI;
};

<span class="comment">/**
* Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of
* measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,
* 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.
*
* @param {int|float} value        an angle in radians
*
* @returns {float}
*
* @see degrees
*/</span>
<span class="keyword">var</span> radians = <span class="keyword">function</span>(aAngle) {
	<span class="keyword">return</span> (aAngle / <span class="number">180</span>) * Math.PI;
};

<span class="comment">/**
* Calculates the sine of an angle. This function expects the values of the angle parameter to be provided in
* radians (values from 0 to 6.28). Values are returned in the range -1 to 1.
*
* @param {float} value        an angle in radians
*
* @returns {float}
*
* @see cos
* @see radians
*/</span>
<span class="keyword">var</span> sin = Math.sin;

<span class="comment">/**
* Calculates the ratio of the sine and cosine of an angle. This function expects the values of the angle
* parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range infinity to -infinity.
*
* @param {float} value        an angle in radians
*
* @returns {float}
*
* @see cos
* @see sin
* @see radians
*/</span>
<span class="keyword">var</span> tan = Math.tan;

<span class="keyword">var</span> currentRandom = Math.random;

<span class="comment">/**
* Generates random numbers. Each time the random() function is called, it returns an unexpected value within
* the specified range. If one parameter is passed to the function it will return a float between zero and the
* value of the high parameter. The function call random(5) returns values between 0 and 5 (starting at zero,
* up to but not including 5). If two parameters are passed, it will return a float with a value between the
* parameters. The function call random(-5, 10.2) returns values starting at -5 up to (but not including) 10.2.
* To convert a floating-point random number to an integer, use the int() function.
*
* @param {int|float} value1         if one parameter is used, the top end to random from, if two params the low end
* @param {int|float} value2         the top end of the random range
*
* @returns {float}
*
* @see randomSeed
* @see noise
*/</span>
<span class="keyword">var</span> random = <span class="keyword">function</span>() {
	<span class="keyword">if</span>(arguments.length === <span class="number">0</span>) {
		<span class="keyword">return</span> currentRandom();
	}
	<span class="keyword">if</span>(arguments.length === <span class="number">1</span>) {
		<span class="keyword">return</span> currentRandom() * arguments[<span class="number">0</span>];
	}
	<span class="keyword">var</span> aMin = arguments[<span class="number">0</span>], aMax = arguments[<span class="number">1</span>];
	<span class="keyword">return</span> currentRandom() * (aMax - aMin) + aMin;
};

</pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>Pseudo-random generator</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="keyword">var</span> Marsaglia = <span class="keyword">function</span>(i1, i2) {
</pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c</p>             </td>             <td class="code">               <div class="highlight"><pre>	<span class="keyword">var</span> z=i1 || <span class="number">362436069</span>, w= i2 || <span class="number">521288629</span>;
	<span class="keyword">var</span> nextInt = <span class="keyword">function</span>() {
		z=(<span class="number">36969</span>*(z&amp;<span class="number">65535</span>)+(z&gt;&gt;&gt;<span class="number">16</span>)) &amp; <span class="number">0xFFFFFFFF</span>;
		w=(<span class="number">18000</span>*(w&amp;<span class="number">65535</span>)+(w&gt;&gt;&gt;<span class="number">16</span>)) &amp; <span class="number">0xFFFFFFFF</span>;
		<span class="keyword">return</span> (((z&amp;<span class="number">0xFFFF</span>)&lt;<span class="xml"><span class="tag">&lt;<span class="title">16)</span> | (<span class="attribute">w</span>&amp;<span class="attribute">0xFFFF</span>)) &amp; <span class="attribute">0xFFFFFFFF</span>;
	};

	<span class="attribute">this.nextDouble</span> = <span class="attribute">function</span>() {
		<span class="attribute">var</span> <span class="attribute">i</span> = <span class="attribute">nextInt</span>() / <span class="attribute">4294967296</span>;
		<span class="attribute">return</span> <span class="attribute">i</span> &lt; <span class="attribute">0</span> ? <span class="attribute">1</span> + <span class="attribute">i</span> <span class="attribute">:</span> <span class="attribute">i</span>;
	};
	<span class="attribute">this.nextInt</span> = <span class="attribute">nextInt</span>;
}
<span class="attribute">Marsaglia.createRandomized</span> = <span class="attribute">function</span>() {
	<span class="attribute">var</span> <span class="attribute">now</span> = <span class="attribute">new</span> <span class="attribute">Date</span>();
	<span class="attribute">return</span> <span class="attribute">new</span> <span class="attribute">Marsaglia</span>((<span class="attribute">now</span> / <span class="attribute">60000</span>) &amp; <span class="attribute">0xFFFFFFFF</span>, <span class="attribute">now</span> &amp; <span class="attribute">0xFFFFFFFF</span>);
};

/**
* <span class="attribute">Sets</span> <span class="attribute">the</span> <span class="attribute">seed</span> <span class="attribute">value</span> <span class="attribute">for</span> <span class="attribute">random</span>()<span class="attribute">.</span> <span class="attribute">By</span> <span class="attribute">default</span>, <span class="attribute">random</span>() <span class="attribute">produces</span> <span class="attribute">different</span> <span class="attribute">results</span> <span class="attribute">each</span> <span class="attribute">time</span> <span class="attribute">the</span>
* <span class="attribute">program</span> <span class="attribute">is</span> <span class="attribute">run.</span> <span class="attribute">Set</span> <span class="attribute">the</span> <span class="attribute">value</span> <span class="attribute">parameter</span> <span class="attribute">to</span> <span class="attribute">a</span> <span class="attribute">constant</span> <span class="attribute">to</span> <span class="attribute">return</span> <span class="attribute">the</span> <span class="attribute">same</span> <span class="attribute">pseudo-random</span> <span class="attribute">numbers</span>
* <span class="attribute">each</span> <span class="attribute">time</span> <span class="attribute">the</span> <span class="attribute">software</span> <span class="attribute">is</span> <span class="attribute">run.</span>
*
* @<span class="attribute">param</span> {<span class="attribute">int</span>|<span class="attribute">float</span>} <span class="attribute">seed</span>         <span class="attribute">int</span>
*
* @<span class="attribute">see</span> <span class="attribute">random</span>
* @<span class="attribute">see</span> <span class="attribute">noise</span>
* @<span class="attribute">see</span> <span class="attribute">noiseSeed</span>
*/
<span class="attribute">var</span> <span class="attribute">randomSeed</span> = <span class="attribute">function</span>(<span class="attribute">seed</span>) {
	<span class="attribute">currentRandom</span> = (<span class="attribute">new</span> <span class="attribute">Marsaglia</span>(<span class="attribute">seed</span>))<span class="attribute">.nextDouble</span>;
};

</span></pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p>Random
We have two random()'s in the code... what does this do ? and which one is current ?</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="keyword">var</span> Random = <span class="keyword">function</span>(seed) {
	<span class="keyword">var</span> haveNextNextGaussian = <span class="literal">false</span>, nextNextGaussian, random;

	<span class="keyword">this</span>.nextGaussian = <span class="keyword">function</span>() {
		<span class="keyword">if</span> (haveNextNextGaussian) {
			haveNextNextGaussian = <span class="literal">false</span>;
			<span class="keyword">return</span> nextNextGaussian;
		}
		<span class="keyword">var</span> v1, v2, s;
		<span class="keyword">do</span> {
			v1 = <span class="number">2</span> * random() - <span class="number">1</span>; <span class="comment">// between -1.0 and 1.0</span>
			v2 = <span class="number">2</span> * random() - <span class="number">1</span>; <span class="comment">// between -1.0 and 1.0</span>
			s = v1 * v1 + v2 * v2;
		}
		<span class="keyword">while</span> (s &gt;= <span class="number">1</span> || s === <span class="number">0</span>);

		<span class="keyword">var</span> multiplier = Math.sqrt(-<span class="number">2</span> * Math.log(s) / s);
		nextNextGaussian = v2 * multiplier;
		haveNextNextGaussian = <span class="literal">true</span>;

		<span class="keyword">return</span> v1 * multiplier;
	};

</pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p>by default use standard random, otherwise seeded</p>             </td>             <td class="code">               <div class="highlight"><pre>	random = (seed === <span class="literal">undefined</span>) ? Math.random : (<span class="keyword">new</span> Marsaglia(seed)).nextDouble;
};

</pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>Noise functions and helpers</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="keyword">var</span> PerlinNoise = <span class="function"><span class="keyword">function</span> <span class="params">(seed)</span> {</span>
	<span class="keyword">var</span> rnd = seed !== <span class="literal">undefined</span> ? <span class="keyword">new</span> Marsaglia(seed) : Marsaglia.createRandomized();
	<span class="keyword">var</span> i, j;
</pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>http://www.noisemachine.com/talk1/17b.html
http://mrl.nyu.edu/~perlin/noise/
generate permutation</p>             </td>             <td class="code">               <div class="highlight"><pre>	<span class="keyword">var</span> perm = <span class="keyword">new</span> Uint8Array(<span class="number">512</span>);
	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i) { perm[i] = i; }
	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i) { <span class="keyword">var</span> t = perm[j = rnd.nextInt() &amp; <span class="number">0xFF</span>]; perm[j] = perm[i]; perm[i] = t; }
</pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p>copy to avoid taking mod in perm[0];</p>             </td>             <td class="code">               <div class="highlight"><pre>	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i) { perm[i + <span class="number">256</span>] = perm[i]; }

	<span class="function"><span class="keyword">function</span> <span class="title">grad3d</span><span class="params">(i,x,y,z)</span> {</span>
		<span class="keyword">var</span> h = i &amp; <span class="number">15</span>; <span class="comment">// convert into 12 gradient directions</span>
		<span class="keyword">var</span> u = h&lt;<span class="number">8</span> ? x : y,
				v = h&lt;<span class="number">4</span> ? y : h===<span class="number">12</span>||h===<span class="number">14</span> ? x : z;
		<span class="keyword">return</span> ((h&amp;<span class="number">1</span>) === <span class="number">0</span> ? u : -u) + ((h&amp;<span class="number">2</span>) === <span class="number">0</span> ? v : -v);
	}

	<span class="function"><span class="keyword">function</span> <span class="title">grad2d</span><span class="params">(i,x,y)</span> {</span>
		<span class="keyword">var</span> v = (i &amp; <span class="number">1</span>) === <span class="number">0</span> ? x : y;
		<span class="keyword">return</span> (i&amp;<span class="number">2</span>) === <span class="number">0</span> ? -v : v;
	}

	<span class="function"><span class="keyword">function</span> <span class="title">grad1d</span><span class="params">(i,x)</span> {</span>
		<span class="keyword">return</span> (i&amp;<span class="number">1</span>) === <span class="number">0</span> ? -x : x;
	}

	<span class="function"><span class="keyword">function</span> <span class="title">lerp</span><span class="params">(t,a,b)</span> {</span> <span class="keyword">return</span> a + t * (b - a); }

	<span class="keyword">this</span>.noise3d = <span class="keyword">function</span>(x, y, z) {
		<span class="keyword">var</span> X = Math.floor(x)&amp;<span class="number">255</span>, Y = Math.floor(y)&amp;<span class="number">255</span>, Z = Math.floor(z)&amp;<span class="number">255</span>;
		x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
		<span class="keyword">var</span> fx = (<span class="number">3</span>-<span class="number">2</span>*x)*x*x, fy = (<span class="number">3</span>-<span class="number">2</span>*y)*y*y, fz = (<span class="number">3</span>-<span class="number">2</span>*z)*z*z;
		<span class="keyword">var</span> p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + <span class="number">1</span>] + Z,
				p1 = perm[X + <span class="number">1</span>] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + <span class="number">1</span>] + Z;
		<span class="keyword">return</span> lerp(fz,
			lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-<span class="number">1</span>, y, z)),
							 lerp(fx, grad3d(perm[p01], x, y-<span class="number">1</span>, z), grad3d(perm[p11], x-<span class="number">1</span>, y-<span class="number">1</span>,z))),
			lerp(fy, lerp(fx, grad3d(perm[p00 + <span class="number">1</span>], x, y, z-<span class="number">1</span>), grad3d(perm[p10 + <span class="number">1</span>], x-<span class="number">1</span>, y, z-<span class="number">1</span>)),
							 lerp(fx, grad3d(perm[p01 + <span class="number">1</span>], x, y-<span class="number">1</span>, z-<span class="number">1</span>), grad3d(perm[p11 + <span class="number">1</span>], x-<span class="number">1</span>, y-<span class="number">1</span>,z-<span class="number">1</span>))));
	};

	<span class="keyword">this</span>.noise2d = <span class="keyword">function</span>(x, y) {
		<span class="keyword">var</span> X = Math.floor(x)&amp;<span class="number">255</span>, Y = Math.floor(y)&amp;<span class="number">255</span>;
		x -= Math.floor(x); y -= Math.floor(y);
		<span class="keyword">var</span> fx = (<span class="number">3</span>-<span class="number">2</span>*x)*x*x, fy = (<span class="number">3</span>-<span class="number">2</span>*y)*y*y;
		<span class="keyword">var</span> p0 = perm[X]+Y, p1 = perm[X + <span class="number">1</span>] + Y;
		<span class="keyword">return</span> lerp(fy,
			lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-<span class="number">1</span>, y)),
			lerp(fx, grad2d(perm[p0 + <span class="number">1</span>], x, y-<span class="number">1</span>), grad2d(perm[p1 + <span class="number">1</span>], x-<span class="number">1</span>, y-<span class="number">1</span>)));
	};

	<span class="keyword">this</span>.noise1d = <span class="keyword">function</span>(x) {
		<span class="keyword">var</span> X = Math.floor(x)&amp;<span class="number">255</span>;
		x -= Math.floor(x);
		<span class="keyword">var</span> fx = (<span class="number">3</span>-<span class="number">2</span>*x)*x*x;
		<span class="keyword">return</span> lerp(fx, grad1d(perm[X], x), grad1d(perm[X+<span class="number">1</span>], x-<span class="number">1</span>));
	};
}

</pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <p>processing defaults</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="keyword">var</span> noiseProfile = { generator: <span class="literal">undefined</span>, octaves: <span class="number">4</span>, fallout: <span class="number">0.5</span>, seed: <span class="literal">undefined</span>};

<span class="comment">/**
* Returns the Perlin noise value at specified coordinates. Perlin noise is a random sequence
* generator producing a more natural ordered, harmonic succession of numbers compared to the
* standard random() function. It was invented by Ken Perlin in the 1980s and been used since
* in graphical applications to produce procedural textures, natural motion, shapes, terrains etc.
* The main difference to the random() function is that Perlin noise is defined in an infinite
* n-dimensional space where each pair of coordinates corresponds to a fixed semi-random value
* (fixed only for the lifespan of the program). The resulting value will always be between 0.0
* and 1.0. Processing can compute 1D, 2D and 3D noise, depending on the number of coordinates
* given. The noise value can be animated by moving through the noise space as demonstrated in
* the example above. The 2nd and 3rd dimension can also be interpreted as time.
* The actual noise is structured similar to an audio signal, in respect to the function's use
* of frequencies. Similar to the concept of harmonics in physics, perlin noise is computed over
* several octaves which are added together for the final result.
* Another way to adjust the character of the resulting sequence is the scale of the input
* coordinates. As the function works within an infinite space the value of the coordinates
* doesn't matter as such, only the distance between successive coordinates does (eg. when using
* noise() within a loop). As a general rule the smaller the difference between coordinates, the
* smoother the resulting noise sequence will be. Steps of 0.005-0.03 work best for most applications,
* but this will differ depending on use.
*
* @param {float} x          x coordinate in noise space
* @param {float} y          y coordinate in noise space
* @param {float} z          z coordinate in noise space
*
* @returns {float}
*
* @see random
* @see noiseDetail
*/</span>
<span class="keyword">var</span> noise = <span class="keyword">function</span>(x, y, z) {
	<span class="keyword">if</span>(noiseProfile.generator === <span class="literal">undefined</span>) {
</pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <p>caching</p>             </td>             <td class="code">               <div class="highlight"><pre>		noiseProfile.generator = <span class="keyword">new</span> PerlinNoise(noiseProfile.seed);
	}
	<span class="keyword">var</span> generator = noiseProfile.generator;
	<span class="keyword">var</span> effect = <span class="number">1</span>, k = <span class="number">1</span>, sum = <span class="number">0</span>;
	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;noiseProfile.octaves; ++i) {
		effect *= noiseProfile.fallout;
		<span class="keyword">switch</span> (arguments.length) {
		<span class="keyword">case</span> <span class="number">1</span>:
			sum += effect * (<span class="number">1</span> + generator.noise1d(k*x))/<span class="number">2</span>; <span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">2</span>:
			sum += effect * (<span class="number">1</span> + generator.noise2d(k*x, k*y))/<span class="number">2</span>; <span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">3</span>:
			sum += effect * (<span class="number">1</span> + generator.noise3d(k*x, k*y, k*z))/<span class="number">2</span>; <span class="keyword">break</span>;
		}
		k *= <span class="number">2</span>;
	}
	<span class="keyword">return</span> sum;
};

<span class="comment">/**
* Adjusts the character and level of detail produced by the Perlin noise function.
* Similar to harmonics in physics, noise is computed over several octaves. Lower octaves
* contribute more to the output signal and as such define the overal intensity of the noise,
* whereas higher octaves create finer grained details in the noise sequence. By default,
* noise is computed over 4 octaves with each octave contributing exactly half than its
* predecessor, starting at 50% strength for the 1st octave. This falloff amount can be
* changed by adding an additional function parameter. Eg. a falloff factor of 0.75 means
* each octave will now have 75% impact (25% less) of the previous lower octave. Any value
* between 0.0 and 1.0 is valid, however note that values greater than 0.5 might result in
* greater than 1.0 values returned by noise(). By changing these parameters, the signal
* created by the noise() function can be adapted to fit very specific needs and characteristics.
*
* @param {int} octaves          number of octaves to be used by the noise() function
* @param {float} falloff        falloff factor for each octave
*
* @see noise
*/</span>
<span class="keyword">var</span> noiseDetail = <span class="keyword">function</span>(octaves, fallout) {
	noiseProfile.octaves = octaves;
	<span class="keyword">if</span>(fallout !== <span class="literal">undefined</span>) {
		noiseProfile.fallout = fallout;
	}
};

<span class="comment">/**
* Sets the seed value for noise(). By default, noise() produces different results each
* time the program is run. Set the value parameter to a constant to return the same
* pseudo-random numbers each time the software is run.
*
* @param {int} seed         int
*
* @returns {float}
*
* @see random
* @see radomSeed
* @see noise
* @see noiseDetail
*/</span>
<span class="keyword">var</span> noiseSeed = <span class="keyword">function</span>(seed) {
	noiseProfile.seed = seed;
	noiseProfile.generator = <span class="literal">undefined</span>;
};


</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 