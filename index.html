<!doctype html>
<html>
	<head>
		<title>Livecodelab</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
			
		<script src="vendor/three.js/Three.js"></script>
		<script src="vendor/three.js/Detector.js"></script>
		<script src="vendor/three.js/Stats.js"></script>

		<script src="vendor/threex/THREEx.WindowResize.js"></script>
		<script type="text/javascript" src="coffee-script.js"></script>

		<script src="vendor/three.js/ShaderExtras.js"></script>
		<script src="vendor/three.js/postprocessing/EffectComposer.js"></script>
		<script src="vendor/three.js/postprocessing/RenderPass.js"></script>
		<script src="vendor/three.js/postprocessing/ShaderPass.js"></script>
		<!--
			 surprisingly MaskPass.js is needed even though masks are not
		     explicitely used
		-->
		<script src="vendor/three.js/postprocessing/MaskPass.js"></script>
		<script src="vendor/three.js/postprocessing/SavePass.js"></script>


		<link  href="css/main.css" rel="stylesheet"/>
		<link rel="stylesheet" href="codemirror.css">
		<script src="codemirror.js"></script>
		<link rel="stylesheet" href="night.css">
		<script src="coffeescriptModified.js"></script>
		<script src="jquery.min.js"></script>

		<style type="text/css">
		  .CodeMirror {border: none; }
		</style>

			<style type="text/css">
					a:hover {cursor: default;}
					.dd_menu {background:#000000; border-bottom: 1px; border-bottom-color: white; border-bottom-style: dotted; padding:0px; margin:0; list-style-type:none; height:30px;}
					.dd_menu li {float:left; height:30px; border-right: solid 1px white; border-right-style: dotted;}
					.dd_menu li a {padding:9px 20px; display:block; color:#fff; text-decoration:none; font:12px arial, verdana, sans-serif; font-weight: bold; }
					.dd_menu li:hover a {color:black;}
					
					.dd_menu ul { position:absolute; left:-9999px; top:-9999px; list-style-type:none;}
					.dd_menu li:hover {position:relative; background:white;}
					.dd_menu li:hover ul {left:0px; top:30px; background:#000000; padding:3px; border:0px solid white; width:160px;}
					.dd_menu li:hover ul li {height:18px; border:none; }
					.dd_menu li:hover ul li a {height:18px; padding:0px; display:block; font-size:11px; width:158px; line-height:18px; text-indent:15px; color:white; background-color:#000000; text-decoration:none;  border-top: 1px; border-top-color: #111111; border-top-style: dotted;}
					.dd_menu li:hover ul li a:hover {height:18px; background:silver; color:#000; border:solid 1px #444; }
					
					#dangerSignText {color:#000000; text-decoration:none;}
					#dangerSign:hover {background:#000000;}

					#errorMessageText {text-decoration:none;}
					#errorMessage:hover {background:#000000;}
					
					.verticalMiddleOfScreen        
						{
						color: white;
						background-color: transparent;
						text-align: center;
						position: absolute;
						top: 50%;
						left: 0px;
						width: 100%;
						height: 1px;
						overflow: visible;
						visibility: visible;
						display: block
						}
					
					.fakeAnimationContent    
						{
						font-family: Verdana, Geneva, Arial, sans-serif;
						background-color: transparent;
						margin-left: -1.5em;
						position: absolute;
						top: -1.1em;
						left: 50%;
						width: 3em;
						height: 2em;
						padding-top: 0px;
						visibility: visible
						}
    
			</style>
		<!-- end of second drop-down menu -->

		<!-- start simple modal -->
			<!-- Page styles -->
			<link type='text/css' href='simpleModal/css/demo.css' rel='stylesheet' media='screen' />			
			<!-- Contact Form CSS files -->
			<link type='text/css' href='simpleModal/css/basic.css' rel='stylesheet' media='screen' />
			<!-- Scripts -->
			<script type='text/javascript' src='simpleModal/js/jquery.js'></script>
			<script type='text/javascript' src='simpleModal/js/jquery.simplemodal.js'></script>
		<!-- end simple modal -->

	</head>
<body>



<div class="verticalMiddleOfScreen" id="toMove" style="font-size:30em;">
    <div class="fakeAnimationContent" >
        <p id="caption"></p>
    </div>
</div>
<div class="verticalMiddleOfScreen" id="justForFakeCursor" style="font-size:30em;">
    <div class="fakeAnimationContent" >
		<p id="fakeStartingBlinkingCursor">|</p>
    </div>
</div>

		<!-- preload the images -->
		<div style='display:none'>
			<img src='simpleModal/img/basic/x.png' alt='' />
		</div>

		<div id='startingCourtainScreen' style='width:100%; height:100%; background-color:white; position: absolute;  z-index:4; top: 0px; left: 0px;'>
			<div class="verticalMiddleOfScreen" id="loading" style="font-size:3em; color: red">
				loading /</div>
		</div>


		<!-- modal content -->
		<div id="aboutWindow">
			<h3>What&apos;s this?</h3>
			<p>This is a toy live coding environment: programs run immediately as they are typed.<br><br>Pick something from the "Demos" menu or try the tutorials.</p>
			<p>Want more info? <a href="http://www.sketchpatch.net/labs/livecodelabIntro.html"> See this.</a></p>
			<p>Want to hack this? <a href="https://github.com/davidedc/livecodelab"> Grab the source code!</a></p>
		</div>

		<div id="noWebGLMessage">
			<h3>Drag!</h3>
			<p>Your browser doesn't seem to support 3D acceleration.</p>
			<p>You'll still have fun, but you really want to try to <a href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_blank">get the 3D party going in your browser</a>.</p>
			<p>(psst! - it's worth it!). </p>
		</div>

		<div id="exampleNeedsWebgl">
			<h3>Oh nooo.</h3>
			<p>All these examples starting with "webgl" are going to look silly in your browser (which doesn't seem to support 3D acceleration).</p>
			<p>Why not try to <a href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_blank">get some awesome 3D action started</a>?</p>
		</div>

		<div id="noAudioMessage">
			<h3>Snap!</h3>
			<p>Your browser doesn't seem to support audio.</p>
			<p>Be a champion and try <a href="http://browsehappy.com/" target="_blank">a newer browser</a>.</p>
			<p>(while you are at it, pick one that supports 3D such as Chrome or Firefox).</p>
		</div>

		<div id="soundSystemIsMangledMessage">
			<h3>Congrats!</h3>
			<p>Your unlocked the "I borked the sound system" badge!</p>
			<p>You probably created a stupendous amount of fast-playing music.</p>
			<p>Just re-start the browser to get everything back to normal.</p>
			<p>(We know it's fun, do this all the time, it's OK).</p>
		</div>

		<div id="noCanvasMessage">
			<h3>Oh my!</h3>
			<p>Your browser is way old.</p>
			<p>We understand. We were there 5 years ago. Why not try <a href="http://browsehappy.com/" target="_blank">a shinier browser</a>?</p>
			<p>(while you are at it, pick one that supports 3D such as Chrome or Firefox).</p>
		</div>

<div id="theMenu" style="position: absolute;  z-index:3; top: 0px; left: 0px; width:100%">

<ul class='dd_menu' >

	<li><a href="javascript:void(0)" onclick="$('#aboutWindow').modal();$('#simplemodal-container').height(250);" style="text-decoration:none; color:red;">LIVECODELAB</a>
	</li>

	<li><a href="javascript:void(0)" style="text-decoration:none;">Demos</a>
		<ul>
		
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('simpleCubeDemo');">Simple cube</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('cubesAndSpikes');">Cubes and spikes</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('littleSpiralOfCubes');">Little spiral</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('tentacleDemo');">Tentacle</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('springysquaresDemo');">Springy squares</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('diceDemo');">Dice</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('lampDemo');">Lamp</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('trillionfeathersDemo');">A trillion feathers</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('monsterblobDemo');">Monster blob</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('industrialMusicDemo');">Sound: Industrial</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('trySoundsDemo');">Sound: Try them all</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('webglalmostvoronoiDemo');">WebGL: Almost Voronoi</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('webglshardsDemo');">WebGL: Shards</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('webglpinkthreadDemo');">WebGL: Pink thread</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('webgltwocubesDemo');">WebGL: Two cubes</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('webglturbineDemo');">WebGL: Turbine</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('webglzfightartDemo');">WebGL: Z-fight art!</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('webglnuclearOctopusDemo');">WebGL: Nuclear octopus</a></li>
		</ul>
	</li>
	<li><a href="javascript:void(0)" style="text-decoration:none;">Tutorials</a>
		<ul>		
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('introTutorial');">intro</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('helloworldTutorial');">hello world</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('somenotesTutorial');">some notes</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('rotateTutorial');">rotate</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('frameTutorial');">frame</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('timeTutorial');">time</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('moveTutorial');">move</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('scaleTutorial');">scale</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('timesTutorial');">times</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('fillTutorial');">fill</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('strokeTutorial');">stroke</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('colornamesTutorial');">color by name</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('lightsTutorial');">lights</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('backgroundTutorial');">background</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('gradientTutorial');">gradient</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('lineTutorial');">line</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('ballTutorial');">ball</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('pushpopMatrixTutorial');">push and pop</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('animationstyleTutorial');">animation style</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('doonceTutorial');">do once</a></li>
			<li><a href="javascript:void(0)" onclick="loadDemoOrTutorial('autocodeTutorial');">autocode</a></li>
		</ul>
	</li>
	<li id="autocodeIndicatorContainer" onClick="toggleAutocode();"><a id="autocodeIndicator" href="javascript:void(0)"  style="text-decoration:none;">Autocode: off</a>
	</li>
	<li id="resetButtonContainer" onClick="triggerReset();"><a id="resetButton" href="javascript:void(0)"  style="text-decoration:none;">Reset</a>
	</li>
	<li id="dangerSign" style="border-right:none;"><a href="" id="dangerSignText" style="font-size:2em;margin-top:-0.3em;">!</a>
	</li>
	<li id="errorMessage" style="border-right:none;"><a href="javascript:void(0)" id="errorMessageText" ></a>
	</li>

</ul>
</div>





<div name="miao" id="miao" style="position: absolute;  top: 30px; left: 0px; width: 100%; font-size: 3em;">

<canvas id="backGroundCanvas" style="position: absolute; z-index:-3; top: 0px; left: 0px;" width="100" height="100"></canvas> 
<canvas id="finalRenderWithSceneAndBlendCanvas" style="position: absolute; z-index:-2; top: 0px; left: 0px;" width="100" height="100"></canvas> 



		<form id="formCode" autocapitalize="off" autocorrect="off" wrap="off"><textarea id="code" name="code" style="z-index:1;" autocapitalize="off" autocorrect="off" wrap="off" ></textarea></form>

      </div>

	<!-- three.js container -->
    	<div id="container" style="position: absolute; z-index:-1; top: 0px; left: 0px;"></div>


	<script type="text/javascript">

		var stats, scene, renderer;
		var camera;
		
		// creating a geometry is expensive
		// so we need to create ONE cube of dimensions 1,1,1
		// if we need a cube of different size, then we need to
		// scale it. Note that the scale for the specific cube shouldn't
		// influence the stack, so we need to create a scale node,
		// and then go up a node.
		var isWebGLUsed = false;
		
		var linesPool = [];
		var rectanglesPool = [];
		var boxesPool = [];
		// spheres have different geometries
		// depending on the detail level,
		// which can be set at whim
		var spheresPool = {};
		var sphereGeometriesPool = {};
		var ambientLightsPool = [];
		var pointLightsPool = [];
		var usedLines = 0;
		var usedRectangles = 0;
		var usedBoxes = 0;
		var usedAmbientLights = 0;
		var usedPointLights = 0;
		var usedSpheres = {};
		var ballDefaultDetLevel;
		var ballDetLevel;
		var currentStrokeSize = 1;
		var cubeGeometry = new THREE.CubeGeometry(1,1,1);
		var planeGeometry = new THREE.PlaneGeometry(1,1);
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push(new THREE.Vertex(new THREE.Vector3(0, -0.5, 0)));
		lineGeometry.vertices.push(new THREE.Vertex(new THREE.Vector3(0, 0.5, 0)));
		
		// loads identity matrix
		var worldMatrix = new THREE.Matrix4();
		
		var forceCanvasRenderer = false;
		var backgroundScene;
		var backgroundSceneContext;
		var sceneRenderingCanvas;
		var sceneRenderingCanvasContext;
		var previousRenderForBlending;
		var previousRenderForBlendingContext;
		var finalRenderWithSceneAndBlend;
		var finalRenderWithSceneAndBlendContext;
		var useRequestAnimationFrame = true;
		// if you put to -1 then it means that
		// requestAnimationFrame will try to go as fast as it
		// can.
		var wantedFramesPerSecond = -1;
		var backGroundFraction = 15;
		var scaledBackgroundWidth;
		var scaledBackgroundHeight;
		var repaintBackroundEveryFrame = true;
		var fullScreenifyBackground = true;
		var animationStyleValue = 0;
		var previousanimationStyleValue = 0;
		var currentGradientStackValue = '';
		var previousGradientStackValue = 0;
		var blendAmount = 0;
		var normal = 0;
		var paintOver = 1;
		var motionBlur = 2;
		
		var soundLoops = [];
		soundLoops.soundIDs = [];
		soundLoops.beatStrings = [];
		
		var programHasBasicError = false;
		var reasonOfBasicError = "";
		var consecutiveFramesWithoutRunTimeError = 0;
		var out;
		var lastStableProgram;
		
		// the "spinthingy" is because we want
		// users who type "box" to see that it's actually
		// a 3d environment. So the first few primitives
		// spin for a few moments when they are created.
		var doTheSpinThingy = true;
		var resetTheSpinThingy = false;
		var SPINFRAMES = 30;

		var userWarnedAboutWebglExamples = false;


function isCanvasSupported(){
  var elem = document.createElement('canvas');
  return !!(elem.getContext && elem.getContext('2d'));
}

// Color constants, modified from processing.js
// with added the missing ones from the CSS standard,
// which includes the spelling "grey" on top of "gray"
    aliceblue =            0xfff0f8ff ;
    antiquewhite =         0xfffaebd7 ;
    aqua =                 0xff00ffff ;
    aquamarine =           0xff7fffd4 ;
    azure =                0xfff0ffff ;
    beige =                0xfff5f5dc ;
    bisque =               0xffffe4c4 ;
    black =                0xff000000 ;
    blanchedalmond =       0xffffebcd ;
    blue =                 0xff0000ff ;
    blueviolet =           0xff8a2be2 ;
    brown =                0xffa52a2a ;
    burlywood =            0xffdeb887 ;
    cadetblue =            0xff5f9ea0 ;
    chartreuse =           0xff7fff00 ;
    chocolate =            0xffd2691e ;
    coral =                0xffff7f50 ;
    cornflowerblue =       0xff6495ed ;
    cornsilk =             0xfffff8dc ;
    crimson =              0xffdc143c ;
    cyan =                 0xff00ffff ;
    darkblue =             0xff00008b ;
    darkcyan =             0xff008b8b ;
    darkgoldenrod =        0xffb8860b ;
    darkgray =             0xffa9a9a9 ;
    darkgrey =             0xffa9a9a9 ;
    darkgreen =            0xff006400 ;
    darkkhaki =            0xffbdb76b ;
    darkmagenta =          0xff8b008b ;
    darkolivegreen =       0xff556b2f ;
    darkorange =           0xffff8c00 ;
    darkorchid =           0xff9932cc ;
    darkred =              0xff8b0000 ;
    darksalmon =           0xffe9967a ;
    darkseagreen =         0xff8fbc8f ;
    darkslateblue =        0xff483d8b ;
    darkslategray =        0xff2f4f4f ;
    darkslategrey =        0xff2f4f4f ;
    darkturquoise =        0xff00ced1 ;
    darkviolet =           0xff9400d3 ;
    deeppink =             0xffff1493 ;
    deepskyblue =          0xff00bfff ;
    dimgray =              0xff696969 ;
    dimgrey =              0xff696969 ;
    dodgerblue =           0xff1e90ff ;
    firebrick =            0xffb22222 ;
    floralwhite =          0xfffffaf0 ;
    forestgreen =          0xff228b22 ;
    fuchsia =              0xffff00ff ;
    gainsboro =            0xffdcdcdc ;
    ghostwhite =           0xfff8f8ff ;
    gold =                 0xffffd700 ;
    goldenrod =            0xffdaa520 ;
    gray =                 0xff808080 ;
    grey =                 0xff808080 ;
    green =                0xff008000 ;
    greenyellow =          0xffadff2f ;
    honeydew =             0xfff0fff0 ;
    hotpink =              0xffff69b4 ;
    indianred =            0xffcd5c5c ;
    indigo =               0xff4b0082 ;
    ivory =                0xfffffff0 ;
    khaki =                0xfff0e68c ;
    lavender =             0xffe6e6fa ;
    lavenderblush =        0xfffff0f5 ;
    lawngreen =            0xff7cfc00 ;
    lemonchiffon =         0xfffffacd ;
    lightblue =            0xffadd8e6 ;
    lightcoral =           0xfff08080 ;
    lightcyan =            0xffe0ffff ;
    lightgoldenrodyellow = 0xfffafad2 ;
    lightgrey =            0xffd3d3d3 ;
    lightgray =            0xffd3d3d3 ;
    lightgreen =           0xff90ee90 ;
    lightpink =            0xffffb6c1 ;
    lightsalmon =          0xffffa07a ;
    lightseagreen =        0xff20b2aa ;
    lightskyblue =         0xff87cefa ;
    lightslategray =       0xff778899 ;
    lightslategrey =       0xff778899 ;
    lightsteelblue =       0xffb0c4de ;
    lightyellow =          0xffffffe0 ;
    lime =                 0xff00ff00 ;
    limegreen =            0xff32cd32 ;
    linen =                0xfffaf0e6 ;
    magenta =              0xffff00ff ;
    maroon =               0xff800000 ;
    mediumaquamarine =     0xff66cdaa ;
    mediumblue =           0xff0000cd ;
    mediumorchid =         0xffba55d3 ;
    mediumpurple =         0xff9370d8 ;
    mediumseagreen =       0xff3cb371 ;
    mediumslateblue =      0xff7b68ee ;
    mediumspringgreen =    0xff00fa9a ;
    mediumturquoise =      0xff48d1cc ;
    mediumvioletred =      0xffc71585 ;
    midnightblue =         0xff191970 ;
    mintcream =            0xfff5fffa ;
    mistyrose =            0xffffe4e1 ;
    moccasin =             0xffffe4b5 ;
    navajowhite =          0xffffdead ;
    navy =                 0xff000080 ;
    oldlace =              0xfffdf5e6 ;
    olive =                0xff808000 ;
    olivedrab =            0xff6b8e23 ;
    orange =               0xffffa500 ;
    orangered =            0xffff4500 ;
    orchid =               0xffda70d6 ;
    palegoldenrod =        0xffeee8aa ;
    palegreen =            0xff98fb98 ;
    paleturquoise =        0xffafeeee ;
    palevioletred =        0xffd87093 ;
    papayawhip =           0xffffefd5 ;
    peachpuff =            0xffffdab9 ;
    peru =                 0xffcd853f ;
    pink =                 0xffffc0cb ;
    plum =                 0xffdda0dd ;
    powderblue =           0xffb0e0e6 ;
    purple =               0xff800080 ;
    red =                  0xffff0000 ;
    rosybrown =            0xffbc8f8f ;
    royalblue =            0xff4169e1 ;
    saddlebrown =          0xff8b4513 ;
    salmon =               0xfffa8072 ;
    sandybrown =           0xfff4a460 ;
    seagreen =             0xff2e8b57 ;
    seashell =             0xfffff5ee ;
    sienna =               0xffa0522d ;
    silver =               0xffc0c0c0 ;
    skyblue =              0xff87ceeb ;
    slateblue =            0xff6a5acd ;
    slategray =            0xff708090 ;
    slategrey =            0xff708090 ;
    snow =                 0xfffffafa ;
    springgreen =          0xff00ff7f ;
    steelblue =            0xff4682b4 ;
    tan =                  0xffd2b48c ;
    teal =                 0xff008080 ;
    thistle =              0xffd8bfd8 ;
    tomato =               0xffff6347 ;
    turquoise =            0xff40e0d0 ;
    violet =               0xffee82ee ;
    wheat =                0xfff5deb3 ;
    white =                0xffffffff ;
    whitesmoke =           0xfff5f5f5 ;
    yellow =               0xffffff00 ;
    yellowgreen =          0xff9acd32 ;
    

// Functions taken from processing.js

/**
   * NOTE: in releases we replace symbolic Constants.* names with their values.
   * Using Constants.* in code below is fine.  See tools/rewrite-pconstants.js.
   */
  var Constants = {
    // Color modes
    RGB:   1,
    ARGB:  2,
    HSB:   3,
    ALPHA: 4,
    CMYK:  5,

    // Blend modes
    REPLACE:    0,
    BLEND:      1 << 0,
    ADD:        1 << 1,
    SUBTRACT:   1 << 2,
    LIGHTEST:   1 << 3,
    DARKEST:    1 << 4,
    DIFFERENCE: 1 << 5,
    EXCLUSION:  1 << 6,
    MULTIPLY:   1 << 7,
    SCREEN:     1 << 8,
    OVERLAY:    1 << 9,
    HARD_LIGHT: 1 << 10,
    SOFT_LIGHT: 1 << 11,
    DODGE:      1 << 12,
    BURN:       1 << 13,

    // Color component bit masks
    ALPHA_MASK: 0xff000000,
    RED_MASK:   0x00ff0000,
    GREEN_MASK: 0x0000ff00,
    BLUE_MASK:  0x000000ff,

  };

var doFill = true,
        fillStyle = [1.0, 1.0, 1.0, 1.0],
        isFillDirty = true,
        doStroke = true,
        strokeStyle = [0.0, 0.0, 0.0, 1.0],
        isStrokeDirty = true,
        lineWidth = 1,
        colorModeA = 255,
        colorModeX = 255,
        colorModeY = 255,
        colorModeZ = 255,
        curColorMode = Constants.RGB;

/**
    * Determines the largest value in a sequence of numbers.
    *
    * @param {int|float} value1         int or float
    * @param {int|float} value2         int or float
    * @param {int|float} value3         int or float
    * @param {int|float} array          int or float array
    *
    * @returns {int|float}
    *
    * @see min
    */
    max = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[1] : arguments[0];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used
      if (! ("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var max = numbers[0],
        count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (max < numbers[i]) {
          max = numbers[i];
        }
      }
      return max;
    };

    /**
    * Determines the smallest value in a sequence of numbers.
    *
    * @param {int|float} value1         int or float
    * @param {int|float} value2         int or float
    * @param {int|float} value3         int or float
    * @param {int|float} array          int or float array
    *
    * @returns {int|float}
    *
    * @see max
    */
    min = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[0] : arguments[1];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used
      if (! ("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var min = numbers[0],
        count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (min > numbers[i]) {
          min = numbers[i];
        }
      }
      return min;
    };
    
function color$4(aValue1, aValue2, aValue3, aValue4) {
      var r, g, b, a;

      if (curColorMode === Constants.HSB) {
        var rgb = color.toRGB(aValue1, aValue2, aValue3);
        r = rgb[0];
        g = rgb[1];
        b = rgb[2];
      } else {
        r = Math.round(255 * (aValue1 / colorModeX));
        g = Math.round(255 * (aValue2 / colorModeY));
        b = Math.round(255 * (aValue3 / colorModeZ));
      }

      a = Math.round(255 * (aValue4 / colorModeA));

      // Limit values less than 0 and greater than 255
      r = (r < 0) ? 0 : r;
      g = (g < 0) ? 0 : g;
      b = (b < 0) ? 0 : b;
      a = (a < 0) ? 0 : a;
      r = (r > 255) ? 255 : r;
      g = (g > 255) ? 255 : g;
      b = (b > 255) ? 255 : b;
      a = (a > 255) ? 255 : a;

      // Create color int
      return (a << 24) & Constants.ALPHA_MASK | (r << 16) & Constants.RED_MASK | (g << 8) & Constants.GREEN_MASK | b & Constants.BLUE_MASK;
    }

    function color$2(aValue1, aValue2) {
      var a;

      if (aValue1 === angleColor) return angleColor;
      
      // Color int and alpha
      if (aValue1 & Constants.ALPHA_MASK) {
        a = Math.round(255 * (aValue2 / colorModeA));
        // Limit values less than 0 and greater than 255
        a = (a > 255) ? 255 : a;
        a = (a < 0) ? 0 : a;

        return aValue1 - (aValue1 & Constants.ALPHA_MASK) + ((a << 24) & Constants.ALPHA_MASK);
      }
      // Grayscale and alpha
      if (curColorMode === Constants.RGB) {
        return color$4(aValue1, aValue1, aValue1, aValue2);
      }
      if (curColorMode === Constants.HSB) {
        return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, aValue2);
      }
    }

    function color$1(aValue1) {
      // Grayscale
      if (aValue1 <= colorModeX && aValue1 >= 0) {
          if (curColorMode === Constants.RGB) {
            return color$4(aValue1, aValue1, aValue1, colorModeA);
          }
          if (curColorMode === Constants.HSB) {
            return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, colorModeA);
          }
      }
      // Color int
      if (aValue1) {
        if (aValue1 > 2147483647) {
          // Java Overflow
          aValue1 -= 4294967296;
        }
        return aValue1;
      }
    }

    /**
    * Creates colors for storing in variables of the color datatype. The parameters are
    * interpreted as RGB or HSB values depending on the current colorMode(). The default
    * mode is RGB values from 0 to 255 and therefore, the function call color(255, 204, 0)
    * will return a bright yellow color. More about how colors are stored can be found in
    * the reference for the color datatype.
    *
    * @param {int|float} aValue1        red or hue or grey values relative to the current color range.
    * Also can be color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)
    * @param {int|float} aValue2        green or saturation values relative to the current color range
    * @param {int|float} aValue3        blue or brightness values relative to the current color range
    * @param {int|float} aValue4        relative to current color range. Represents alpha
    *
    * @returns {color} the color
    *
    * @see colorMode
    */
    var color = function(aValue1, aValue2, aValue3, aValue4) {
    //alert("color");

      // 4 arguments: (R, G, B, A) or (H, S, B, A)
      if (aValue1 !== undefined && aValue2 !== undefined && aValue3 !== undefined && aValue4 !== undefined) {
        return color$4(aValue1, aValue2, aValue3, aValue4);
      }

      // 3 arguments: (R, G, B) or (H, S, B)
      if (aValue1 !== undefined && aValue2 !== undefined && aValue3 !== undefined) {
        return color$4(aValue1, aValue2, aValue3, colorModeA);
      }

      // 2 arguments: (Color, A) or (Grayscale, A)
      if (aValue1 !== undefined && aValue2 !== undefined) {
        return color$2(aValue1, aValue2);
      }

      // 1 argument: (Grayscale) or (Color)
      if (typeof aValue1 === "number") {
        return color$1(aValue1);
      }

      // Default
      return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);
    };

    // Ease of use function to extract the colour bits into a string
    color.toString = function(colorInt) {
      return "rgba(" + ((colorInt & Constants.RED_MASK) >>> 16) + "," + ((colorInt & Constants.GREEN_MASK) >>> 8) +
             "," + ((colorInt & Constants.BLUE_MASK)) + "," + ((colorInt & Constants.ALPHA_MASK) >>> 24) / 255 + ")";
    };

    // Easy of use function to pack rgba values into a single bit-shifted color int.
    color.toInt = function(r, g, b, a) {
      return (a << 24) & Constants.ALPHA_MASK | (r << 16) & Constants.RED_MASK | (g << 8) & Constants.GREEN_MASK | b & Constants.BLUE_MASK;
    };

    // Creates a simple array in [R, G, B, A] format, [255, 255, 255, 255]
    color.toArray = function(colorInt) {
      return [(colorInt & Constants.RED_MASK) >>> 16, (colorInt & Constants.GREEN_MASK) >>> 8,
              colorInt & Constants.BLUE_MASK, (colorInt & Constants.ALPHA_MASK) >>> 24];
    };

    // Creates a WebGL color array in [R, G, B, A] format. WebGL wants the color ranges between 0 and 1, [1, 1, 1, 1]
    color.toGLArray = function(colorInt) {
      return [((colorInt & Constants.RED_MASK) >>> 16) / 255, ((colorInt & Constants.GREEN_MASK) >>> 8) / 255,
              (colorInt & Constants.BLUE_MASK) / 255, ((colorInt & Constants.ALPHA_MASK) >>> 24) / 255];
    };

    // HSB conversion function from Mootools, MIT Licensed
    color.toRGB = function(h, s, b) {
      // Limit values greater than range
      h = (h > colorModeX) ? colorModeX : h;
      s = (s > colorModeY) ? colorModeY : s;
      b = (b > colorModeZ) ? colorModeZ : b;

      h = (h / colorModeX) * 360;
      s = (s / colorModeY) * 100;
      b = (b / colorModeZ) * 100;

      var br = Math.round(b / 100 * 255);

      if (s === 0) { // Grayscale
        return [br, br, br];
      }
      var hue = h % 360;
      var f = hue % 60;
      var p = Math.round((b * (100 - s)) / 10000 * 255);
      var q = Math.round((b * (6000 - s * f)) / 600000 * 255);
      var t = Math.round((b * (6000 - s * (60 - f))) / 600000 * 255);
      switch (Math.floor(hue / 60)) {
      case 0:
        return [br, t, p];
      case 1:
        return [q, br, p];
      case 2:
        return [p, br, t];
      case 3:
        return [p, q, br];
      case 4:
        return [t, p, br];
      case 5:
        return [br, p, q];
      }
    };

    function colorToHSB(colorInt) {
      var red, green, blue;

      red   = ((colorInt & Constants.RED_MASK) >>> 16) / 255;
      green = ((colorInt & Constants.GREEN_MASK) >>> 8) / 255;
      blue  = (colorInt & Constants.BLUE_MASK) / 255;

      var max = max(max(red,green), blue),
          min = min(min(red,green), blue),
          hue, saturation;

      if (min === max) {
        return [0, 0, max*colorModeZ];
      }
      saturation = (max - min) / max;

      if (red === max) {
        hue = (green - blue) / (max - min);
      } else if (green === max) {
        hue = 2 + ((blue - red) / (max - min));
      } else {
        hue = 4 + ((red - green) / (max - min));
      }

      hue /= 6;

      if (hue < 0) {
        hue += 1;
      } else if (hue > 1) {
        hue -= 1;
      }
      return [hue*colorModeX, saturation*colorModeY, max*colorModeZ];
    }

    /**
    * Extracts the brightness value from a color.
    *
    * @param {color} colInt any value of the color datatype
    *
    * @returns {float} The brightness color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see hue
    * @see saturation
    */
    brightness = function(colInt){
      return colorToHSB(colInt)[2];
    };

    /**
    * Extracts the saturation value from a color.
    *
    * @param {color} colInt any value of the color datatype
    *
    * @returns {float} The saturation color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see hue
    * @see brightness
    */
    saturation = function(colInt){
      return colorToHSB(colInt)[1];
    };

    /**
    * Extracts the hue value from a color.
    *
    * @param {color} colInt any value of the color datatype
    *
    * @returns {float} The hue color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see saturation
    * @see brightness
    */
    hue = function(colInt){
      return colorToHSB(colInt)[0];
    };

    /**
    * Extracts the red value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The red color value.
    *
    * @see green
    * @see blue
    * @see alpha
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    redF = function(aColor) {
      return ((aColor & Constants.RED_MASK) >>> 16) / 255 * colorModeX;
    };

    /**
    * Extracts the green value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The green color value.
    *
    * @see red
    * @see blue
    * @see alpha
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    greenF = function(aColor) {
      return ((aColor & Constants.GREEN_MASK) >>> 8) / 255 * colorModeY;
    };

    /**
    * Extracts the blue value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The blue color value.
    *
    * @see red
    * @see green
    * @see alpha
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    blueF = function(aColor) {
      return (aColor & Constants.BLUE_MASK) / 255 * colorModeZ;
    };

    /**
    * Extracts the alpha value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The alpha color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    alpha = function(aColor) {
      return ((aColor & Constants.ALPHA_MASK) >>> 24) / 255 * colorModeA;
    };
    alphaZeroToOne = function(aColor) {
      return ((aColor & Constants.ALPHA_MASK) >>> 24) / 255;
    };

    /**
    * Calculates a color or colors between two colors at a specific increment.
    * The amt parameter is the amount to interpolate between the two values where 0.0
    * equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.
    *
    * @param {color} c1     interpolate from this color
    * @param {color} c2     interpolate to this color
    * @param {float} amt    between 0.0 and 1.0
    *
    * @returns {float} The blended color.
    *
    * @see blendColor
    * @see color
    */
    lerpColor = function(c1, c2, amt) {
      var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;
      var hsb1, hsb2, rgb, h, s;
      var colorBits1 = color(c1);
      var colorBits2 = color(c2);

      if (curColorMode === Constants.HSB) {
        // Special processing for HSB mode.
        // Get HSB and Alpha values for Color 1 and 2
        hsb1 = colorToHSB(colorBits1);
        a1 = ((colorBits1 & Constants.ALPHA_MASK) >>> 24) / colorModeA;
        hsb2 = colorToHSB(colorBits2);
        a2 = ((colorBits2 & Constants.ALPHA_MASK) >>> 24) / colorModeA;

        // Return lerp value for each channel, for HSB components
        h = lerp(hsb1[0], hsb2[0], amt);
        s = lerp(hsb1[1], hsb2[1], amt);
        b = lerp(hsb1[2], hsb2[2], amt);
        rgb = color.toRGB(h, s, b);
        // ... and for Alpha-range
        a = lerp(a1, a2, amt) * colorModeA;

        return (a << 24) & Constants.ALPHA_MASK |
               (rgb[0] << 16) & Constants.RED_MASK |
               (rgb[1] << 8) & Constants.GREEN_MASK |
               rgb[2] & Constants.BLUE_MASK;
      }

      // Get RGBA values for Color 1 to floats
      r1 = (colorBits1 & Constants.RED_MASK) >>> 16;
      g1 = (colorBits1 & Constants.GREEN_MASK) >>> 8;
      b1 = (colorBits1 & Constants.BLUE_MASK);
      a1 = ((colorBits1 & Constants.ALPHA_MASK) >>> 24) / colorModeA;

      // Get RGBA values for Color 2 to floats
      r2 = (colorBits2 & Constants.RED_MASK) >>> 16;
      g2 = (colorBits2 & Constants.GREEN_MASK) >>> 8;
      b2 = (colorBits2 & Constants.BLUE_MASK);
      a2 = ((colorBits2 & Constants.ALPHA_MASK) >>> 24) / colorModeA;

      // Return lerp value for each channel, INT for color, Float for Alpha-range
      r = lerp(r1, r2, amt) | 0;
      g = lerp(g1, g2, amt) | 0;
      b = lerp(b1, b2, amt) | 0;
      a = lerp(a1, a2, amt) * colorModeA;

      return (a << 24) & Constants.ALPHA_MASK |
             (r << 16) & Constants.RED_MASK |
             (g << 8) & Constants.GREEN_MASK |
             b & Constants.BLUE_MASK;
    };

    /**
    * Changes the way Processing interprets color data. By default, fill(), stroke(), and background()
    * colors are set by values between 0 and 255 using the RGB color model. It is possible to change the
    * numerical range used for specifying colors and to switch color systems. For example, calling colorMode(RGB, 1.0)
    * will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the
    * parameters range1, range2, range3, and range 4.
    *
    * @param {MODE} mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness
    * @param {int|float} range              range for all color elements
    * @param {int|float} range1             range for the red or hue depending on the current color mode
    * @param {int|float} range2             range for the green or saturation depending on the current color mode
    * @param {int|float} range3             range for the blue or brightness depending on the current color mode
    * @param {int|float} range4             range for the alpha
    *
    * @returns none
    *
    * @see background
    * @see fill
    * @see stroke
    */
    colorMode = function() { // mode, range1, range2, range3, range4
      curColorMode = arguments[0];
      if (arguments.length > 1) {
        colorModeX   = arguments[1];
        colorModeY   = arguments[2] || arguments[1];
        colorModeZ   = arguments[3] || arguments[1];
        colorModeA   = arguments[4] || arguments[1];
      }
    };

    /**
    * Blends two color values together based on the blending mode given as the MODE parameter.
    * The possible modes are described in the reference for the blend() function.
    *
    * @param {color} c1 color: the first color to blend
    * @param {color} c2 color: the second color to blend
    * @param {MODE} MODE Either BLEND, ADD, SUBTRACT, DARKEST, LIGHTEST, DIFFERENCE, EXCLUSION, MULTIPLY,
    * SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, or BURN
    *
    * @returns {float} The blended color.
    *
    * @see blend
    * @see color
    */
    blendColor = function(c1, c2, mode) {
      if (mode === Constants.REPLACE) {
        return modes.replace(c1, c2);
      } else if (mode === Constants.BLEND) {
        return modes.blend(c1, c2);
      } else if (mode === Constants.ADD) {
        return modes.add(c1, c2);
      } else if (mode === Constants.SUBTRACT) {
        return modes.subtract(c1, c2);
      } else if (mode === Constants.LIGHTEST) {
        return modes.lightest(c1, c2);
      } else if (mode === Constants.DARKEST) {
        return modes.darkest(c1, c2);
      } else if (mode === Constants.DIFFERENCE) {
        return modes.difference(c1, c2);
      } else if (mode === Constants.EXCLUSION) {
        return modes.exclusion(c1, c2);
      } else if (mode === Constants.MULTIPLY) {
        return modes.multiply(c1, c2);
      } else if (mode === Constants.SCREEN) {
        return modes.screen(c1, c2);
      } else if (mode === Constants.HARD_LIGHT) {
        return modes.hard_light(c1, c2);
      } else if (mode === Constants.SOFT_LIGHT) {
        return modes.soft_light(c1, c2);
      } else if (mode === Constants.OVERLAY) {
        return modes.overlay(c1, c2);
      } else if (mode === Constants.DODGE) {
        return modes.dodge(c1, c2);
      } else if (mode === Constants.BURN) {
        return modes.burn(c1, c2);
      }
    };

    var currentFillAlpha = 1;
    var currentFillColor = 0xFFFFFF;
    var defaultNormalFill = true;
    var defaultNormalStroke = true;
	// lowest than any 32 bit color is a special
	// color that paints based on normals.
    var angleColor = -16777217;
    fill = function() {
    	defaultNormalFill = false;
      var c = color(arguments[0], arguments[1], arguments[2], arguments[3]);
      var crgb;
      var ca;
      //console.log("fillColor: "+c);
      if (c === angleColor) {
      	// this is so we can do a smart optimisation later
      	// and not draw the wireframe is it happens to be the same color as
      	// the fill
	      defaultNormalFill = true;
      	//console.log("yes it's normal color ");
      	crgb = c;
      	if (arguments[1] !== undefined) {
      		//console.log("passed alpha: " + arguments[1]);
      		ca = arguments[1] / colorModeA;
      		//console.log("calculated alpha: " + ca);
      	}
      	else {
	      	ca = 1;
      	}
      }
      else {
		  crgb = color(redF(c), greenF(c), blueF(c));
		  ca = alphaZeroToOne(c);
      }
      //console.log("crgb ca "+crgb + " " + ca);
      if(crgb === currentFillColor && ca === currentFillAlpha && doFill) {
        return;
      }
      doFill = true;
      currentFillColor = crgb;
      currentFillAlpha = ca;
    };

/**
     * The noFill() function disables filling geometry. If both <b>noStroke()</b> and <b>noFill()</b>
     * are called, no shapes will be drawn to the screen.
     *
     * @see #fill()
     *
     */
    noFill = function() {
      doFill = false;
    };

    /**
     * The stroke() function sets the color used to draw lines and borders around shapes. This color
     * is either specified in terms of the RGB or HSB color depending on the
     * current <b>colorMode()</b> (the default color space is RGB, with each
     * value in the range from 0 to 255).
     * <br><br>When using hexadecimal notation to specify a color, use "#" or
     * "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six
     * digits to specify a color (the way colors are specified in HTML and CSS).
     * When using the hexadecimal notation starting with "0x", the hexadecimal
     * value must be specified with eight characters; the first two characters
     * define the alpha component and the remainder the red, green, and blue
     * components.
     * <br><br>The value for the parameter "gray" must be less than or equal
     * to the current maximum value as specified by <b>colorMode()</b>.
     * The default maximum value is 255.
     *
     * @param {int|float} gray    number specifying value between white and black
     * @param {int|float} value1  red or hue value
     * @param {int|float} value2  green or saturation value
     * @param {int|float} value3  blue or brightness value
     * @param {int|float} alpha   opacity of the stroke
     * @param {Color} color       any value of the color datatype
     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)
     *
     * @see #fill()
     * @see #noStroke()
     * @see #tint()
     * @see #background()
     * @see #colorMode()
     */
	var currentStrokeAlpha = 1;
    var currentStrokeColor = 0x000000;
    var stroke = function() {
    defaultNormalStroke = false;
      var c = color(arguments[0], arguments[1], arguments[2], arguments[3]);
      var crgb;
      var ca;
		if (c === angleColor) {
      	// this is so we can do a smart optimisation later
      	// and not draw the wireframe is it happens to be the same color as
      	// the fill
	      defaultNormalStroke = true;
			//console.log("yes it's normal color ");
			crgb = c;
			if (arguments[1] !== undefined) {
				//console.log("passed alpha: " + arguments[1]);
				ca = arguments[1] / colorModeA;
				//console.log("calculated alpha: " + ca);
			}
			else {
				ca = 1;
			}
		}
		else {	
			crgb = color(redF(c), greenF(c), blueF(c));
			ca = alphaZeroToOne(c);
		}
      //console.log("crgb ca "+crgb + " " + ca);
      if(crgb === currentStrokeColor && ca === currentStrokeAlpha && doStroke) {
        return;
      }
      doStroke = true;
      currentStrokeColor = crgb;
      currentStrokeAlpha = ca;
    };

	/**
     * The noStroke() function disables drawing the stroke (outline). If both <b>noStroke()</b> and
     * <b>noFill()</b> are called, no shapes will be drawn to the screen.
     *
     * @see #stroke()
     */
    noStroke = function() {
      doStroke = false;
    };

    strokeSize = function(a) {
      if (a===undefined) a=1;
      else if (a<0) a=0;
      currentStrokeSize = a;
    };
    // enf of functions from processing.js
		// init the scene
		function init(){

			scaledBackgroundWidth = Math.floor(window.innerWidth / backGroundFraction);
			scaledBackgroundHeight = Math.floor(window.innerHeight / backGroundFraction);

			if( Detector.webgl && !forceCanvasRenderer ){

				ballDefaultDetLevel = 16;
				sceneRenderingCanvas = document.createElement('canvas');
				
				renderer = new THREE.WebGLRenderer({
					canvas: sceneRenderingCanvas,
					antialias		: true,	// to get smoother output					
					preserveDrawingBuffer	: false,	// to allow screenshot
					clearColor: 0x000000, clearAlpha: 0, antialias: false
				});
			   
			   //renderer.autoClearColor = false;
			   //renderer.autoClear = false;
			   isWebGLUsed = true;
			   
			   // this is really a bad hack, but chrome goes twice
			   // as fast with this, while safari doesn't work,
			   // and firefox is the fastest no matter what
			   if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
			   	//renderer.autoClear = false;
			   }
			   
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.getElementById('container').appendChild(sceneRenderingCanvas);
				//document.getElementById('finalRenderWithSceneAndBlendCanvas').appendChild(finalRenderWithSceneAndBlend);


			}else{
			
			
			 // we always draw the 3d scene off-screen
				
				ballDefaultDetLevel = 6;
				sceneRenderingCanvas = document.createElement('canvas');
				sceneRenderingCanvasContext = sceneRenderingCanvas.getContext('2d');
				renderer	= new THREE.CanvasRenderer({
					canvas: sceneRenderingCanvas,
					antialias		: true,	// to get smoother output					
					preserveDrawingBuffer	: false	// to allow screenshot
				});
			   	
			   	//renderer.autoClear = true;
			   	//renderer.setClearColorHex( 0x000000, 1 );


				previousRenderForBlending = document.createElement('canvas');
				previousRenderForBlending.width = window.innerWidth;
				previousRenderForBlending.height = window.innerHeight;
				previousRenderForBlendingContext = previousRenderForBlending.getContext('2d');
		
				finalRenderWithSceneAndBlend = document.getElementById('finalRenderWithSceneAndBlendCanvas');  
				//finalRenderWithSceneAndBlend.width = scaledBackgroundWidth;
				//finalRenderWithSceneAndBlend.height = scaledBackgroundHeight;
				finalRenderWithSceneAndBlend.width = window.innerWidth;
				finalRenderWithSceneAndBlend.height = window.innerWidth;
				finalRenderWithSceneAndBlendContext = finalRenderWithSceneAndBlend.getContext('2d');
				
				renderer.setSize( window.innerWidth, window.innerHeight );
				//document.getElementById('container').appendChild(sceneRenderingCanvas);
			}


				backgroundScene = document.getElementById('backGroundCanvas');  
				backgroundScene.width = scaledBackgroundWidth;
				backgroundScene.height = scaledBackgroundHeight;
				backgroundSceneContext = backgroundScene.getContext('2d');



			// add Stats.js - https://github.com/mrdoob/stats.js
			stats = new Stats();
			// Align bottom-left
			stats.getDomElement().style.position = 'absolute';
			stats.getDomElement().style.right = '0px';
			stats.getDomElement().style.top = '0px';
			document.body.appendChild( stats.getDomElement() );

			scene = new THREE.Scene();
			scene.matrixAutoUpdate = false;


			// put a camera in the scene
			camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.set(0, 0, 5);
			scene.add(camera);

			// temporarily, add a light

			// add subtle ambient lighting
			//var ambientLight = new THREE.AmbientLight(0xFF0000);
			//scene.add(ambientLight);
        
			// create a point light
			var pointLight = new THREE.PointLight(0xFFFFFF);
			
			// set its position
			pointLight.position.x = 10;
			pointLight.position.y = 50;
			pointLight.position.z = 130;
			
			// add to the scene
			scene.add(pointLight);

			// transparently support window resize
			THREEx.WindowResize.bind(renderer, camera);
			
			if (isWebGLUsed) {
				buildPostprocessingChain();
			}

}

buildPostprocessingChain = function () {
	renderTargetParameters = { format: THREE.RGBAFormat, stencilBuffer: true };
	
	renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, renderTargetParameters );			
	effectSaveTarget = new THREE.SavePass( new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, renderTargetParameters ) );
	effectSaveTarget.clear = false;
	
	fxaaPass = new THREE.ShaderPass( THREE.ShaderExtras[ "fxaa" ] );
	fxaaPass.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
	
	effectBlend = new THREE.ShaderPass( THREE.ShaderExtras[ "blend" ], "tDiffuse1" );   
	screenPass = new THREE.ShaderPass( THREE.ShaderExtras[ "screen" ] );
	
	// motion blur
	effectBlend.uniforms[ 'tDiffuse2' ].texture = effectSaveTarget.renderTarget;
	effectBlend.uniforms[ 'mixRatio' ].value = 0;
	
	var renderModel = new THREE.RenderPass( scene, camera );    
	
	composer = new THREE.EffectComposer( renderer, renderTarget );
	
	composer.addPass( renderModel );
	//composer.addPass( fxaaPass );	
	composer.addPass( effectBlend );
	composer.addPass( effectSaveTarget );
	composer.addPass( screenPass );
	screenPass.renderToScreen = true;
}

		

		function render() {


			/*
			// need a light for the meshlambert material
			var light = new THREE.PointLight( 0xFFFFFF );
			light.position.set( 10, 0, 10 );
			scene.add( light );
			*/



			////////////////////////

			if (isWebGLUsed) {
				composer.render( );
				//renderer.render(scene,camera);
			}

			else {
			
			
				// the renderer draws into an offscreen canvas called sceneRenderingCanvas
				renderer.render( scene, camera );
								
				// clear the final render context
				finalRenderWithSceneAndBlendContext.globalAlpha = 1.0;
				finalRenderWithSceneAndBlendContext.clearRect(0, 0, window.innerWidth,window.innerHeight)
				
				// draw the rendering of the scene on the final render
				// clear the final render context
				finalRenderWithSceneAndBlendContext.globalAlpha = blendAmount;
				finalRenderWithSceneAndBlendContext.drawImage(previousRenderForBlending, 0, 0);

				finalRenderWithSceneAndBlendContext.globalAlpha = 1.0;
				finalRenderWithSceneAndBlendContext.drawImage(sceneRenderingCanvas, 0, 0);
				
				//previousRenderForBlendingContext.clearRect(0, 0, window.innerWidth,window.innerHeight)
				previousRenderForBlendingContext.globalCompositeOperation = 'copy';
				previousRenderForBlendingContext.drawImage(finalRenderWithSceneAndBlend, 0, 0);
				
				// clear the renderer's canvas to transparent black
				sceneRenderingCanvasContext.clearRect(0, 0, window.innerWidth,window.innerHeight)



			}

				
		}
		
		
var drawLoopTimer = null;
var frame = 0;
var doLNOnce = [];


// By doing some profiling it is apparent that
// adding and removing objects has a big cost.
// So instead of adding/removing objects every frame,
// objects are only added at creation and they are
// never removed from the scene. They are
// only made invisible. This routine combs the
// scene and finds the objects that.
// TODO a way to shrink the scene if it's been a
// long time that only a handful of lines/meshes
// have been used.

function combDisplayList() {
	
	for(var i = 0; i < scene.objects.length; ++i) {
			var sceneObject = scene.objects[i];
			if (sceneObject.isLine){
				if (usedLines > 0) {
					sceneObject.visible = true;
					usedLines--;
				}
				else {
					sceneObject.visible = false;
				}
			}
			else if (sceneObject.isRectangle){
				if (usedRectangles > 0) {
					sceneObject.visible = true;
					usedRectangles--;
				}
				else {
					sceneObject.visible = false;
				}
			}
			else if (sceneObject.isBox){
				if (usedBoxes > 0) {
					sceneObject.visible = true;
					usedBoxes--;
				}
				else {
					sceneObject.visible = false;
				}
			}
			else if (sceneObject.isAmbientLight){
				if (usedAmbientLights > 0) {
					sceneObject.visible = true;
					usedAmbientLights--;
				}
				else {
					sceneObject.visible = false;
				}
			}
			else if (sceneObject.isSphere !== 0){
				if (usedSpheres[''+sceneObject.isSphere] > 0) {
					sceneObject.visible = true;
					usedSpheres[''+sceneObject.isSphere] = usedSpheres[''+sceneObject.isSphere]-1;
				}
				else {
					sceneObject.visible = false;
				}
			}
	}
}


function clearDisplayList() {
	/*
	for(var i = 0; i < scene.objects.length; ++i) {
			scene.remove(scene.objects[i]);
			i--;
	}
	*/
}

function registerCode() {
    

      try {
      
        var editorContent = editor.getValue();
        
        if (editorContent !== '' && fakeText === true) {
        	shrinkFakeText();
        }
        
        if (editorContent === '' && !fakeText) {
			resetTheSpinThingy = true;
    		fakeText = true;
    		window.location.hash = '';
    	
			$("#formCode").animate({opacity: 0}, "fast");
			//$("#formCode").css('opacity',0);
			//setTimeout('if (editor.getValue() !== "") $("#formCode").css("opacity",0);',10);
			//console.log('unshrinking');
			$("#justForFakeCursor").show();
			$("#toMove").show();			
			$('#caption').html('|');

		  
		  $("#toMove").animate(
			  {
				opacity: 1,
				margin: 0,
				fontSize:350,
				left: 0
			  },
			  "fast",
			  function() {
							$('#caption').html('');
							$('#fakeStartingBlinkingCursor').html('|');
							//fakeCursorInterval = setInterval ( "fakeCursorBlinking()", 800 );
						}
		  );

        }
        
        var copyOfEditorContent;
        var programIsMangled = false;
        var programContainsStringsOrComments = false;
        var characterBeingExamined;
        var nextCharacterBeingExamined;
        
		// a check mark is added to the left of
		// doOnce statements that have been executed
		// but in reality those check marks
		// are just single-line comments, so replace here.

		editorContent = editorContent.replace(/^(\s)*[ ]*doOnce[ ]*\-\>[ ]*$/gm,"$1if false");
		editorContent = editorContent.replace("\u2713","//");
        
        // according to jsperf, this is the fastest way to count for
        // occurrences of a character. We count apostrophes


		// check whether the program potentially
		// contains strings or comments
		// if it doesn't then we can do some
		// simple syntactic checks that are likely
		// to be much faster than attempting a
		// coffescript to javascript translation
        copyOfEditorContent = editorContent;

        /*
        if (chromeHackUncaughtReferenceNames !== []) {
			//alert("there is at least one undefined, actually: " + chromeHackUncaughtReferenceNames.length);

			var lengthToCheck = chromeHackUncaughtReferenceNames.length;
			for (var iteratingOverSource = 0; iteratingOverSource < lengthToCheck; iteratingOverSource++) {
						copyOfEditorContent = copyOfEditorContent.replace(new RegExp( '\\s+'+chromeHackUncaughtReferenceNames[iteratingOverSource]+'\\s+', "g" ),"ERROR");
			}
	
			if (copyOfEditorContent.indexOf('ERROR') > -1) {
				alert("found some old undefineds");
				return;
			}
			
			// if we are here it means that
			// all the previous undefineds are not
			// found anymore
			// TODO this wouldn't work if one uses a function name
			// and then one defines it. We should also check
			// whether there is a function definition
			chromeHackUncaughtReferenceNames = [];

		}
		*/


		while (copyOfEditorContent.length) {
			characterBeingExamined = copyOfEditorContent.charAt(0);
			nextCharacterBeingExamined = copyOfEditorContent.charAt(1);
		  if (characterBeingExamined === "'" ||
		  	characterBeingExamined === '"' ||
		  	(characterBeingExamined === "/" &&
		  		(
		  		nextCharacterBeingExamined === "*" ||
		  		nextCharacterBeingExamined === "/"
		  		)
		  	)
		  	) {
			  programContainsStringsOrComments = true;
			  //alert('program contains strings or comments');
			  break;
		   }
		   copyOfEditorContent = copyOfEditorContent.slice(1);
		}

        // let's do a quick check:
        // these groups of characters should be in even number:
        // ", ', (), {}, []
        
		if (programContainsStringsOrComments) {
			// OK the program contains comments and/or strings
			// so this is what we are going to do:
			// first we remove all the comments for good
			// then we create a version without the strings
			// so we can perform some basic syntax checking.
			// Note that when we remove the comments we also need to
			// take into account strings because otherwise we mangle a line like
       	 	// print "frame/100 //"
       	 	// where we need to now that that single comment is actually the content
       	 	// of a string.
		
			// modified from Processing.js (search for: "masks strings and regexs")
			// this is useful to remove all comments but keeping all the strings
			// the difference is that here I don't treat regular expressions.
			// Note that string take precedence over comments i.e.
			// is a string, not half a string with a quote in a comment

			// get rid of the comments for good.
			editorContent = editorContent.replace(/("(?:[^"\\\n]|\\.)*")|('(?:[^'\\\n]|\\.)*')|(\/\/[^\n]*\n)|(\/\*(?:(?!\*\/)(?:.|\n))*\*\/)/g,
			function(all, quoted, aposed, singleComment, comment) {
			  // strings are kept as they are
			  if(quoted) {
				return quoted;
			  }
			  else if(aposed) {
				return aposed;
			  }
			  else if(singleComment) {
			  	// preserve the line because
			  	// the doOnce mechanism needs to retrieve
			  	// the line where it was
				return "\n";
			  }
			  // eliminate multiline comments preserving the lines
			  else {
			  	var numberOfLinesInMultilineComment = comment.split("\n").length-1;
			  	//alert('rebuilding multilines: '+ numberOfLinesInMultilineComment);
			  	var rebuiltNewLines = '';
			  	for (var cycleToRebuildNewLines = 0; cycleToRebuildNewLines < numberOfLinesInMultilineComment; cycleToRebuildNewLines++){
			  		rebuiltNewLines = rebuiltNewLines + "\n";
			  	}
			  	//alert('rebuilding multilines: '+ rebuiltNewLines);
				return rebuiltNewLines;
			  }
			});
			
			// ok now in the version we use for syntax checking we delete all the strings
			copyOfEditorContent = editorContent.replace(/("(?:[^"\\\n]|\\.)*")|('(?:[^'\\\n]|\\.)*')/g,"");

		}
		else {
		    copyOfEditorContent = editorContent;
		}
		
			var aposCount = 0;
			var quoteCount = 0;
			var roundBrackCount = 0;
			var curlyBrackCount = 0;
			var squareBrackCount = 0;
			
			while (copyOfEditorContent.length) {
				characterBeingExamined = copyOfEditorContent.charAt(0)
			
			  if ( characterBeingExamined === "'") {
				  aposCount += 1;
				}
			  else if (characterBeingExamined === '"') {
				  quoteCount += 1;
				}
			  else if (characterBeingExamined === '(' || characterBeingExamined === ')' ) {
				  roundBrackCount += 1;
				}
			  else if (characterBeingExamined === '{' || characterBeingExamined === '}' ) {
				  curlyBrackCount += 1;
				}
			  else if (characterBeingExamined === '[' || characterBeingExamined === ']' ) {
				  squareBrackCount += 1;
				}
			   copyOfEditorContent = copyOfEditorContent.slice(1);
			}
			
			// according to jsperf, the fastest way to check if number is even/odd
			if (
				aposCount & 1 ||
				quoteCount & 1 ||
				roundBrackCount & 1 ||
				curlyBrackCount & 1 ||
				squareBrackCount & 1
			){
				 if(autocodeOn) {
					 editor.undo();
					 //alert("did an undo");
					 return;
				 }
				
				programHasBasicError = true;
				//alert("basic error");
				//alert("p:" + $('#dangerSignText').css('color'));
				$('#dangerSignText').css('color','red')

			if (aposCount & 1) reasonOfBasicError = "Missing '";
			if (quoteCount & 1) reasonOfBasicError = 'Missing "';
			if (roundBrackCount & 1) reasonOfBasicError = "Unbalanced ()";
			if (curlyBrackCount & 1) reasonOfBasicError = "Unbalanced {}";
			if (squareBrackCount & 1) reasonOfBasicError = "Unbalanced []";

				$('#errorMessageText').text(reasonOfBasicError)
				
				
				return;
			}
					
        
      	// indent the code
        var elaboratedSource = "\t"+editorContent.replace(
			new RegExp( "\\n", "g" ), "\n\t"
		);
        elaboratedSource = "draw = ->\n" + elaboratedSource;
        
        // little trick. This is mangled up in the translation from coffeescript
        // (1).times ->
        // But this isn't:
        // (1+0).times ->
        // So here is the little replace.
        
        // TODO: you should be a little smarter about the substitution of the draw method
        // You can tell a method declaration because the line below is indented
        // so you should check that.
        
        
        //elaboratedSource =  elaboratedSource.replace(/^([a-z]+[a-zA-Z0-9]+)\s*$/gm, "$1 = ->" );
        
        // some replacements add a semicolon for the
        // following reason: coffeescript allows you to split arguments
        // over multiple lines.
        // So if you have:
        //   rotate 0,0,1
        //   box
        // and you want to add a scale like so:
        //   scale 2,2,2
        //   rotate 0,0,1
        //   box
        // What happens is that as you are in the middle of typing:
        //   scale 2,
        //   rotate 0,0,1
        //   box
        // coffeescript takes the rotate as the second argument of scale
        // causing mayhem.
        // Instead, all is good if rotate is prepended with a semicolon.
        
        
        elaboratedSource =  elaboratedSource.replace(/(\d+)\s+times[ ]*\->/g, ";( $1 + 0).times ->" );


        // if there is at least one doOnce:
        // split the source in lines
        // add all the line numbers info
        // regroup the lines into a single string again
        
        //alert('soon before replacing doOnces'+elaboratedSource);
        if (elaboratedSource.indexOf('doOnce') > -1){
        	//alert("a doOnce is potentially executable");
			elaboratedSourceByLine = elaboratedSource.split("\n");
			//alert('splitting: ' + elaboratedSourceByLine.length );
			for (var iteratingOverSource = 0; iteratingOverSource < elaboratedSourceByLine.length; iteratingOverSource++) {
				//alert('iterating: ' + iteratingOverSource );
				elaboratedSourceByLine[iteratingOverSource] = elaboratedSourceByLine[iteratingOverSource].replace(/^(\s*)doOnce[ ]*\->[ ]*(.+)$/gm, "$1;doLNOnce.push("+(iteratingOverSource-1)+"); (1+0).times -> $2" );
				
				if (elaboratedSourceByLine[iteratingOverSource].match(/^(\s*)doOnce[ ]*\->[ ]*$/gm)) {
					//alert('doOnce multiline!');
					elaboratedSourceByLine[iteratingOverSource] = elaboratedSourceByLine[iteratingOverSource].replace(/^(\s*)doOnce[ ]*\->[ ]*$/gm, "$1(1+0).times ->" );
					elaboratedSourceByLine[iteratingOverSource+1] = elaboratedSourceByLine[iteratingOverSource+1].replace(/^(\s*)(.+)$/gm, "$1;doLNOnce.push("+(iteratingOverSource-1)+"); $2" );
				}
				
			}
			elaboratedSource = elaboratedSourceByLine.join("\n");
        	//alert('soon after replacing doOnces'+elaboratedSource);
        }
        


        elaboratedSource =  elaboratedSource.replace(/^(\s*)([a-z]+[a-zA-Z0-9]+)[ ]*$/gm, "$1;$2()" );
        
        // this takes care of when a token that it's supposed to be
        // a function is inlined with something else e.g.
        // doOnce frame = 0; box
        // 2 times -> box
        elaboratedSource =  elaboratedSource.replace(/;\s*([a-z]+[a-zA-Z0-9]+)[ ]*([;\n]+)/g, ";$1()$2" );
        // this takes care of when a token that it's supposed to be
        // a function is inlined like so:
        // 2 times -> box
        elaboratedSource =  elaboratedSource.replace(/\->\s*([a-z]+[a-zA-Z0-9]+)[ ]*([;\n]+)/g, ";$1()$2" );

			// draw() could just be called by mistake and it's likely
			// to be disastrous. User doesn't even have visibility of such method,
			// why should he/she call it?
			// TODO: call draw() something else that the user is not
			// likely to use by mistake and take away this check.
			if (
				elaboratedSource.match(/[\s\+\;]+draw\s*\(/) ||
				false
			){
				 if(autocodeOn) {
					 editor.undo();
					 //alert("did an undo");
					 return;
				 }
				programHasBasicError = true;
				$('#dangerSignText').css('color','red');
				$('#errorMessageText').text("You can't call draw()");
				return;
			}


        // we don't want if and for to undergo the same tratment as, say, box
        // so put those back to normal.
        elaboratedSource =  elaboratedSource.replace(/;if\(\)/g, ";if" );
        elaboratedSource =  elaboratedSource.replace(/;for\(\)/g, ";for" );

        elaboratedSource =  elaboratedSource.replace(/\/\//g, "#" );
        elaboratedSource =  elaboratedSource.replace(/scale(\s)+/g, ";scale$1" );
        elaboratedSource =  elaboratedSource.replace(/rotate(\s)+/g, ";rotate$1" );
        elaboratedSource =  elaboratedSource.replace(/move(\s)+/g, ";move$1" );
        elaboratedSource =  elaboratedSource.replace(/rect(\s)+/g, ";rect$1" );
        elaboratedSource =  elaboratedSource.replace(/line(\s)+/g, ";line$1" );
        elaboratedSource =  elaboratedSource.replace(/bpm(\s)+/g, ";bpm$1" );
        elaboratedSource =  elaboratedSource.replace(/addSound(\s)+/g, ";addSound$1" );
        elaboratedSource =  elaboratedSource.replace(/pushMatrix(\s)+/g, ";pushMatrix$1" );
        elaboratedSource =  elaboratedSource.replace(/popMatrix(\s)+/g, ";popMatrix$1" );
        elaboratedSource =  elaboratedSource.replace(/resetMatrix(\s)+/g, ";resetMatrix$1" );
        elaboratedSource =  elaboratedSource.replace(/fill(\s)+/g, ";fill$1" );
        elaboratedSource =  elaboratedSource.replace(/noFill(\s)+/g, ";noFill$1" );
        elaboratedSource =  elaboratedSource.replace(/stroke(\s)+/g, ";stroke$1" );
        elaboratedSource =  elaboratedSource.replace(/noStroke(\s)+/g, ";noStroke$1" );
        elaboratedSource =  elaboratedSource.replace(/strokeSize(\s)+/g, ";strokeSize$1" );
        elaboratedSource =  elaboratedSource.replace(/animationStyle(\s)+/g, ";animationStyle$1" );
        elaboratedSource =  elaboratedSource.replace(/simpleGradient(\s)+/g, ";simpleGradient$1" );
        elaboratedSource =  elaboratedSource.replace(/background(\s)+/g, ";background$1" );
        elaboratedSource =  elaboratedSource.replace(/color(\s)+/g, ";color$1" );
        //elaboratedSource =  elaboratedSource.replace(/ambient(\s)+/g, ";ambient$1" );
        //elaboratedSource =  elaboratedSource.replace(/reflect(\s)+/g, ";reflect$1" );
        //elaboratedSource =  elaboratedSource.replace(/refract(\s)+/g, ";refract$1" );
        elaboratedSource =  elaboratedSource.replace(/lights(\s)+/g, ";lights$1" );
        elaboratedSource =  elaboratedSource.replace(/noLights(\s)+/g, ";noLights$1" );
        elaboratedSource =  elaboratedSource.replace(/ambientLight(\s)+/g, ";ambientLight$1" );
        elaboratedSource =  elaboratedSource.replace(/pointLight(\s)+/g, ";pointLight$1" );
        elaboratedSource =  elaboratedSource.replace(/ball(\s)+/g, ";ball$1" );
        elaboratedSource =  elaboratedSource.replace(/ballDetail(\s)+/g, ";ballDetail$1" );

        // the semicolon mangles the first line of the function definitions
        // coffeescript doesn't like that
        elaboratedSource =  elaboratedSource.replace(/->(\s+);/g, "->$1" );

        // the semicolon mangles the first line of if statements
        // coffeescript doesn't like that
        elaboratedSource =  elaboratedSource.replace(/(\s)if\s*([a-zA-Z0-9]*)(\s*);/g, "$1if $2$3" );
        
      
        //console.log(elaboratedSource );
        out = CoffeeScript.compile(elaboratedSource, {
          bare: "on"
        });
        //console.log("in javascript: " + out);
        
      } catch (e) {

				 if(autocodeOn) {
					 editor.undo();
					 //alert("did an undo");
					 return;
				 }

			$('#dangerSignText').css('color','red')
			var coffeeScriptErrorMessage = ""+e;
			if (coffeeScriptErrorMessage.indexOf("Unexpected 'INDENT'") > -1){
				coffeeScriptErrorMessage = "weird indentation"
			}
			else if (coffeeScriptErrorMessage.indexOf("Unexpected 'TERMINATOR'") > -1){
				coffeeScriptErrorMessage = "line not complete"
			}
			else if (coffeeScriptErrorMessage.indexOf("Unexpected 'CALL_END'") > -1){
				coffeeScriptErrorMessage = "line not complete"
			}
			else if (coffeeScriptErrorMessage.indexOf("Unexpected '}'") > -1){
				coffeeScriptErrorMessage = "something wrong"
			}
			else if (coffeeScriptErrorMessage.indexOf("Unexpected 'MATH'") > -1){
				coffeeScriptErrorMessage = "weird arithmetic there"
			}
			else if (coffeeScriptErrorMessage.indexOf("Unexpected 'LOGIC'") > -1){
				coffeeScriptErrorMessage = "odd expression thingy"
			}
			else if (coffeeScriptErrorMessage.indexOf("Unexpected 'NUMBER'") > -1){
				coffeeScriptErrorMessage = "lost number?"
			}
			$('#errorMessageText').text(coffeeScriptErrorMessage)
        return;
      }


      // FINDS USED METHODS WHICH ARE NOT DECLARED
	  var matchDeclaredMethod = /([a-z]+[a-zA-Z0-9]*) = function/ ;
	  var declaredMethods = [];
	  var mc;
	  var copyOfOut = out;
	  while ((mc = copyOfOut.match( matchDeclaredMethod  ))) {
        declaredMethods.push(mc[1]);
        copyOfOut = RegExp.rightContext;
      }
      //alert("found declared methods " + declaredMethods.length);
      //alert("out:"+out)


	  var usedMethods = [];
	  var md;
	  copyOfOut = out;
	  while ((md = copyOfOut.match(  /\s([a-z]+[a-zA-Z0-9]*)\(/ ))) {
        usedMethods.push(md[1]);
        copyOfOut = RegExp.rightContext;
      }
      //alert("found used methods " + usedMethods.length);
      
	  var error = false;
      for (var scanningUsedMethods = 0; scanningUsedMethods < usedMethods.length; scanningUsedMethods++){
		  if (
			  usedMethods[scanningUsedMethods] === "function" ||
			  usedMethods[scanningUsedMethods] === "rotate" ||
			  usedMethods[scanningUsedMethods] === "rect" ||
			  usedMethods[scanningUsedMethods] === "line" ||
			  usedMethods[scanningUsedMethods] === "box" ||
			  usedMethods[scanningUsedMethods] === "move" ||
			  usedMethods[scanningUsedMethods] === "scale" ||
			  usedMethods[scanningUsedMethods] === "alert" ||
			  usedMethods[scanningUsedMethods] === "bpm" ||
			  usedMethods[scanningUsedMethods] === "addSound" ||
			  usedMethods[scanningUsedMethods] === "pushMatrix" ||
			  usedMethods[scanningUsedMethods] === "popMatrix" ||
			  usedMethods[scanningUsedMethods] === "resetMatrix" ||
			  usedMethods[scanningUsedMethods] === "fill" ||
			  usedMethods[scanningUsedMethods] === "noFill" ||
			  usedMethods[scanningUsedMethods] === "stroke" ||
			  usedMethods[scanningUsedMethods] === "noStroke" ||
			  usedMethods[scanningUsedMethods] === "strokeSize" ||
			  usedMethods[scanningUsedMethods] === "animationStyle" ||
			  usedMethods[scanningUsedMethods] === "background" ||
			  usedMethods[scanningUsedMethods] === "simpleGradient" ||
			  usedMethods[scanningUsedMethods] === "color" ||
			  //usedMethods[scanningUsedMethods] === "ambient" ||
			  //usedMethods[scanningUsedMethods] === "reflect" ||
			  //usedMethods[scanningUsedMethods] === "refract" ||
			  usedMethods[scanningUsedMethods] === "lights" ||
			  usedMethods[scanningUsedMethods] === "noLights" ||
			  usedMethods[scanningUsedMethods] === "ambientLight" ||
			  usedMethods[scanningUsedMethods] === "pointLight" ||
			  usedMethods[scanningUsedMethods] === "ball" ||
			  usedMethods[scanningUsedMethods] === "ballDetail" ||
			  false
		  ){
		  	continue;
		  }
      	  if (declaredMethods.length == 0){
			  error = true;
			  //alert("used method not declared: " + usedMethods[scanningUsedMethods]);
			  $('#dangerSignText').css('color','red');
			  $('#errorMessageText').text(usedMethods[scanningUsedMethods] + " doesn't exist");
			  return;
      	  }
		  for (var scanningDeclaredMethods = 0; scanningDeclaredMethods < declaredMethods.length; scanningDeclaredMethods++){
		  	//alert ("comparing >" + usedMethods[scanningUsedMethods]  + "< , >" + declaredMethods[scanningDeclaredMethods] +"<");
		  	if (usedMethods[scanningUsedMethods] === declaredMethods[scanningDeclaredMethods]){
		  		break;
		  	}
		  	else if (scanningDeclaredMethods == declaredMethods.length - 1) {
			  error = true;
			  //alert("used method not declared: " + usedMethods[scanningUsedMethods]);
			  $('#dangerSignText').css('color','red');
			  $('#errorMessageText').text(usedMethods[scanningUsedMethods] + " doesn't exist");
			  return;
		  	}
		  }
      }


				programHasBasicError = false;
				reasonOfBasicError = "";
				$('#dangerSignText').css('color','#000000')
				$('#errorMessageText').text(reasonOfBasicError)

	// see here for the deepest examination ever of "eval"
	// http://perfectionkills.com/global-eval-what-are-the-options/
	// note that exceptions are caught by the window.onerror callback
	consecutiveFramesWithoutRunTimeError = 0;
	
	// so it turns out that when you ASSIGN to the frame variable inside
	// the coffeescript, it declares a local one, which makes changing
	// it impossible.
	// TODO: There must be a way to tell coffeescript to accept
	// some variables as global, for the time being let's put
	// the cheap hack in place.
	out = out.replace(/var frame/,";");
	
    //alert("out:"+out);
	window.eval(out);

      
}

//var chromeHackUncaughtReferenceName = '';
//var chromeHackUncaughtReferenceNames = [];

window.onerror=function(msg, url, linenumber){

 if(autocodeOn) {
	 editor.undo();
	 //alert("did an undo");
	 return;
 }
 
if (msg.indexOf("Uncaught ReferenceError: ") > -1){
	msg = msg.substring(25);
}

 $('#dangerSignText').css('color','red');
 $('#errorMessageText').text(msg);
 
 // ok so this is kind of a hack that we need to put
 // in place for Chrome (both Windows and Mac)
 // what Chrome does is: when there is a function call,
 // it evaluates the arguments
 // of a function even if the function is undefined
 // so for example
 // doO alert "miao"
 // alerts a miao, because it's translated into
 // doO(alert("miao))
 // and even if doO is undefined, the argumen is evaluated
 // This is a problem because doOnce would encourage
 // the following use: misspell doOnce until the rest of the
 // line is finished, then correct the mispell to actually
 // run the line once.
 // But unfortunately because of the quirk described above,
 // that wouldn't work in Chrome.
 
 /*
 if (msg.indexOf("Uncaught ReferenceError") > -1) {
 	chromeHackUncaughtReferenceName = msg.split(' ')[2];

	var lengthToCheck = chromeHackUncaughtReferenceNames.length;
	if (lengthToCheck == 0){
		chromeHackUncaughtReferenceNames.push(chromeHackUncaughtReferenceName);
	}
	else {
		for (var iteratingOverSource = 0; iteratingOverSource < lengthToCheck; iteratingOverSource++) {
			if (chromeHackUncaughtReferenceNames[iteratingOverSource].indexOf(chromeHackUncaughtReferenceName) > -1) {
				break;
			}
			else if (iteratingOverSource == lengthToCheck-1) {
			 // if we are here it means that the variable is not in the array
			 chromeHackUncaughtReferenceNames.push(chromeHackUncaughtReferenceName);
			}
		}
	}
 }
 */
 
 // we set this to 6 because we save it as stable
 // when it's 5, so we avoid re-saving.
 consecutiveFramesWithoutRunTimeError = 6;
 window.eval(lastStableProgram);

 return true
}

function background(r, g, b) {

			clearDisplayList();

			// canvas renderer
			theColor = new THREE.Color();
			theColor.setRGB(r, g,b);
			renderer.setClearColor(theColor,1);



}

// animation loop
		var loopInterval;
		var time;
		var timeAtStart;
    	function animate() {

			// loop on request animation loop
			// - it has to be at the begining of the function
			// - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
			// requestAnimationFrame seems to only do 60 fps, which in my case is too much,
			// I rather prefer to have a slower framerate but steadier.
			
			if (useRequestAnimationFrame) {
				if (wantedFramesPerSecond === -1) {
					requestAnimationFrame( animate );
				}
				else {
					//setTimeout("window.requestAnimationFrame(animate)",
                    //       1000 / wantedFramesPerSecond);
                    if (loopInterval === undefined) {
						loopInterval = setInterval("window.requestAnimationFrame(animate)",
							   1000 / wantedFramesPerSecond);
                    }
				}
			}
			else {
				setTimeout( 'animate();', 1000 / wantedFramesPerSecond );
			}

			//clearDisplayList();
			matrixStack = [];
			worldMatrix.identity();

			// the sound list needs to be cleaned
			// and the beatsPerMinute set to zero
			// so that the user program can create its own from scratch
			beatsPerMinute = 0;
			soundLoops.soundIDs = [];
			soundLoops.beatStrings = [];


			//rootObject = new THREE.Object3D();
			//scene.add(rootObject);
			//parentObject = rootObject;

			if (typeof(draw) != "undefined") {
			  var d = new Date();
			  if (frame===0) {
				  timeAtStart = d.getTime();
				  time = 0;
			  }
			  else {
				  time = d.getTime() - timeAtStart;
			  }
			  doLNOnce = [];
			  fill(0xFFFFFFFF);
			  stroke(0xFF000000);
			  currentStrokeSize = 1;
 			 defaultNormalFill = true;
 			 defaultNormalStroke = true;
 			 ballDetLevel = ballDefaultDetLevel;
			  noLights();
			  usedLines = 0;
			  usedRectangles = 0;
			  usedBoxes = 0;
			  usedAmbientLights = 0;
			  usedPointLights = 0;
			  // In theory there is no need to chuck away the
			  // counter altogether, you could go through
			  // the existing counters contained in this object
			  // (one for each ball detail ever used)
			  // and set it to zero. That would maybe save
			  // some garbage collection time.
			  // But it's probably not worth it...
			  usedSpheres = {};
			  animationStyleValue = normal;
			  resetGradientStack();
			  //bpm(0);
			  draw();
			  // we have to repeat this check because in the case
			  // the user has set frame = 0,
			  // then we have to catch that case here
			  // after the program has executed
			  if (frame===0) {
				  timeAtStart = d.getTime();
				  time = 0;
			  }
			  animationStyleUpdateIfChanged();
			  simpleGradientUpdateIfChanged();
			  updateBpmIfChanged();
			  frame++;
			  consecutiveFramesWithoutRunTimeError++;
			  if (consecutiveFramesWithoutRunTimeError == 5) {
			  	lastStableProgram = out;
			  	//chromeHackUncaughtReferenceName = '';
			  }
			}

			// do the render
			combDisplayList();
			render();
			//clearDisplayList();

			// update stats
			stats.update();
			
			
			if (doLNOnce.length !== 0){
				//alert("a doOnce has been ran");
				elaboratedSource = editor.getValue();
				elaboratedSourceByLine = elaboratedSource.split("\n");
				//alert('splitting: ' + elaboratedSourceByLine.length );
				for (var iteratingOverSource = 0; iteratingOverSource < doLNOnce.length; iteratingOverSource++) {
					//alert('iterating: ' + iteratingOverSource );
					elaboratedSourceByLine[doLNOnce[iteratingOverSource]] = elaboratedSourceByLine[doLNOnce[iteratingOverSource]].replace(/^(\s*)doOnce([ ]*\->[ ]*.+)$/gm, "$1\u2713doOnce$2" );
					elaboratedSourceByLine[doLNOnce[iteratingOverSource]] = elaboratedSourceByLine[doLNOnce[iteratingOverSource]].replace(/^(\s*)doOnce([ ]*\->[ ]*)$/gm, "$1\u2713doOnce$2" );
				}
				elaboratedSource = elaboratedSourceByLine.join("\n");
				
				var cursorPositionBeforeAddingCheckMark = editor.getCursor();
				cursorPositionBeforeAddingCheckMark.ch = cursorPositionBeforeAddingCheckMark.ch + 1;
				editor.setValue(elaboratedSource);
				editor.setCursor(cursorPositionBeforeAddingCheckMark);
				
				// we want to avoid that another frame is run with the old
				// code, as this would mean that the
				// runOnce code is run more than once,
				// so we need to register the new code.
				// TODO: ideally we don't want to register the
				// new code by getting the code from codemirror again
				// because we don't know what that entails. We should
				// just pass the code we already have.
				// Also registerCode() may split the source code by line, so we can
				// avoid that since we've just split it, we could pass
				// the already split code.
				registerCode();
        	}

			
		}

	var lastkey = 0
	var fakeText = true;
	document.onkeypress = function(e){

		if (fakeText && editor.getValue() !== "") shrinkFakeText(e);
	
	};
	
    var shrinkFakeText = function(e) {

		if (e !== undefined){
			var theEvent = e || window.event;
			var key = theEvent.keyCode || theEvent.which;
			key = String.fromCharCode( key ); 
		}
		else key = '';

	    var currentCaption = $('#caption').html();
	    var shorterCaption  = currentCaption.substring(0,currentCaption.length - 1);
	    $('#caption').html( shorterCaption + key + "|");
	    $('#fakeStartingBlinkingCursor').html('');
	    
		  $("#toMove").animate(
		  {
			opacity: 0,
			margin: -100,
			fontSize:300,
			left: 0
		  }, "fast");
		  
		  setTimeout('$("#formCode").animate({opacity: 1}, "fast");',120);
		  setTimeout('$("#justForFakeCursor").hide();',200);
		  setTimeout('$("#toMove").hide();',200);
		  //setTimeout('clearTimeout(fakeCursorInterval);',200);
		  fakeText = false;

    }
    

var parentObject, rootObject, rotate, move;
parentObject = 0;
rootObject = 0;
var currentObject;
var beatsPerMinute = 0;
var oldBeatsPerMinute = 0;
var soundLoopTimer;
var beatNumber = 0;

bpm = function(a) {

	beatsPerMinute = a;
	updateBpmIfChanged();
}

updateBpmIfChanged = function() {
	if (oldBeatsPerMinute !== beatsPerMinute){
		//alert('changing beats per minute old ' + oldBeatsPerMinute + ' new: ' + beatsPerMinute);
		clearTimeout(soundLoopTimer);
		
		if (beatsPerMinute !== 0) {
				soundLoopTimer = setInterval('soundLoop();',(1000*60)/beatsPerMinute);
		}
    	oldBeatsPerMinute = beatsPerMinute;
    }
	//alert('AFTER old ' + oldBeatsPerMinute + ' new: ' + a);

}

soundLoop = function() {
			//clearTimeout(soundLoopTimer);
			//alert('soundLoop');
			
			//if (beatsPerMinute !== 0) {
			//		soundLoopTimer = setTimeout('soundLoop();',(1000*60)/beatsPerMinute);
			//}
			
			if (soundSystemIsMangled) return;
			
			beatNumber++;
			beatNumber = beatNumber % 16;

			//console.log('about to loop in '+soundLoops.soundIDs+" of length "+soundLoops.soundIDs.length);
			for(var loopingTheSoundIDs = 0; loopingTheSoundIDs < soundLoops.soundIDs.length; loopingTheSoundIDs++){
				var loopedSoundID = soundLoops.soundIDs[loopingTheSoundIDs];
				var playOrNoPlay;
				playOrNoPlay = soundLoops.beatStrings[loopingTheSoundIDs].charAt(beatNumber);
				//console.log('checking sound loop '+soundLoops.beatStrings[loopingTheSoundIDs]+" beat "+beatNumber+" : "+playOrNoPlay);
				if (playOrNoPlay === 'x') {
					// OK so this is what we do here:
					// when each Audio object plays, it plays from start to end
					// and you can't get it to re-start until it's completely done
					// playing.
					// This is bad because some sounds last a second or so, and they
					// need to play more often than one time per second.
					// So there are two possible solutions:
					// 1) to have 20 or so sound objects, and all the times that
					//    a file needs playing, scan them and find one that is free,
					//    then associate that to the file one wants to play
					//    this works well in IE and Chrome but really bad in Safari
					// 2) for each file, give it a queue of audio objects.
					//    This is more complicated but seems to work
					//    about right in all browsers. Only caveat is that Safari
					//    needs the audio objects to be preloaded because otherwise
					//    it jams. Conversely, IE and Chrome don't like them preloaded
					//    because they have a limit of 35 or so sounds.
					// So here we went for 2), and we preload the sounds only for
					// browsers other than Chrome and IE.
					var relevantSoundBank = soundBank[loopedSoundID];
					var lengthOfSoundBank = relevantSoundBank.length;
					var availableSoundBank = undefined;
					//console.log('playing  '+loopedSoundID+" length: "+lengthOfSoundBank);
					for (var checkingAvailableSoundBank = 0; checkingAvailableSoundBank < lengthOfSoundBank; checkingAvailableSoundBank++){
						var checkingSoundBank = relevantSoundBank[checkingAvailableSoundBank];
						if (checkingSoundBank.isEnded()) {
							availableSoundBank = checkingSoundBank;
							//console.log('sound bank '+checkingAvailableSoundBank+" is available ");
							break;							
						}
						else {
							//console.log('sound bank '+checkingAvailableSoundBank+" has not ended ");
						}
					}
					if (availableSoundBank === undefined){
							//console.log('creating new sound object ');
							if (totalCreatedSoundObjects > 31) {
								soundSystemIsMangled = true;
								$('#soundSystemIsMangledMessage').modal();
								$('#simplemodal-container').height(250);
							}
							availableSoundBank = new buzz.sound(soundFiles[loopedSoundID]);
							soundBank[loopedSoundID].push(availableSoundBank);
							totalCreatedSoundObjects++;
					}
					
					//console.log('using version: ' + soundBank[soundLoops.soundIDs[i]]['lastUsed']);
					//console.log('soundID: ' + soundLoops.soundIDs[i] + " " + soundBank[soundLoops.soundIDs[i]][soundBank[soundLoops.soundIDs[i]]['lastUsed']]);
					availableSoundBank.play()
					//soundBank[soundLoops.soundIDs[i]]['lastUsed'] = (soundBank[soundLoops.soundIDs[i]]['lastUsed']+1)%CHANNELSPERSOUND;
				}
			}
}


addSound = function(soundID,beatString) {
    		beatString = beatString.replace(/\s*/g,"");
    		soundLoops.soundIDs.push(soundID);
    		soundLoops.beatStrings.push(beatString);
    		//console.log('pushing '+soundID+" beat: "+beatString);
}

var matrixStack = [];
pushMatrix = function(){
	matrixStack.push(worldMatrix);
	worldMatrix = (new THREE.Matrix4()).copy(worldMatrix);
}

popMatrix = function(){
	if (matrixStack.length !== 0)
		worldMatrix = matrixStack.pop();
	else
		worldMatrix.identity();
}

resetMatrix = function(){
	worldMatrix.identity();
}

move = function(a, b, c) {
  /*
  currentObject = new THREE.Object3D();
  currentObject.position.x = a;
  currentObject.position.y = b;
  currentObject.position.z = c;
  parentObject.add(currentObject);
  parentObject = currentObject;
  */
  worldMatrix.translate(new THREE.Vector3(a,b,c));
};

rotate = function(a, b, c) {

  if(arguments.length == 0){
  	  a = time/1000;
  	  b = a;
  	  c = a;
  }
  else if(arguments.length == 1){
  	  b=a; c=a;
  }
  else if(arguments.length == 2){
  	  c=0;
  }

  /*
  currentObject = new THREE.Object3D();
  currentObject.rotation.x = a;
  currentObject.rotation.y = b;
  currentObject.rotation.z = c;
  parentObject.add(currentObject);
  parentObject = currentObject;
  */
  //worldMatrix.setRotationFromEuler(new THREE.Vector3(a,b,c));
  worldMatrix.rotateX(a).rotateY(b).rotateZ(c);

};

scale = function(a, b, c) {
  if(arguments.length == 0){
  	  return;
  }
  else if(arguments.length == 1){
  	  b=a; c=a;
  }
  else if(arguments.length == 2){
  	  c=1;
  }
  
  // odd things happen setting scale to zero
  if (a < 0.000000001) a = 0.000000001;
  if (b < 0.000000001) b = 0.000000001;
  if (c < 0.000000001) c = 0.000000001;

  /*
  currentObject = new THREE.Object3D();
  currentObject.scale.x = a;
  currentObject.scale.y = b;
  currentObject.scale.z = c;
  parentObject.add(currentObject);
  parentObject = currentObject;
  */
  worldMatrix.scale(new THREE.Vector3(a,b,c));

};


  // TODO Note that lines have a "solid fill" mode
  // and something similar to the normalMaterial mode
  // but there is no equivalent to the lambert material
  // mode.
  // That could be done by somehow mixing the color of
  // an ambient light to the color of the stroke
  // (although which ambient light do you pick if there
  // is more than one?)
  line = function(a) {
  	
  	if (!doStroke) {
  		return;
  	}
  	
  	if(a === undefined){
  	  a=1;
  	  }

    
    var mesh = linesPool[usedLines];
    if ( mesh === undefined){
		var lineBasicMaterialCOL = new THREE.LineBasicMaterial({
			//color: currentStrokeColor,
			opacity: currentStrokeAlpha,
			linewidth: currentStrokeSize,
		});

      mesh = new THREE.Line(lineGeometry, lineBasicMaterialCOL);
      mesh.isLine = true;
      mesh.isRectangle = false;
      mesh.isBox = false;
      mesh.isAmbientLight = false;
      mesh.isPointLight = false;
      mesh.isSphere = 0;
      linesPool.push(mesh);
      scene.add(mesh);
    }
    else {
    	//mesh.geometry = lineGeometry;
    	//mesh.material = lineBasicMaterialCOL;
    	//mesh.material.color.setHex(currentStrokeColor);
		mesh.material.opacity = currentStrokeAlpha;
		mesh.material.linewidth = currentStrokeSize;
    }
    usedLines++;
    
    // old unpooled mechanism
    //var mesh = new THREE.Line(lineGeometry, lineBasicMaterialCOL);

    mesh.matrixAutoUpdate = false;
    mesh.matrix.copy(worldMatrix);
    mesh.matrixWorldNeedsUpdate = true;
  	if( a !== 1){
      mesh.matrix.scale(new THREE.Vector3(1,a,1));
      // in theory the docs say that we should change the boundradius
      // but I don't think that we need it...
      //mesh.boundRadiusScale = Math.max(a,b,c);
    }
    
    // setting the color after the geometry has been dealt with
    // because in case we use the angleColor then we
    // need to know the geometry.
    if(currentStrokeColor === angleColor || defaultNormalStroke){
		var sasaas = mesh.matrix.multiplyVector3( new THREE.Vector3(0,1,0) ).normalize();
		//console.log(sasaas.x+ " " + sasaas.y + " " + sasaas.z);
		mesh.material.color.setHex(color(((sasaas.x+1)/2)*255,((sasaas.y+1)/2)*255,((sasaas.z+1)/2)*255));
    }
    else {
    	mesh.material.color.setHex(currentStrokeColor);
	}

  }

	// ambientColor is always white
	// because it needs to reflect what the
	// ambient light color is
	// I tried to set the ambientColor directly
	// but it doesn't work. It needs to be white so
	// that the tint of the ambientLight is shown. 
  var ambientColor = color(255,255,255);
  //ambient = function(a) {
  	//ambientColor = a;
  //}

  var reflectValue = 1;
  //reflect = function(a) {
	//  reflectValue = a;
  //}
  var refractValue = 0.98;
  //refract = function(a) {
	//  refractValue = a;
  //}
  var lightsAreOn = false;
  lights = function() {
	  lightsAreOn = true;
  }
  noLights = function() {
	  lightsAreOn = false;
  }

  rect = function(a,b) {
  	
  	// simple case - if there is no fill and
  	// no stroke then there is nothing to do.
	var startIndex = 0;
	var endIndex = 0;

  	if (!doFill && !doStroke) {
  		return;
  	}
  	// if the wireframe is not going to be visible on top of the
  	// fill then don't draw it
  	else if ((doFill && (currentStrokeSize === 0 || !doStroke || (currentStrokeSize <= 1 && !defaultNormalFill && !defaultNormalStroke && currentStrokeColor === currentFillColor && currentFillAlpha === 1 && currentStrokeAlpha === 1))) || (currentStrokeSize <= 1 && defaultNormalFill && defaultNormalStroke)) {
  		//if (doStroke) console.log('smart optimisation, was supposed to do the stroke but not doing it!!');
  		startIndex = 0;
  		endIndex = 1;
  	}
  	else if (!doFill && doStroke) {
  		startIndex = 1;
  		endIndex = 2;
  	}
  	else {
  		startIndex = 0;
  		endIndex = 2;
  	}
  	//console.log("si: " + startIndex + " endI: " + endIndex );
  	
  	if(a === undefined){
  	  a=1; b=1;
  	  }
  	  
  	else if(arguments.length === 1){
  	  b=a;
  	  }
  	
	var strokeTime = false;
	var colorToBeUsed;
	var alphaToBeUsed;
	var newRectCreated = false;
	
	// this is to run the code twice. This should be neater
	// and turned into a function call really.
	for (var fillAndStroke = startIndex; fillAndStroke < endIndex; fillAndStroke++) {
		if (fillAndStroke === 1) {
			strokeTime = true;
			colorToBeUsed = currentStrokeColor;
			alphaToBeUsed = currentStrokeAlpha;
		}
		else {
			colorToBeUsed = currentFillColor;
			alphaToBeUsed = currentFillAlpha;
		}
			var pooledRectangle = rectanglesPool[usedRectangles];
			if ( pooledRectangle === undefined){
			  // each pooled rectangle contains a geometry,
			  // a basic material and a lambert material.
			  pooledRectangle = {
					basicMaterial: undefined,
					lambertMaterial: undefined,
					normalMaterial: undefined,
					// the first time we render a mesh we need to
					// render it with the material that takes the
					// bigger buffer space, otherwise the
					// more complicated materials won't show
					// up, see:
					// https://github.com/mrdoob/three.js/issues/1051
					// so we always need to create a normalmaterial
					// and render that material first, in case
					// the user will ever want to use it.
					// Another workaround would be to create a mesh
					// for each different type of material
					neverUsed: true,
					mesh: undefined
			  };
			  newRectCreated = true;
			  rectanglesPool.push(pooledRectangle);
			}
			var applyDefaultNormalColor = false;
			if (!strokeTime) {
				if (defaultNormalFill) {
					applyDefaultNormalColor = true;
				}
				else {
					applyDefaultNormalColor = false;
				}
			}
			else {
				if (defaultNormalStroke) {
					applyDefaultNormalColor = true;
				}
				else {
					applyDefaultNormalColor = false;
				}
			}
				//console.log("rect: default normal color: " + applyDefaultNormalColor);
				//console.log("rect: alphaToBeUsed: " + alphaToBeUsed);
				if (pooledRectangle.neverUsed || (colorToBeUsed === angleColor || applyDefaultNormalColor)){
					// the first time we render a mesh we need to
					// render it with the material that takes the
					// bigger buffer space, see:
					// https://github.com/mrdoob/three.js/issues/1051
					// Another workaround would be to create a mesh
					// for each different type of material
					pooledRectangle.neverUsed = false;
					if (pooledRectangle.normalMaterial === undefined) {
						//console.log("creating normal material");
						pooledRectangle.normalMaterial = new THREE.MeshNormalMaterial({
							opacity: alphaToBeUsed,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledRectangle.normalMaterial.opacity = alphaToBeUsed;
						pooledRectangle.normalMaterial.wireframe = strokeTime;
						pooledRectangle.normalMaterial.doubleSided = true;
						pooledRectangle.normalMaterial.wireframeLinewidth = currentStrokeSize;
					}
					if (pooledRectangle.mesh === undefined){
						pooledRectangle.mesh = new THREE.Mesh(planeGeometry, pooledRectangle.normalMaterial);
						pooledRectangle.startCountdown = SPINFRAMES;
					}
					else {
						//console.log("associating normal material to existing mesh");
						pooledRectangle.mesh.material = pooledRectangle.normalMaterial;
					}
				}
				else if (!lightsAreOn){
					//console.log("rect: lights are not on");
					if (pooledRectangle.basicMaterial === undefined) {
						pooledRectangle.basicMaterial = new THREE.MeshBasicMaterial({
							color: colorToBeUsed,
							opacity: alphaToBeUsed,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledRectangle.basicMaterial.color.setHex(colorToBeUsed);
						pooledRectangle.basicMaterial.opacity = alphaToBeUsed;
						pooledRectangle.basicMaterial.wireframe = strokeTime;
						pooledRectangle.basicMaterial.doubleSided = true;
						pooledRectangle.basicMaterial.wireframeLinewidth = currentStrokeSize;
					}
					if (pooledRectangle.mesh === undefined){
						pooledRectangle.mesh = new THREE.Mesh(planeGeometry, pooledRectangle.basicMaterial);
						pooledRectangle.startCountdown = SPINFRAMES;
					}
					else {
						pooledRectangle.mesh.material = pooledRectangle.basicMaterial;
					}

				}
				// lights are on
				else {
					//console.log("rect: lights are on");
					if (pooledRectangle.lambertMaterial === undefined) {
					  //console.log("creating lambert:"+currentFillColor+" "+currentFillAlpha+" "+ambientColor+" "+reflectValue+" "+refractValue);
					  pooledRectangle.lambertMaterial = new THREE.MeshLambertMaterial({
							color: colorToBeUsed,
							opacity: alphaToBeUsed,
							ambient: ambientColor,
							reflectivity: reflectValue,
							refractionRatio: refractValue,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledRectangle.lambertMaterial.color.setHex(colorToBeUsed);
						pooledRectangle.lambertMaterial.opacity = alphaToBeUsed;
						pooledRectangle.lambertMaterial.wireframe = strokeTime;
						pooledRectangle.lambertMaterial.wireframeLinewidth = currentStrokeSize;
						pooledRectangle.lambertMaterial.doubleSided = true;
						pooledRectangle.lambertMaterial.ambient.setHex(ambientColor);
						pooledRectangle.lambertMaterial.reflectivity = reflectValue;
						pooledRectangle.lambertMaterial.refractionRatio = refractValue;
					}
					if (pooledRectangle.mesh === undefined){
						pooledRectangle.mesh = new THREE.Mesh(planeGeometry, pooledRectangle.lambertMaterial);
						pooledRectangle.startCountdown = SPINFRAMES;
					}
					else {
						pooledRectangle.mesh.material = pooledRectangle.lambertMaterial;
					}
			}

			if (resetTheSpinThingy) {
				pooledRectangle.startCountdown = SPINFRAMES;
				resetTheSpinThingy = false;
				doTheSpinThingy = true;
			}
			if (doTheSpinThingy) pooledRectangle.startCountdown --;
			if (pooledRectangle.startCountdown === -1) doTheSpinThingy = false;
			
			pooledRectangle.mesh.isLine = false;
			pooledRectangle.mesh.isRectangle = true;
			pooledRectangle.mesh.isBox = false;
			pooledRectangle.mesh.isAmbientLight = false;
			pooledRectangle.mesh.isPointLight = false;
			pooledRectangle.mesh.isSphere = 0;
			pooledRectangle.mesh.doubleSided = true;
			
			
			usedRectangles++;

			if (doTheSpinThingy && pooledRectangle.startCountdown > 0) {
				pushMatrix();
				rotate(pooledRectangle.startCountdown/50);			
				//console.log(""+pooledRectangle.startCountdown);			
			}
			
			pooledRectangle.mesh.matrixAutoUpdate = false;
			pooledRectangle.mesh.matrix.copy(worldMatrix);
			pooledRectangle.mesh.matrixWorldNeedsUpdate = true;

			if (doTheSpinThingy && pooledRectangle.startCountdown > 0) {
				popMatrix();
			}

			if( a !== 1 || b !== 1){
				pooledRectangle.mesh.matrix.scale(new THREE.Vector3(a,b,1));
			}
			
			if (newRectCreated) scene.add(pooledRectangle.mesh);

    }
    
  }

  ambientLight = function() {
  	
	var colorToBeUsed;
	if (arguments[0] === undefined) {
		// empty arguments gives some sort
		// of grey ambient light.
		// black is too stark and white
		// doesn't show the effect with the
		// default white fill
		colorToBeUsed = color$1(125);
	}
	else  {
		colorToBeUsed = color(arguments[0], arguments[1], arguments[2], arguments[3]);
	}
	
	var newLightCreated = false;
	lightsAreOn = true;
    defaultNormalFill = false;
    defaultNormalStroke = false;
	
			var pooledAmbientLight = ambientLightsPool[usedAmbientLights];
			if ( pooledAmbientLight === undefined){
			  //console.log('no ambientLight in pool, creating one');
			  pooledAmbientLight = new THREE.AmbientLight(colorToBeUsed);
			  newLightCreated = true;
			  ambientLightsPool.push(pooledAmbientLight);
			}
			else {
    			pooledAmbientLight.color.setHex(colorToBeUsed);
			    //console.log('existing ambientLight in pool, setting color: ' + pooledAmbientLight.color.r + ' ' + pooledAmbientLight.color.g + ' ' + pooledAmbientLight.color.b);
			}

			
			pooledAmbientLight.isLine = false;
			pooledAmbientLight.isRectangle = false;
			pooledAmbientLight.isBox = false;
			pooledAmbientLight.isAmbientLight = true;
			pooledAmbientLight.isPointLight = false;
			pooledAmbientLight.isSphere = 0;
			
			
			usedAmbientLights++;
			pooledAmbientLight.matrixAutoUpdate = false;
			pooledAmbientLight.matrix.copy(worldMatrix);
			pooledAmbientLight.matrixWorldNeedsUpdate = true;

			if (newLightCreated) scene.add(pooledAmbientLight);

    
  }

  var gradStack = [];
  var defaultGradientColor1 = orange;
  var defaultGradientColor2 = red;
  var defaultGradientColor3 = black;
  var whichDefaultBackground;

  pickRandomDefaultGradient = function() {  
	if (whichDefaultBackground === undefined) {
		whichDefaultBackground = Math.floor(Math.random() * 5);
	}
	else {
		whichDefaultBackground = (whichDefaultBackground+1)%5;
	}
	
	  if (whichDefaultBackground === 0){
		  defaultGradientColor1 = orange;
		  defaultGradientColor2 = red;
		  defaultGradientColor3 = black;
		  $("#fakeStartingBlinkingCursor").css('color','white');
	  }
	  else if (whichDefaultBackground === 1){
		  defaultGradientColor1 = white;
		  defaultGradientColor2 = khaki;
		  defaultGradientColor3 = peachpuff;
		  $("#fakeStartingBlinkingCursor").css('color','LightPink');
	  }
	  else if (whichDefaultBackground === 2){
		  defaultGradientColor1 = lightsteelblue;
		  defaultGradientColor2 = lightcyan;
		  defaultGradientColor3 = paleturquoise;
		  $("#fakeStartingBlinkingCursor").css('color','CadetBlue');
	  }
	  else if (whichDefaultBackground === 3){
		  defaultGradientColor1 = silver;
		  defaultGradientColor2 = lightgrey;
		  defaultGradientColor3 = gainsboro;
		  $("#fakeStartingBlinkingCursor").css('color','white');
	  }
	  else if (whichDefaultBackground === 4){
		  defaultGradientColor1 = color(155,255,155);
		  defaultGradientColor2 = color(155,255,155);
		  defaultGradientColor3 = color(155,255,155);
		  $("#fakeStartingBlinkingCursor").css('color','DarkOliveGreen');
	  }
  }

  resetGradientStack = function() {
  	currentGradientStackValue = "";
  	// we could be more efficient and
  	// reuse the previous stack elements
  	// but I don't think it matters here
  	gradStack = [];

	//simpleGradient(color(70),color(30),color(0),1);
	simpleGradient(defaultGradientColor1,defaultGradientColor2,defaultGradientColor3);

  }

  background = function() {
    var a = color(arguments[0], arguments[1], arguments[2], arguments[3]);
	//console.log("adding solid background to stack");
  	//if (a===undefined) a = color(0);
	currentGradientStackValue = currentGradientStackValue + " null null null null "+a+" ";
	gradStack.push(
		{
			gradStacka: undefined,
			gradStackb: undefined,
			gradStackc: undefined,
			gradStackd: undefined,
			solid: a
		}
	);
  }

  simpleGradient = function(a,b,c,d) {
	currentGradientStackValue = currentGradientStackValue + " "+a+""+b+""+c+""+d+"null ";
	gradStack.push(
		{
			gradStacka: a,
			gradStackb: b,
			gradStackc: c,
			gradStackd: d,
			solid: null
		}
	);
	
  }

  var simpleGradientUpdateIfChanged = function() {

	//alert('simpleGradientUpdateIfChanged curr '+currentGradientStackValue + " prev " +previousGradientStackValue );
	if ((currentGradientStackValue === previousGradientStackValue) ) {
  		return;
  	}
  	else {

				previousGradientStackValue = currentGradientStackValue;
				//console.log('repainting background');
				var diagonal = Math.sqrt(Math.pow(scaledBackgroundWidth/2,2)+ Math.pow( scaledBackgroundHeight/2,2));
				var radgrad;
				for (var scanningGradStack = 0; scanningGradStack < gradStack.length; scanningGradStack++) {
					
					if (gradStack[scanningGradStack].gradStacka !== undefined){
						radgrad = backgroundSceneContext.createLinearGradient(scaledBackgroundWidth/2, 0, scaledBackgroundWidth/2, scaledBackgroundHeight);  
						radgrad.addColorStop(0, color.toString(gradStack[scanningGradStack].gradStacka));  
						radgrad.addColorStop(0.5, color.toString(gradStack[scanningGradStack].gradStackb));  
						radgrad.addColorStop(1, color.toString(gradStack[scanningGradStack].gradStackc));    
						
						backgroundSceneContext.globalAlpha = 1.0;
						backgroundSceneContext.fillStyle = radgrad;
						backgroundSceneContext.fillRect(0,0,scaledBackgroundWidth,scaledBackgroundHeight);
					}
					else {
						//console.log("solid background: "+ gradStack[scanningGradStack].solid);
						backgroundSceneContext.globalAlpha = 1.0;
						backgroundSceneContext.fillStyle = color.toString(gradStack[scanningGradStack].solid);
						backgroundSceneContext.fillRect(0,0,scaledBackgroundWidth,scaledBackgroundHeight);
					}
				}				
  	}

  }


  animationStyle = function(a) {
  	// turns out when you type normal that the first two letters "no"
  	// are sent as "false"
    if (a===false) return;
  	if (a===undefined) return;
  	animationStyleValue = a;
  }


  animationStyleUpdateIfChanged = function() {
  	//alert("actual called " + a);

	if ((animationStyleValue !== previousanimationStyleValue) ) {
  		//alert("actual changed!");
  	}
  	else {
  		//alert("no change");
  		return;
  	}

  	previousanimationStyleValue = animationStyleValue;
  	
  	if (isWebGLUsed && animationStyleValue === motionBlur) {
  		effectBlend.uniforms[ 'mixRatio' ].value = 0.7;
  	}
  	else if (!isWebGLUsed && animationStyleValue === motionBlur) {
  		blendAmount = 0.6;
  		//alert('motion blur canvas');
  	}

  	if (isWebGLUsed && animationStyleValue === paintOver) {
  		effectBlend.uniforms[ 'mixRatio' ].value = 1;
  	}
  	else if (!isWebGLUsed && animationStyleValue === paintOver) {
  		blendAmount = 1;
  		//alert('paintOver canvas');
  	}

  	if (isWebGLUsed && animationStyleValue === normal) {
  		effectBlend.uniforms[ 'mixRatio' ].value = 0;
  	}
  	else if (!isWebGLUsed && animationStyleValue === normal) {
  		blendAmount = 0;
  		//alert('normal canvas');
  	}
  		
  }

    
  box = function(a,b,c) {
  	// simple case - if there is no fill and
  	// no stroke then there is nothing to do.
	var startIndex = 0;
	var endIndex = 0;

  	if (!doFill && !doStroke) {
  		return;
  	}
  	// if the wireframe is not going to be visible on top of the
  	// fill then don't draw it
  	else if ((doFill && (currentStrokeSize === 0 || !doStroke || (currentStrokeSize <= 1 && !defaultNormalFill && !defaultNormalStroke && currentStrokeColor === currentFillColor && currentFillAlpha === 1 && currentStrokeAlpha === 1))) || (currentStrokeSize <= 1 && defaultNormalFill && defaultNormalStroke)) {
  		//if (doStroke) console.log('smart optimisation, was supposed to do the stroke but not doing it!!');
  		startIndex = 0;
  		endIndex = 1;
  	}
  	else if (!doFill && doStroke) {
  		startIndex = 1;
  		endIndex = 2;
  	}
  	else {
  		startIndex = 0;
  		endIndex = 2;
  	}
  	//console.log("si: " + startIndex + " endI: " + endIndex );

  	if(a === undefined){
  	  //alert('cube!')
  	  a=1; b=1; c=1;
  	  }
  	  
  	else if(arguments.length === 1){
  	  b=a; c=a;
  	  }

	var strokeTime = false;
	var colorToBeUsed;
	var alphaToBeUsed;
	var newBoxCreated = false;
	

	// this is to run the code twice. This should be neater
	// and turned into a function call really.
	for (var fillAndStroke = startIndex; fillAndStroke < endIndex; fillAndStroke++) {
		if (fillAndStroke === 1) {
			strokeTime = true;
			colorToBeUsed = currentStrokeColor;
			alphaToBeUsed = currentStrokeAlpha;
		}
		else {
			colorToBeUsed = currentFillColor;
			alphaToBeUsed = currentFillAlpha;
		}
			var pooledBox = boxesPool[usedBoxes];
			if ( pooledBox === undefined){
			  // each pooled box contains a geometry,
			  // a basic material and a lambert material.
			  pooledBox = {
					basicMaterial: undefined,
					lambertMaterial: undefined,
					normalMaterial: undefined,
					// the first time we render a mesh we need to
					// render it with the material that takes the
					// bigger buffer space, otherwise the
					// more complicated materials won't show
					// up, see:
					// https://github.com/mrdoob/three.js/issues/1051
					// so we always need to create a normalmaterial
					// and render that material first, in case
					// the user will ever want to use it.
					// Another workaround would be to create a mesh
					// for each different type of material
					neverUsed: true,
					mesh: undefined
			  };
			  newBoxCreated = true;
			  boxesPool.push(pooledBox);
			}
			var applyDefaultNormalColor = false;
			if (!strokeTime) {
				if (defaultNormalFill) {
					applyDefaultNormalColor = true;
				}
				else {
					applyDefaultNormalColor = false;
				}
			}
			else {
				if (defaultNormalStroke) {
					applyDefaultNormalColor = true;
				}
				else {
					applyDefaultNormalColor = false;
				}
			}
				if (pooledBox.neverUsed || (colorToBeUsed === angleColor || applyDefaultNormalColor)){
					// the first time we render a mesh we need to
					// render it with the material that takes the
					// bigger buffer space, see:
					// https://github.com/mrdoob/three.js/issues/1051
					// Another workaround would be to create a mesh
					// for each different type of material
					pooledBox.neverUsed = false;
					if (pooledBox.normalMaterial === undefined) {
						//console.log("creating normal material");
						pooledBox.normalMaterial = new THREE.MeshNormalMaterial({
							opacity: alphaToBeUsed,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledBox.normalMaterial.opacity = alphaToBeUsed;
						pooledBox.normalMaterial.wireframe = strokeTime;
						pooledBox.normalMaterial.wireframeLinewidth = currentStrokeSize;
						pooledBox.normalMaterial.doubleSided = false;
					}
					if (pooledBox.mesh === undefined){
						pooledBox.mesh = new THREE.Mesh(cubeGeometry, pooledBox.normalMaterial);
						pooledBox.startCountdown = SPINFRAMES;
					}
					else {
						//console.log("associating normal material to existing mesh");
						pooledBox.mesh.material = pooledBox.normalMaterial;
					}
				}
				else if (!lightsAreOn){
					if (pooledBox.basicMaterial === undefined) {
						pooledBox.basicMaterial = new THREE.MeshBasicMaterial({
							color: colorToBeUsed,
							opacity: alphaToBeUsed,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledBox.basicMaterial.color.setHex(colorToBeUsed);
						pooledBox.basicMaterial.opacity = alphaToBeUsed;
						pooledBox.basicMaterial.wireframe = strokeTime;
						pooledBox.basicMaterial.wireframeLinewidth = currentStrokeSize;
						pooledBox.basicMaterial.doubleSided = false;
					}
					if (pooledBox.mesh === undefined){
						pooledBox.mesh = new THREE.Mesh(cubeGeometry, pooledBox.basicMaterial);
						pooledBox.startCountdown = SPINFRAMES;
					}
					else {
						pooledBox.mesh.material = pooledBox.basicMaterial;
					}

				}
				// lights are on
				else {
					if (pooledBox.lambertMaterial === undefined) {
					  //console.log("creating lambert:"+currentFillColor+" "+currentFillAlpha+" "+ambientColor+" "+reflectValue+" "+refractValue);
					  pooledBox.lambertMaterial = new THREE.MeshLambertMaterial({
							color: colorToBeUsed,
							opacity: alphaToBeUsed,
							ambient: ambientColor,
							reflectivity: reflectValue,
							refractionRatio: refractValue,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledBox.lambertMaterial.color.setHex(colorToBeUsed);
						pooledBox.lambertMaterial.opacity = alphaToBeUsed;
						pooledBox.lambertMaterial.wireframe = strokeTime;
						pooledBox.lambertMaterial.wireframeLinewidth = currentStrokeSize;
						pooledBox.lambertMaterial.doubleSided = false;
						pooledBox.lambertMaterial.ambient.setHex(ambientColor);
						pooledBox.lambertMaterial.reflectivity = reflectValue;
						pooledBox.lambertMaterial.refractionRatio = refractValue;
					}
					if (pooledBox.mesh === undefined){
						pooledBox.mesh = new THREE.Mesh(cubeGeometry, pooledBox.lambertMaterial);
						pooledBox.startCountdown = SPINFRAMES;
					}
					else {
						pooledBox.mesh.material = pooledBox.lambertMaterial;
					}
			}
			
			if (resetTheSpinThingy) {
				pooledBox.startCountdown = SPINFRAMES;
				resetTheSpinThingy = false;
				doTheSpinThingy = true;
			}
			if (doTheSpinThingy) pooledBox.startCountdown --;
			if (pooledBox.startCountdown === -1) doTheSpinThingy = false;
						
			pooledBox.mesh.isLine = false;
			pooledBox.mesh.isRectangle = false;
			pooledBox.mesh.isBox = true;
			pooledBox.mesh.isAmbientLight = false;
			pooledBox.mesh.isPointLight = false;
			pooledBox.mesh.isSphere = 0;
			pooledBox.mesh.doubleSided = false;
			
						
			usedBoxes++;
			
			if (doTheSpinThingy && pooledBox.startCountdown > 0) {
				pushMatrix();
				rotate(pooledBox.startCountdown/50);			
				//console.log(""+pooledBox.startCountdown);			
			}
			
			pooledBox.mesh.matrixAutoUpdate = false;
			pooledBox.mesh.matrix.copy(worldMatrix);
			pooledBox.mesh.matrixWorldNeedsUpdate = true;

			if (doTheSpinThingy && pooledBox.startCountdown > 0) {
				popMatrix();
			}

			// TODO: meshes should be built from geometries that are
			// ever so slight larger than the "fill" mesh so there
			// is no z-fighting...
			// constant 0.001 below is to avoid z-fighting
			if( a !== 1 || b !== 1 || c !== 1){
				if (! strokeTime) pooledBox.mesh.matrix.scale(new THREE.Vector3(a,b,c));
				else pooledBox.mesh.matrix.scale(new THREE.Vector3(a+0.001,b+0.001,c+0.001));
			}

			if (newBoxCreated) scene.add(pooledBox.mesh);
    }


  }

  ballDetail = function(a) {
	if (a === undefined) return;
	if (a < 2) a = 2;
	if (a > 30) a = 30;
	ballDetLevel = a;
  }

  ball = function(a) {
	var pooledSphereGeometry;
  	// simple case - if there is no fill and
  	// no stroke then there is nothing to do.
	var startIndex = 0;
	var endIndex = 0;

  	//console.log("fill: "+doFill+" stroke: "+doStroke+" fillCol " + currentFillColor + " stroke col " + currentStrokeColor + " fill alpha " + currentFillAlpha);
  	if (!doFill && !doStroke) {
  		return;
  	}
  	// if the wireframe is not going to be visible on top of the
  	// fill then don't draw it
  	else if ((doFill && (currentStrokeSize === 0 || !doStroke || (currentStrokeSize <= 1 && !defaultNormalFill && !defaultNormalStroke && currentStrokeColor === currentFillColor && currentFillAlpha === 1 && currentStrokeAlpha === 1))) || (currentStrokeSize <= 1 && defaultNormalFill && defaultNormalStroke)) {
  		//if (doStroke) console.log('smart optimisation, was supposed to do the stroke but not doing it!!');
  		startIndex = 0;
  		endIndex = 1;
  	}
  	else if (!doFill && doStroke) {
  		startIndex = 1;
  		endIndex = 2;
  	}
  	else {
  		startIndex = 0;
  		endIndex = 2;
  	}
  	//console.log("si: " + startIndex + " endI: " + endIndex );

  	if(a === undefined){
  	  //alert('ball!')
  	  a=1;
  	  }

	var strokeTime = false;
	var colorToBeUsed;
	var alphaToBeUsed;
	var newSphereCreated = false;
	

	// this is to run the code twice. This should be neater
	// and turned into a function call really.
	for (var fillAndStroke = startIndex; fillAndStroke < endIndex; fillAndStroke++) {
		if (fillAndStroke === 1) {
			strokeTime = true;
			colorToBeUsed = currentStrokeColor;
			alphaToBeUsed = currentStrokeAlpha;
		}
		else {
			colorToBeUsed = currentFillColor;
			alphaToBeUsed = currentFillAlpha;
		}
			if (spheresPool[''+ballDetLevel] === undefined) {
				spheresPool[''+ballDetLevel] = [];
				//console.log('creating pool for ball det level ' + ballDetLevel);
			}
			if (usedSpheres[''+ballDetLevel] === undefined) {
				usedSpheres[''+ballDetLevel] = 0;
				//console.log('creating counter for ball det level ' + ballDetLevel);
			}
			var pooledSphere = spheresPool[''+ballDetLevel][usedSpheres[''+ballDetLevel]];
			if ( pooledSphere === undefined){
			  // each pooled sphere contains a geometry,
			  // a basic material and a lambert material.
			  pooledSphere = {
					basicMaterial: undefined,
					lambertMaterial: undefined,
					normalMaterial: undefined,
					// the first time we render a mesh we need to
					// render it with the material that takes the
					// bigger buffer space, otherwise the
					// more complicated materials won't show
					// up, see:
					// https://github.com/mrdoob/three.js/issues/1051
					// so we always need to create a normalmaterial
					// and render that material first, in case
					// the user will ever want to use it.
					// Another workaround would be to create a mesh
					// for each different type of material
					neverUsed: true,
					mesh: undefined
			  };
			  newSphereCreated = true;
			  spheresPool[''+ballDetLevel].push(pooledSphere);
			  //console.log('making space for pool for sphere , size of pool for spheres of detail ' + ballDetLevel + ' is ' + spheresPool[''+ballDetLevel].length);
			}
			var applyDefaultNormalColor = false;
			if (!strokeTime) {
				if (defaultNormalFill) {
					applyDefaultNormalColor = true;
				}
				else {
					applyDefaultNormalColor = false;
				}
			}
			else {
				if (defaultNormalStroke) {
					applyDefaultNormalColor = true;
				}
				else {
					applyDefaultNormalColor = false;
				}
			}
				if (pooledSphere.neverUsed || (colorToBeUsed === angleColor || applyDefaultNormalColor)){
					// the first time we render a mesh we need to
					// render it with the material that takes the
					// bigger buffer space, see:
					// https://github.com/mrdoob/three.js/issues/1051
					// Another workaround would be to create a mesh
					// for each different type of material
					pooledSphere.neverUsed = false;
					if (pooledSphere.normalMaterial === undefined) {
						//console.log("creating normal material");
						pooledSphere.normalMaterial = new THREE.MeshNormalMaterial({
							opacity: alphaToBeUsed,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledSphere.normalMaterial.opacity = alphaToBeUsed;
						pooledSphere.normalMaterial.wireframe = strokeTime;
						pooledSphere.normalMaterial.wireframeLinewidth = currentStrokeSize;
						pooledSphere.normalMaterial.doubleSided = false;
					}
					if (pooledSphere.mesh === undefined){
						pooledSphereGeometry = sphereGeometriesPool[''+ballDetLevel];
						if ( pooledSphereGeometry === undefined) {
							pooledSphereGeometry = new THREE.SphereGeometry(1,ballDetLevel,ballDetLevel);
							sphereGeometriesPool[''+ballDetLevel] = pooledSphereGeometry;
							//console.log('creating ball geometry of detail ' + ballDetLevel);
						}
						pooledSphere.mesh = new THREE.Mesh(pooledSphereGeometry, pooledSphere.normalMaterial);
						pooledSphere.startCountdown = SPINFRAMES;
					}
					else {
						//console.log("associating normal material to existing mesh");
						pooledSphere.mesh.material = pooledSphere.normalMaterial;
					}
				}
				else if (!lightsAreOn){
					if (pooledSphere.basicMaterial === undefined) {
						pooledSphere.basicMaterial = new THREE.MeshBasicMaterial({
							color: colorToBeUsed,
							opacity: alphaToBeUsed,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledSphere.basicMaterial.color.setHex(colorToBeUsed);
						pooledSphere.basicMaterial.opacity = alphaToBeUsed;
						pooledSphere.basicMaterial.wireframe = strokeTime;
						pooledSphere.basicMaterial.wireframeLinewidth = currentStrokeSize;
						pooledSphere.basicMaterial.doubleSided = false;
					}
					if (pooledSphere.mesh === undefined){
						pooledSphereGeometry = sphereGeometriesPool[''+ballDetLevel];
						if ( pooledSphereGeometry === undefined) {
							pooledSphereGeometry = new THREE.SphereGeometry(1,ballDetLevel,ballDetLevel);
							sphereGeometriesPool[''+ballDetLevel] = pooledSphereGeometry;
							//console.log('creating ball geometry of detail ' + ballDetLevel);
						}
						pooledSphere.mesh = new THREE.Mesh(pooledSphereGeometry, pooledSphere.basicMaterial);
						pooledSphere.startCountdown = SPINFRAMES;
					}
					else {
						pooledSphere.mesh.material = pooledSphere.basicMaterial;
					}

				}
				// lights are on
				else {
					if (pooledSphere.lambertMaterial === undefined) {
					  //console.log("creating lambert:"+currentFillColor+" "+currentFillAlpha+" "+ambientColor+" "+reflectValue+" "+refractValue);
					  pooledSphere.lambertMaterial = new THREE.MeshLambertMaterial({
							color: colorToBeUsed,
							opacity: alphaToBeUsed,
							ambient: ambientColor,
							reflectivity: reflectValue,
							refractionRatio: refractValue,
							wireframe: strokeTime,
							wireframeLinewidth: currentStrokeSize,
						});
					}
					else {
						pooledSphere.lambertMaterial.color.setHex(colorToBeUsed);
						pooledSphere.lambertMaterial.opacity = alphaToBeUsed;
						pooledSphere.lambertMaterial.wireframe = strokeTime;
						pooledSphere.lambertMaterial.wireframeLinewidth = currentStrokeSize;
						pooledSphere.lambertMaterial.doubleSided = false;
						pooledSphere.lambertMaterial.ambient.setHex(ambientColor);
						pooledSphere.lambertMaterial.reflectivity = reflectValue;
						pooledSphere.lambertMaterial.refractionRatio = refractValue;
					}
					if (pooledSphere.mesh === undefined){
						pooledSphereGeometry = sphereGeometriesPool[''+ballDetLevel];
						if ( pooledSphereGeometry === undefined) {
							pooledSphereGeometry = new THREE.SphereGeometry(1,ballDetLevel,ballDetLevel);
							sphereGeometriesPool[''+ballDetLevel] = pooledSphereGeometry;
							//console.log('creating ball geometry of detail ' + ballDetLevel);
						}
						pooledSphere.mesh = new THREE.Mesh(pooledSphereGeometry, pooledSphere.lambertMaterial);
						pooledSphere.startCountdown = SPINFRAMES;
					}
					else {
						pooledSphere.mesh.material = pooledSphere.lambertMaterial;
					}
			}

			if (resetTheSpinThingy) {
				pooledSphere.startCountdown = SPINFRAMES;
				resetTheSpinThingy = false;
				doTheSpinThingy = true;
			}
			if (doTheSpinThingy) pooledSphere.startCountdown --;
			if (pooledSphere.startCountdown === -1) doTheSpinThingy = false;
			
			pooledSphere.mesh.isLine = false;
			pooledSphere.mesh.isRectangle = false;
			pooledSphere.mesh.isBox = false;
			pooledSphere.mesh.isAmbientLight = false;
			pooledSphere.mesh.isPointLight = false;
			pooledSphere.mesh.isSphere = ballDetLevel;
			pooledSphere.mesh.doubleSided = false;
			
						
			usedSpheres[''+ballDetLevel] = usedSpheres[''+ballDetLevel]+1;

			if (doTheSpinThingy && pooledSphere.startCountdown > 0) {
				pushMatrix();
				rotate(pooledSphere.startCountdown/50);			
				//console.log(""+pooledSphere.startCountdown);			
			}

			pooledSphere.mesh.matrixAutoUpdate = false;
			pooledSphere.mesh.matrix.copy(worldMatrix);
			pooledSphere.mesh.matrixWorldNeedsUpdate = true;

			if (doTheSpinThingy && pooledSphere.startCountdown > 0) {
				popMatrix();
			}

			// TODO: meshes should be built from geometries that are
			// ever so slight larger than the "fill" mesh so there
			// is no z-fighting...
			// constant 0.001 below is to avoid z-fighting
			if( a !== 1){
				if (! strokeTime) pooledSphere.mesh.matrix.scale(new THREE.Vector3(a,a,a));
				else pooledSphere.mesh.matrix.scale(new THREE.Vector3(a+0.001,a+0.001,a+0.001));
			}

			if (newSphereCreated) scene.add(pooledSphere.mesh);
    }


  }



/**
 * extend the Number prototype
 * @param func
 * @param scope [optional]
 */
Number.prototype.times = function(func, scope){
    var v = this.valueOf();
    for (var i=0; i < v; i++){
        func.call(scope||window,i);
    }
};


/*
To set the flash security settings:
http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html
*/

var simpleCubeDemo = ""+
""+		"// there you go!\n"+
""+		"// a simple cube!\n"+
""+		"\n"+
""+		"background yellow\n"+
""+		"rotate 0,time/2000,time/2000\n"+
""+		"box\n";

var webgltwocubesDemo = ""+
""+		"background 155,255,255\n"+
""+		"2 times ->\n"+
"\t"+		"rotate 0, 1, time/2000\n"+
"\t"+		"box\n";

var cubesAndSpikes = ""+
""+		"simpleGradient fuchsia,color(100,200,200),yellow\n"+
""+		"scale 2.1\n"+
""+		"5 times ->\n"+
"\t"+			"rotate 0,1,time/5000\n"+
"\t"+			"box 0.1,0.1,0.1\n"+
"\t"+			"move 0,0.1,0.1\n"+
"\t"+			"3 times ->\n"+
"\t\t"+				"rotate 0,1,1\n"+
"\t\t"+				"box 0.01,0.01,1\n";

var webglturbineDemo = ""+
""+		"background 155,55,255\n"+
""+		"70 times ->\n"+
"\t"+		"rotate time/100000,1,time/100000\n"+
"\t"+		"box\n";

var webglzfightartDemo = ""+
""+		"// Explore the artifacts\n"+
""+		"// of your GPU!\n"+
""+		"// Go Z-fighting, go!\n"+
""+		"scale 5\n"+
""+		"rotate\n"+
""+		"fill red\n"+
""+		"box\n"+
""+		"rotate 0.000001\n"+
""+		"fill yellow\n"+
""+		"box";

var littleSpiralOfCubes = ""+
""+		"background orange\n"+
""+		"scale 0.1\n"+
""+		"10 times ->\n"+
"\t"+		"rotate 0,1,time/1000\n"+
"\t"+		"move 1,1,1\n"+
"\t"+		"box\n";

var tentacleDemo = ""+
""+		"background 155,255,155\n"+
""+		"scale 0.15\n"+
""+		"3 times ->\n"+
"\t"+		"rotate 0,1,1\n"+
"\t"+		"10 times ->\n"+
"\t\t"+		"rotate 0,1,time/1000\n"+
"\t\t"+		"scale 0.9\n"+
"\t\t"+		"move 1,1,1\n"+
"\t\t"+		"box\n";

var lampDemo = ""+
""+		"animationStyle motionBlur\n"+
""+		"simpleGradient red,yellow,color(255,0,255)\n"+
""+		"//animationStyle paintOver\n"+
""+		"scale 2\n"+
""+		"rotate time/4000, time/4000,  time/4000\n"+
""+		"90 times ->\n"+
"\t"+		"rotate time/200000, time/200000,  time/200000\n"+
"\t"+		"line\n"+
"\t"+		"move 0.5,0,0\n"+
"\t"+		"line\n"+
"\t"+		"move -0.5,0,0\n"+
"\t"+		"line\n"+
"\t"+		"line\n";

var trillionfeathersDemo = ""+
""+		"animationStyle paintOver\n"+
""+		"move 2,0,0\n"+
""+		"scale 2\n"+
""+		"rotate\n"+
""+		"20 times ->\n"+
"\t"+		"rotate\n"+
"\t"+		"move 0.25,0,0\n"+
"\t"+		"line\n"+
"\t"+		"move -0.5,0,0\n"+
"\t"+		"line";

var monsterblobDemo = ""+
""+		"ballDetail 6\n"+
""+		"animationStyle motionBlur\n"+
""+		"rotate time/5000\n"+
""+		"simpleGradient fuchsia,aqua,yellow\n"+
""+		"5 times ->\n"+
"\t"+		"rotate 0,1,time/5000\n"+
"\t"+		"move 0,0.1,0.1\n"+
"\t"+		"3 times ->\n"+
"\t\t"+			"rotate 0,0,1\n"+
"\t\t"+			"ball -1.01,0.01,1";

var industrialMusicDemo = ""+
""+		"bpm 350\n"+
""+		"addSound 'alienBeep'  ,'zzxz zzzz zzxz zzzz'\n"+
""+		"addSound 'beepC'  ,'zxzz zzzz xzzx xxxz'\n"+
""+		"addSound 'beepA'  ,'zzxz zzzz zzxz zzzz'\n"+
""+		"addSound 'lowFlash'  ,'zzxz zzzz zzzz zzzz'\n"+
""+		"addSound 'beepB'  ,'xzzx zzzz zxzz zxzz'\n"+
""+		"addSound 'voltage' ,'xzxz zxzz xzxx xzxx'\n"+
""+		"addSound 'tranceKick' ,'zxzx zzzx xzzz zzxx'\n";

var trySoundsDemo = ""+
""+		"bpm 350\n"+
""+		"// leave this one as base\n"+
""+		"addSound 'tranceKick' ,'zxzx zzzx xzzz zzxx'\n"+
""+		"\n"+
""+		"// uncomment the sounds you want to try\n"+
""+		"//addSound 'toc','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'highHatClosed','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'highHatOpen','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'toc2','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'toc3','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'toc4','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'snare','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'snare2','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'china','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'crash','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'crash2','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'crash3','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'ride','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'glass','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'glass1','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'glass2','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'glass3','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'thump','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'lowFlash','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'lowFlash2','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'tranceKick2','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'tranceKick','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'wosh','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'voltage','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'beepA','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'beepB','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'beepC','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'beepD','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'beep','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'hello','zzxz zzzz zzxz zzzz'\n"+
""+		"//addSound 'alienBeep','zzxz zzzz zzxz zzzz'\n";

var springysquaresDemo = ""+
""+		"animationStyle motionBlur\n"+
""+		"simpleGradient fuchsia,color(100,200,200),yellow\n"+
""+		"scale 0.3\n"+
""+		"3 times ->\n"+
"\t"+		"move 0,0,0.5\n"+
"\t"+		"5 times ->\n"+
"\t\t"+		"rotate time/2000\n"+
"\t\t"+	   "move 0.7,0,0\n"+
"\t\t"+		"rect";

var diceDemo = ""+
""+		"animationStyle motionBlur\n"+
""+		"simpleGradient color(255),moccasin,peachpuff\n"+
""+		"stroke 255,100,100,255\n"+
""+		"fill red,155\n"+
""+		"move -0.5,0,0\n"+
""+		"scale 0.3\n"+
""+		"3 times ->\n"+
"\t"+		"move 0,0,0.5\n"+
"\t"+		"1 times ->\n"+
"\t\t"+		"rotate time/1000\n"+
"\t\t"+		"move 2,0,0\n"+
"\t\t"+		"box";

var webglalmostvoronoiDemo = ""+
""+		"scale 10\n"+
""+		"2 times ->\n"+
"\t"+		"rotate 0,1,time/10000\n"+
"\t"+		"ball -1";

var webglshardsDemo = ""+
""+		"scale 10\n"+
""+		"fill 0\n"+
""+		"strokeSize 7\n"+
""+		"5 times ->\n"+
"\t"+		"rotate 0,1,time/20000\n"+
"\t"+		"ball \n"+
"\t"+		"rotate 0,1,1\n"+
"\t"+		"ball -1.01";

var webglpinkthreadDemo = ""+
""+		"scale 10.5\n"+
""+		"background black\n"+
""+		"stroke red\n"+
""+		"noFill\n"+
""+		"strokeSize 7\n"+
""+		"5 times ->\n"+
"\t"+		"rotate time/20000\n"+
"\t"+		"ball\n"+
"\t"+		"rotate 0,1,1\n"+
"\t"+		"ball";

var webglnuclearOctopusDemo = ""+
""+		"simpleGradient black,color(0,0,(time/5)%255),black\n"+
""+		"scale 0.2\n"+
""+		"move 5\n"+
""+		"animationStyle motionBlur\n"+
""+		"//animationStyle paintOver\n"+
""+		"stroke 255,0,0,120\n"+
""+		"fill time%255,0,0\n"+
""+		"pushMatrix\n"+
""+		"count = 0\n"+
""+		"3 times ->\n"+
"\t"+		"count++\n"+
"\t"+		"pushMatrix\n"+
"\t"+		"rotate count+3+time/1000,2+count + time/1000,4+count\n"+
"\t"+		"120 times ->\n"+
"\t\t"+		"scale 0.9\n"+
"\t\t"+		"move 1,1,0\n"+
"\t\t"+		"rotate time/100\n"+
"\t\t"+		"box\n"+
"\t"+		"popMatrix";

var introTutorial = ""+
""+		"// Lines beginning with two\n"+
""+		"// slashes (like these) are just comments.\n"+
""+		'// Everything else is run\n'+
""+		'// about 30 to 60 times per second\n'+
""+		'// in order to create an animation.\n'+
""+		"\n"+
""+		"// Click the link below to start the tutorial.\n"+
""+		"// (it might need multiple clicks, it's weird like that)\n"+
""+		"// next-tutorial:hello_world";

var helloworldTutorial = ""+
""+		"// type these three letters\n"+
""+		"// in one of these empty lines below:\n"+
""+		'// "b" and "o" and "x"\n'+
""+		"\n"+
""+		"\n"+
""+		"\n"+
""+		"// (you should then see a box facing you)\n"+
""+		"// click below for the next tutorial\n"+
""+		"// next-tutorial:some_notes";

var somenotesTutorial = ""+
""+		"// If this makes sense to you:\n"+
""+		"// the syntax is similar to Coffeescript\n"+
""+		'// and the commands are almost\n'+
""+		'// like Processing.\n'+
""+		"\n"+
""+		"// If this doesn't make sense to you\n"+
""+		"// don't worry.\n"+
""+		"// next-tutorial:rotate";

var rotateTutorial = ""+
""+		"// now that we have a box\n"+
""+		"// let's rotate it:\n"+
""+		'// type "rotate 1" in the\n'+
""+		'// line before the "box"\n'+
""+		"\n"+
""+		"\n"+
""+		"box\n"+
""+		"\n"+
""+		"// click for the next tutorial:\n"+
""+		"// next-tutorial:frame";

var frameTutorial = ""+
""+		"// make the box spin\n"+
""+		'// by replacing "1" with "frame"\n'+
""+		"\n"+
""+		"rotate 1\n"+
""+		"box\n"+
""+		"\n"+
""+		'// "frame" contains a number\n'+
""+		"// always incrementing as\n"+
""+		"// the screen is re-drawn.\n"+
""+		'// (use "frame/100" to slow it down)\n'+
""+		"// next-tutorial:time";

var timeTutorial = ""+
""+		'// "frame/100" has one problem:\n'+
""+		'// faster computers will make\n'+
""+		'// the cube spin too fast.\n'+
""+		'// Replace it with "time/2000".\n'+
""+		"\n"+
""+		"rotate frame/100\n"+
""+		"box\n"+
""+		"\n"+
""+		'// "time" counts the\n'+
""+		"// number of milliseconds since\n"+
""+		"// the program started, so it's\n"+
""+		"// independent of how fast\n"+
""+		"// the computer is at drawing.\n"+
""+		"// next-tutorial:move";

var moveTutorial = ""+
""+		"// you can move any object\n"+
""+		'// by using "move"\n'+
""+		"\n"+
""+		"box\n"+
""+		"move 1,1,0\n"+
""+		"box\n"+
""+		"\n"+
""+		'// try to use a rotate before \n'+
""+		"// the first box to see how the\n"+
""+		"// scene changes.\n"+
""+		"// next-tutorial:scale";

var scaleTutorial = ""+
""+		"// you can zoom in or out\n"+
""+		'// by using "scale"\n'+
""+		"\n"+
""+		"rotate 3\n"+
""+		"box\n"+
""+		"move 1\n"+
""+		"scale 2\n"+
""+		"box\n"+
""+		"\n"+
""+		'// try to use a rotate before \n'+
""+		"// the first box to see how the\n"+
""+		"// scene changes.\n"+
""+		"// next-tutorial:times";

var timesTutorial = ""+
""+		'// "times" (not to be confused with\n'+
""+		'// "time"!) can be used to\n'+
""+		'// repeat operations like so:\n'+
""+		"\n"+
""+		"rotate 1\n"+
""+		"3 times ->\n"+
"\t"+		"move 0.2,0.2,0.2\n"+
"\t"+		"box\n"+
""+		"\n"+
""+		'// note how the tabs indicate \n'+
""+		"// exactly the block of code\n"+
""+		"// to be repeated.\n"+
""+		"// next-tutorial:fill";

var fillTutorial = ""+
""+		'// "fill" changes the\n'+
""+		'// color of all the faces:\n'+
""+		"\n"+
""+		"fill 255,255,0\n"+
""+		"box\n"+
""+		"\n"+
""+		'// the three numbers indicate \n'+
""+		"// red green and blue values.\n"+
""+		"// You can also use color names such as indigo\n"+
""+		"// Try replacing the numbers with\n"+
""+		'// "angleColor"\n'+
""+		"// next-tutorial:stroke";

var strokeTutorial = ""+
""+		'// "stroke" changes all the\n'+
""+		'// edges:\n'+
""+		"\n"+
""+		"rotate 1\n"+
""+		"strokeSize 5\n"+
""+		"stroke 255,255,255\n"+
""+		"box\n"+
""+		"\n"+
""+		'// the three numbers are RGB\n'+
""+		"// but you can also use the color names\n"+
""+		'// or the special color "angleColor"\n'+
""+		'// Also you can use "strokeSize"\n'+
""+		'// to specify the thickness.\n'+
""+		"// next-tutorial:color_names";

var colornamesTutorial = ""+
""+		'// you can call color by name\n'+
""+		'// try to un-comment one line:\n'+
""+		"\n"+
""+		"//fill greenyellow\n"+
""+		"//fill indigo\n"+
""+		"//fill lemonchiffon // how about that!\n"+
""+		"rotate 1\n"+
""+		"box\n"+
""+		"\n"+
""+		'// more color names here:\n'+
""+		'// http://html-color-codes.info/color-names/\n'+
""+		'// (just use them in lower case)\n'+
""+		"// next-tutorial:lights";


var lightsTutorial = ""+
""+		'// "ambientLight" creates an\n'+
""+		'// ambient light so things have\n'+
""+		'// some sort of shading:\n'+
""+		"\n"+
""+		"ambientLight 0,255,255\n"+
""+		"rotate time/1000\n"+
""+		"box\n"+
""+		"\n"+
""+		'// you can turn that light on and \n'+
""+		"// off while you build the scene\n"+
""+		'// by using "lights" and "noLights"\n'+
""+		"// next-tutorial:background";

var backgroundTutorial = ""+
""+		'// "background" creates a\n'+
""+		'// solid background:\n'+
""+		"\n"+
""+		"background 0,0,255\n"+
""+		"rotate time/1000\n"+
""+		"box\n"+
""+		"\n"+
""+		"// next-tutorial:gradient";

var gradientTutorial = ""+
""+		'// even nicer, you can paint a\n'+
""+		'// background gradient:\n'+
""+		"\n"+
""+		"simpleGradient color(190,10,10),color(30,90,100),color(0)\n"+
""+		"rotate time/1000\n"+
""+		"box\n"+
""+		"\n"+
""+		"// next-tutorial:line";

var lineTutorial = ""+
""+		'// draw lines like this:\n'+
""+		"\n"+
""+		"20 times ->\n"+
"\t"+		"rotate time/9000\n"+
"\t"+		"line\n"+
""+		"\n"+
""+		"// next-tutorial:ball";

var ballTutorial = ""+
""+		'// draw balls like this:\n'+
""+		"\n"+
""+		"ballDetail 10\n"+
""+		"3 times ->\n"+
"\t"+		"move 0.2,0.2,0.2\n"+
"\t"+		"ball\n"+
""+		"\n"+
""+		'// ("ballDetail" is optional)\n'+
""+		"// next-tutorial:pushpopMatrix";

var pushpopMatrixTutorial = ""+
""+		'// pushMatrix creates a bookmark of\n'+
""+		'// the position, which you can\n'+
""+		'// return to later by using popMatrix.\n'+
""+		'// You can reset using "resetMatrix".\n'+
""+		"\n"+
""+		"rotate time/1000\n"+
""+		'pushMatrix // bookmark the position after the rotation\n'+
""+		"line\n"+
""+		"move 0.5,0,0\n"+
""+		"line\n"+
""+		"popMatrix // go back to the bookmarked position\n"+
""+		"move -0.5,0,0\n"+
""+		"line\n"+
""+		"resetMatrix // resets the position\n"+
""+		"line // not affected by initial rotation\n"+
""+		"// next-tutorial:animation_style";

var animationstyleTutorial = ""+
""+		'// try uncommenting either line\n'+
""+		'// with the animationStyle\n'+
""+		"\n"+
""+		"background 255\n"+
""+		"//animationStyle motionBlur\n"+
""+		"//animationStyle paintOver\n"+
""+		"rotate frame/10\n"+
""+		"box\n"+
""+		"\n"+
""+		"// next-tutorial:do_once";

var doonceTutorial = ""+
""+		'// delete either check mark below\n'+
""+		"\n"+
""+		"rotate time/1000\n"+
""+		"doOnce ->\n"+
"\t"+	   "background 255\n"+
"\t"+	   "fill 255,0,0\n"+
""+		"doOnce -> ball\n"+
""+		"box\n"+
""+		"\n"+
""+		'// ...the line or block of code\n'+
""+		'// are ran one time only, after that the\n'+
""+		'// check marks immediately re-appear\n'+
""+		'// P.S. keep hitting the delete button\n'+
""+		'// on that first check mark for seizures.\n'+
""+		"// next-tutorial:autocode";

var autocodeTutorial = ""+
""+		'// the Autocode button invents random\n'+
""+		'// variations for you.\n'+
""+		'\n'+
""+		'// You can interrupt the Autocoder at\n'+
""+		'// any time by pressing the button again,\n'+
""+		'// or you can press CTRL-Z\n'+
""+		'// (or CMD-Z on Macs) to undo (or re-do) some of\n'+
""+		'// the steps even WHILE the autocoder is running,\n'+
""+		'// if you see that things got\n'+
""+		'// boring down a particular path of changes.';

var autocodeOn = false;
var blinkingAutocoderTimeout;
var blinkingAutocoderStatus = false;

function blinkAutocodeIndicator() {
	blinkingAutocoderStatus = !blinkingAutocoderStatus;
	if (blinkingAutocoderStatus){
		$("#autocodeIndicatorContainer").css("background-color",'');
	}
	else {
		$("#autocodeIndicatorContainer").css("background-color",'#FF0000');
		mutate();
	}
}

function toggleAutocode() {
	autocodeOn = !autocodeOn;
	
	if (!autocodeOn) {
		$("#autocodeIndicator").html("Autocode: off");
		clearInterval(blinkingAutocoderTimeout);
		$("#autocodeIndicatorContainer").css("background-color",'');
	}
	else {
		$("#autocodeIndicator").html("Autocode: on");
		blinkingAutocoderTimeout = setInterval('blinkAutocodeIndicator();',500);
		$("#autocodeIndicatorContainer").css("background-color",'#FF0000');
		if (editor.getValue() === '' ||
			(
				(window.location.hash.indexOf("bookmark")!==-1) &&
				(window.location.hash.indexOf("autocodeTutorial")!==-1)
			)

		) loadDemoOrTutorial('cubesAndSpikes');
	}
}

function mutate() {
		var whichMutation = Math.floor(Math.random() * 5);
		if (whichMutation == 0)
		replaceAFloat();
		else if (whichMutation == 1)
		replaceAnInteger();
		else if (whichMutation == 2)
		replaceABoxWithABall();
		else if (whichMutation == 3)
		replaceABallWithABox();
		//else if (whichMutation == 4)
		//replacetimeWithAConstant();
		
}

function replaceAFloat() {
        var editorContent = editor.getValue();
		var rePattern = /([-+]?[0-9]*\.[0-9]+)/gi;

		var allMatches = editorContent.match(rePattern);
		if (allMatches === null) numberOfResults = 0;
		else numberOfResults = allMatches.length;
		whichOneToChange = Math.floor(Math.random() * numberOfResults) + 1;

		var countWhichOneToSwap = 0;
		editorContent = editorContent.replace(rePattern, function(match, text, urlId){
			countWhichOneToSwap++;
			if (countWhichOneToSwap === whichOneToChange){
				var whichOp = Math.floor(Math.random() * 12);
				if (whichOp == 0)
				return parseFloat(match)*2;
				else if (whichOp == 1)
				return parseFloat(match)/2;
				else if (whichOp == 2)
				return parseFloat(match)+1;
				else if (whichOp == 3)
				return parseFloat(match)-1;
				else if (whichOp == 4)
				return parseFloat(match)*5;
				else if (whichOp == 5)
				return parseFloat(match)/5;
				else if (whichOp == 6)
				return parseFloat(match)+0.1;
				else if (whichOp == 7)
				return parseFloat(match)-0.1;
				else if (whichOp == 8)
				return parseFloat(match)+0.5;
				else if (whichOp == 9)
				return parseFloat(match)-0.5;
				else if (whichOp == 10)
				return Math.floor(parseFloat(match));
				else if (whichOp == 11)
				return 'time/1000';
			}
				return match;
		});
		editor.setValue(editorContent);
}

function replaceABoxWithABall() {
        var editorContent = editor.getValue();
		var rePattern = /(box)/gi;

		var allMatches = editorContent.match(rePattern);
		if (allMatches === null) numberOfResults = 0;
		else numberOfResults = allMatches.length;
		whichOneToChange = Math.floor(Math.random() * numberOfResults) + 1;

		var countWhichOneToSwap = 0;
		editorContent = editorContent.replace(rePattern, function(match, text, urlId){
			countWhichOneToSwap++;
			if (countWhichOneToSwap === whichOneToChange){
				return "ball";
			}
				return match;
		});
		editor.setValue(editorContent);
}

function replaceTimeWithAConstant() {
        var editorContent = editor.getValue();
		var rePattern = /(time)/gi;

		var allMatches = editorContent.match(rePattern);
		if (allMatches === null) numberOfResults = 0;
		else numberOfResults = allMatches.length;
		whichOneToChange = Math.floor(Math.random() * numberOfResults) + 1;

		var countWhichOneToSwap = 0;
		editorContent = editorContent.replace(rePattern, function(match, text, urlId){
			countWhichOneToSwap++;
			if (countWhichOneToSwap === whichOneToChange){
				return ''+Math.floor(Math.random() * 20) + 1;
			}
				return match;
		});
		editor.setValue(editorContent);
}

function replaceABallWithABox() {
        var editorContent = editor.getValue();
		var rePattern = /(ball)/gi;

		var allMatches = editorContent.match(rePattern);
		if (allMatches === null) numberOfResults = 0;
		else numberOfResults = allMatches.length;
		whichOneToChange = Math.floor(Math.random() * numberOfResults) + 1;

		var countWhichOneToSwap = 0;
		editorContent = editorContent.replace(rePattern, function(match, text, urlId){
			countWhichOneToSwap++;
			if (countWhichOneToSwap === whichOneToChange){
				return "box";
			}
				return match;
		});
		editor.setValue(editorContent);
}

function replaceAnInteger() {
        var editorContent = editor.getValue();
		var rePattern = /([-+]?[0-9]+)/gi;

		var allMatches = editorContent.match(rePattern);
		if (allMatches === null) numberOfResults = 0;
		else numberOfResults = allMatches.length;
		whichOneToChange = Math.floor(Math.random() * numberOfResults) + 1;

		var countWhichOneToSwap = 0;
		editorContent = editorContent.replace(rePattern, function(match, text, urlId){
			countWhichOneToSwap++;
			if (countWhichOneToSwap === whichOneToChange){
				var whichOp = Math.floor(Math.random() * 7);
				if (whichOp == 0)
				return Math.floor(parseFloat(match)*2);
				else if (whichOp == 1)
				return Math.floor(parseFloat(match)/2);
				else if (whichOp == 2)
				return Math.floor(parseFloat(match)+1);
				else if (whichOp == 3)
				return Math.floor(parseFloat(match)-1);
				else if (whichOp == 4)
				return Math.floor(parseFloat(match)*5);
				else if (whichOp == 5)
				return Math.floor(parseFloat(match)/5);
				else if (whichOp == 6)
				return 'Math.floor(1+time/1000)';
			}
				return match;
		});
		editor.setValue(editorContent);

}

function triggerReset() {
	pickRandomDefaultGradient();
	if (autocodeOn) toggleAutocode();
	editor.setValue('');
	$("#resetButtonContainer").css("background-color",'#FF0000');
	setTimeout('$("#resetButtonContainer").css("background-color","");',200);
}

function loadDemoOrTutorial(whichDemo) {

	if (!Detector.webgl && !userWarnedAboutWebglExamples && whichDemo.indexOf('webgl') === 0) {
		userWarnedAboutWebglExamples = true;
		$('#exampleNeedsWebgl').modal();
		$('#simplemodal-container').height(200);
	}
	
	
	// set the demo as a hash state
	// so that ideally people can link directly to
	// a specific demo they like.
	// (in the document.ready function we check for
	// this hash value and load the correct demo)
	window.location.hash =  'bookmark='+whichDemo;

	if (fakeText) shrinkFakeText();
	undimEditor();
	
	doTheSpinThingy = false;
	
	var prependMessage = "";
	if (!Detector.webgl && whichDemo.indexOf('webgl') === 0) {
		prependMessage = ""+
		"// this drawing makes much more sense\n"+
		"// in a WebGL-enabled browser\n"+
		"\n";
	}

	switch(whichDemo) {
		case 'simpleCubeDemo':
			editor.setValue( prependMessage + simpleCubeDemo);
			break;
		case 'webgltwocubesDemo':
			editor.setValue( prependMessage + webgltwocubesDemo);
			break;
		case 'cubesAndSpikes':
			editor.setValue( prependMessage + cubesAndSpikes);
			break;
		case 'webglturbineDemo':
			editor.setValue( prependMessage + webglturbineDemo);
			break;
		case 'webglzfightartDemo':
			editor.setValue( prependMessage + webglzfightartDemo);
			break;
		case 'littleSpiralOfCubes':
			editor.setValue( prependMessage + littleSpiralOfCubes);
			break;
		case 'tentacleDemo':
			editor.setValue( prependMessage + tentacleDemo);
			break;
		case 'lampDemo':
			editor.setValue( prependMessage + lampDemo);
			break;
		case 'trillionfeathersDemo':
			editor.setValue( prependMessage + trillionfeathersDemo);
			break;
		case 'monsterblobDemo':
			editor.setValue( prependMessage + monsterblobDemo);
			break;
		case 'industrialMusicDemo':
			editor.setValue( prependMessage + industrialMusicDemo);
			break;
		case 'trySoundsDemo':
			editor.setValue( prependMessage + trySoundsDemo);
			break;
		case 'springysquaresDemo':
			editor.setValue( prependMessage + springysquaresDemo);
			break;
		case 'diceDemo':
			editor.setValue( prependMessage + diceDemo);
			break;
		case 'webglalmostvoronoiDemo':
			editor.setValue( prependMessage + webglalmostvoronoiDemo);
			break;
		case 'webglshardsDemo':
			editor.setValue( prependMessage + webglshardsDemo);
			break;
		case 'webglpinkthreadDemo':
			editor.setValue( prependMessage + webglpinkthreadDemo);
			break;
		case 'webglnuclearOctopusDemo':
			editor.setValue( prependMessage + webglnuclearOctopusDemo);
			break;
		case 'introTutorial':
			editor.setValue( prependMessage + introTutorial);
			break;
		case 'helloworldTutorial':
			editor.setValue( prependMessage + helloworldTutorial);
			break;
		case 'somenotesTutorial':
			editor.setValue( prependMessage + somenotesTutorial);
			break;
		case 'rotateTutorial':
			editor.setValue( prependMessage + rotateTutorial);
			break;
		case 'frameTutorial':
			editor.setValue( prependMessage + frameTutorial);
			break;
		case 'timeTutorial':
			editor.setValue( prependMessage + timeTutorial);
			break;
		case 'moveTutorial':
			editor.setValue( prependMessage + moveTutorial);
			break;
		case 'scaleTutorial':
			editor.setValue( prependMessage + scaleTutorial);
			break;
		case 'timesTutorial':
			editor.setValue( prependMessage + timesTutorial);
			break;
		case 'fillTutorial':
			editor.setValue( prependMessage + fillTutorial);
			break;
		case 'strokeTutorial':
			editor.setValue( prependMessage + strokeTutorial);
			break;
		case 'colornamesTutorial':
			editor.setValue( prependMessage + colornamesTutorial);
			break;
		case 'lightsTutorial':
			editor.setValue( prependMessage + lightsTutorial);
			break;
		case 'backgroundTutorial':
			editor.setValue( prependMessage + backgroundTutorial);
			break;
		case 'gradientTutorial':
			editor.setValue( prependMessage + gradientTutorial);
			break;
		case 'lineTutorial':
			editor.setValue( prependMessage + lineTutorial);
			break;
		case 'ballTutorial':
			editor.setValue( prependMessage + ballTutorial);
			break;
		case 'pushpopMatrixTutorial':
			editor.setValue( prependMessage + pushpopMatrixTutorial);
			break;
		case 'animationstyleTutorial':
			editor.setValue( prependMessage + animationstyleTutorial);
			break;
		case 'doonceTutorial':
			editor.setValue( prependMessage + doonceTutorial);
			break;
		case 'autocodeTutorial':
			editor.setValue( prependMessage + autocodeTutorial);
			break;

	}
	
	// setting the value of the editor triggers the
	// codeMirror onChange callback, and that runs
	// the demo.
}

	</script>
	
	<script>
  var changesHappened = false;
  
  // way to add links taken form here:
  // http://groups.google.com/group/codemirror/browse_thread/thread/a96bb56548815163/87a3869e2cfd0a37?lnk=gst&q=links#87a3869e2cfd0a37
  CodeMirror.defineMode("links", function(config, parserConfig) { 
    return { 
    token: function(stream, state) {
      if (stream.match(/\/\/\s*(next-tutorial:([^\s]+))\b/)) 
      { 
           return "link"; 
      } 
            stream.skipToEnd(); 
    
    } 
  }; 
}); 


  var cursorActivity = true;
  var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
    lineNumbers: false,
        tabSize: 2,
        indentUnit: 2,
        indentWithTabs: true,
        lineWrapping: true,
        // We want the code editor to always have focus
        // since there is nothing else to type into.
        // One of those little wonders: you have to pause a little
        // before giving the editor focus, otherwise for some reason
        // the focus is not regained. Go figure.
        onBlur: (function(){ setTimeout('editor.focus()',30) }),
        onChange: (function(){registerCode();}),
        mode: "links",
        onCursorActivity: (function(){undimIfCursorActivity();}),
        //onScroll: (function(){alert('scroll')})
  });

  
  $('#formCode').delegate(".cm-link", "click", function(event) {
  //alert('clicked');
  var url;
  url = $(event.target).text();
  url = url.replace(/\/\/\s*next-tutorial\:/,"");
  url = url.replace("_","");
  //alert(""+url);
  loadDemoOrTutorial(url+"Tutorial");
});

  editor.setOption("theme", 'night');
  function selectTheme(node) {
    var theme = node.options[node.selectedIndex].innerHTML;
    editor.setOption("theme", theme);
  }

// resizing the text area is necessary otherwise
// as the user types to the end of it, instead of just scrolling
// the content leaving all the other parts of the page where
// they are, it expands and it pushes down
// the view of the page, meaning that the canvas goes up and
// the menu disappears
// so we have to resize it at launch and also every time the window
// is resized.

function adjustCodeMirrorHeight() {
	//alert("code height:" + $('#code').height());
	//alert("window height:" + window.innerHeight);
	//alert("code height:" + $('.CodeMirror-scroll').css('height'));
	//alert("menu height:" + $('#theMenu').height());
	$('.CodeMirror-scroll').css('height',window.innerHeight - $('#theMenu').height()); 
}

var fakeCursorInterval;

function fakeCursorBlinking() 
{
  $("#fakeStartingBlinkingCursor").animate(
  {
    opacity: 0.2
  }, "fast", "swing").animate(
  {
    opacity: 1
  }, "fast", "swing");
}

function undimIfCursorActivity(){
	if (fakeText || editor.getValue() === '') return;
	//console.log('cursor activity! opacity: ' + $("#formCode").css('opacity'));
	cursorActivity = true;
	undimEditor();
}

function undimEditor(){
	if (fakeText || editor.getValue() === '') $("#formCode").css('opacity',0);
	if ($("#formCode").css('opacity') < 0.99) {
		//console.log('undimming the editor');
		$("#formCode").animate(
		  {
			opacity: 1
		  }, "fast");
	}
}

function dimEditor(){
		if ($("#formCode").css('opacity') > 0.200001) {
			//console.log('starting fadeout animation');
			$("#formCode").animate(
			  {
				opacity: 0.2
			  }, "slow");
		  }
}

function dimIfNoCursorActivity(){
	if (fakeText || editor.getValue() === '') return;
	if (cursorActivity) {
		//console.log('marking cursor act = false and check again in a second');
		cursorActivity = false;
		return;
	}
	else {
		//console.log('no activity in the last second and opacity: ' + $("#formCode").css('opacity') );
		dimEditor();

	}
}

var closeAndCheckAudio = function(){
		//$('#noWebGLMessage').close();
		$.modal.close();
		setTimeout('checkAudio();',500);
}

var checkAudio = function(){
	if (!buzz.isSupported()) {
	//if (true) {
		$('#noAudioMessage').modal();
		$('#simplemodal-container').height(200);
	}
}

var loadAndTestAllTheSounds = function() {
	//console.log("loading and testing all sounds");
	for (var cycleSoundDefs = 0; cycleSoundDefs < numberOfSounds; cycleSoundDefs++){
	
		if (buzz.isMP3Supported()) soundDef[cycleSoundDefs].soundFile = soundDef[cycleSoundDefs].soundFile+".mp3";
		else if (buzz.isOGGSupported()) soundDef[cycleSoundDefs].soundFile = soundDef[cycleSoundDefs].soundFile+".ogg";
		else {break}
	
		soundBank[soundDef[cycleSoundDefs].soundName] = [];
		soundFiles[soundDef[cycleSoundDefs].soundName] = soundDef[cycleSoundDefs].soundFile;
		
		// Chrome can deal with dynamic loading
		// of many files but doesn't like loading too many audio objects
		// so fast - it crashes.
		// At the opposite end, Safari doesn't like loading sound dynamically
		// and instead works fine by loading sound all at the beginning.
		if (navigator.userAgent.toLowerCase().indexOf('chrome') === -1 && !(/MSIE (\d+\.\d+);/.test(navigator.userAgent)) ) {
			for (var preloadSounds = 0; preloadSounds < CHANNELSPERSOUND; preloadSounds++){
				// if you load and play all the channels of all the sounds all together
				// the browser freezes, and the OS doesn't feel too well either
				// so better stagger the checks in time.
				setTimeout("checkSound("+cycleSoundDefs+");", 200* cycleSoundDefs);
			}
		}
	
	} // end of the for loop

	if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1 || (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) ) {
		startEnvironment();
	}
}

var checkSound = function(cycleSoundDefs){
		var newSound = new buzz.sound(soundDef[cycleSoundDefs].soundFile);
		//console.log("loading sound "+ soundDef[cycleSoundDefs].soundFile);
		newSound.mute()
		newSound.load();
		newSound.bind("ended", function(e) {
			this.unbind("ended");
			this.unmute();
			endedFirstPlay++;
			if (endedFirstPlay%10 === 0) $('#loading').append('/');
			//console.log("tested "+endedFirstPlay+" sounds");
			if (endedFirstPlay === numberOfSounds * CHANNELSPERSOUND) {
				//console.log("tested all sounds");
				startEnvironment();
			}
		});
		newSound.play();
		soundBank[soundDef[cycleSoundDefs].soundName].push(newSound);
}
	
$(document).ready(function(){
	//console.log("document ready");
	if (!isCanvasSupported) {
		$('#noCanvasMessage').modal({onClose: function(){$('#loading').text('sorry :-(');$.modal.close();}});
		$('#simplemodal-container').height(200);
		return;
	}

	loadAndTestAllTheSounds();
});

startEnvironment = function(){
	pickRandomDefaultGradient();
		
	//console.log("startEnvironment");
	if( !init() )	animate();

	if (!Detector.webgl) {
		//$('#noWebGLMessage').modal()
		$('#noWebGLMessage').modal({onClose: closeAndCheckAudio});
		$('#simplemodal-container').height(200);
	}
	
	//alert('resizing canvas');
	var canvas = document.getElementById('backGroundCanvas');
	
	if (fullScreenifyBackground) {
		fullscreenify(canvas);
	}
	resetGradientStack();
	simpleGradientUpdateIfChanged();
		

	$('#startingCourtainScreen').fadeOut();
	$("#formCode").css('opacity',0);

	editor.focus();
	adjustCodeMirrorHeight();
	
	// check if the url points to a particular demo,
	// in which case we load the demo directly.
	// otherwise we do as usual.
	if (window.location.hash.indexOf("bookmark")!==-1){
		var demoToLoad = window.location.hash.substring("bookmark".length + 2);
		//setTimeout ( "loadDemoOrTutorial('"+demoToLoad+"');",500);
		loadDemoOrTutorial(demoToLoad);
	}
	fakeCursorInterval = setInterval ( "fakeCursorBlinking()", 800 );
	setInterval ( "dimIfNoCursorActivity()", 2000 );
	
}


///////////////////////////////////////////////

function fullscreenify(canvas) {
    var style = canvas.getAttribute('style') || '';
    //alert('style: ' +  style);
    
    window.addEventListener('resize', function () {	adjustCodeMirrorHeight(); resize(canvas);}, false);

    resize(canvas);

    function resize(canvas) {
        var scale = {x: 1, y: 1};
        scale.x = (window.innerWidth + 40) / canvas.width;
        scale.y = (window.innerHeight + 40) / canvas.height;
        
        scale = scale.x + ', ' + scale.y;
        
        // this code below is if one wants to keep the aspect ratio
        // but I mean one doesn't necessarily resize the window
        // keeping the same aspect ratio.
        /*
        if (scale.x < 1 || scale.y < 1) {
            scale = '1, 1';
        } else if (scale.x < scale.y) {
            scale = scale.x + ', ' + scale.x;
        } else {
            scale = scale.y + ', ' + scale.y;
        }
        */
        
        canvas.setAttribute('style', style + ' ' + '-ms-transform-origin: left top; -webkit-transform-origin: left top; -moz-transform-origin: left top; -o-transform-origin: left top; transform-origin: left top; -ms-transform: scale(' + scale + '); -webkit-transform: scale3d(' + scale + ', 1); -moz-transform: scale(' + scale + '); -o-transform: scale(' + scale + '); transform: scale(' + scale + ');');
		
		// TODO In theory we want to re-draw the background because the
		// aspect ration might have changed.
		// But for the time being we only have vertical
		// gradients so that's not going to be a problem.

    }
}

</script>




<script type="text/javascript" src="./sound/buzz.js"></script>
<script>
var totalCreatedSoundObjects = 0;
var soundSystemIsMangled = false;
var CHANNELSPERSOUND = 6;
var soundDef = [];
var soundDefCounter = 0;
// first value here below of soundDefCounter is zero.
soundDef[soundDefCounter++] = {soundName: 'toc', soundFile: './sound/audioFiles/AMB_BD_1'};
soundDef[soundDefCounter++] = {soundName: 'highHatClosed', soundFile: './sound/audioFiles/AMB_HHCL'};
soundDef[soundDefCounter++] = {soundName: 'highHatOpen', soundFile: './sound/audioFiles/AMB_HHOP'};
soundDef[soundDefCounter++] = {soundName: 'toc2', soundFile: './sound/audioFiles/AMB_HTM'};
soundDef[soundDefCounter++] = {soundName: 'toc3', soundFile: './sound/audioFiles/AMB_LTM2'};
soundDef[soundDefCounter++] = {soundName: 'toc4', soundFile: './sound/audioFiles/AMB_RIM1'};
soundDef[soundDefCounter++] = {soundName: 'snare', soundFile: './sound/audioFiles/AMB_SN13'};
soundDef[soundDefCounter++] = {soundName: 'snare2', soundFile: './sound/audioFiles/AMB_SN_5'};
soundDef[soundDefCounter++] = {soundName: 'china', soundFile: './sound/audioFiles/CHINA_1'};
soundDef[soundDefCounter++] = {soundName: 'crash', soundFile: './sound/audioFiles/CRASH_1'};
soundDef[soundDefCounter++] = {soundName: 'crash2', soundFile: './sound/audioFiles/CRASH_5'};
soundDef[soundDefCounter++] = {soundName: 'crash3', soundFile: './sound/audioFiles/CRASH_6'};
soundDef[soundDefCounter++] = {soundName: 'ride', soundFile: './sound/audioFiles/RIDE_1'};

soundDef[soundDefCounter++] = {soundName: 'glass', soundFile: './sound/audioFiles/glass2'};
soundDef[soundDefCounter++] = {soundName: 'glass1', soundFile: './sound/audioFiles/glass3'};
soundDef[soundDefCounter++] = {soundName: 'glass2', soundFile: './sound/audioFiles/glass4'};
soundDef[soundDefCounter++] = {soundName: 'glass3', soundFile: './sound/audioFiles/glass5'};

soundDef[soundDefCounter++] = {soundName: 'thump', soundFile: './sound/audioFiles/8938__patchen__piano-hits-hand-03v2'};
soundDef[soundDefCounter++] = {soundName: 'lowFlash', soundFile: './sound/audioFiles/9569__thanvannispen__industrial-low-flash04'};
soundDef[soundDefCounter++] = {soundName: 'lowFlash2', soundFile: './sound/audioFiles/9570__thanvannispen__industrial-low-flash07'};
soundDef[soundDefCounter++] = {soundName: 'tranceKick2', soundFile: './sound/audioFiles/24004__laya__dance-kick3'};
soundDef[soundDefCounter++] = {soundName: 'tranceKick', soundFile: './sound/audioFiles/33325__laya__trance-kick01'};
soundDef[soundDefCounter++] = {soundName: 'wosh', soundFile: './sound/audioFiles/33960__krlox__pudricion-4'};
soundDef[soundDefCounter++] = {soundName: 'voltage', soundFile: './sound/audioFiles/49255__keinzweiter__bonobob-funk'};
soundDef[soundDefCounter++] = {soundName: 'beepA', soundFile: './sound/audioFiles/100708__steveygos93__bleep_a'};
soundDef[soundDefCounter++] = {soundName: 'beepB', soundFile: './sound/audioFiles/100708__steveygos93__bleep_b'};
soundDef[soundDefCounter++] = {soundName: 'beepC', soundFile: './sound/audioFiles/100708__steveygos93__bleep_c'};
soundDef[soundDefCounter++] = {soundName: 'beepD', soundFile: './sound/audioFiles/100708__steveygos93__bleep_d'};
soundDef[soundDefCounter++] = {soundName: 'beep', soundFile: './sound/audioFiles/116508_Beep'};
soundDef[soundDefCounter++] = {soundName: 'hello', soundFile: './sound/audioFiles/116508_Hello'};
soundDef[soundDefCounter++] = {soundName: 'alienBeep', soundFile: './sound/audioFiles/132389__blackie666__alienbleep'};

numberOfSounds = soundDefCounter;

var soundBank = {};
var soundFiles = {};
var endedFirstPlay = 0;

</script>


</body>
</html>