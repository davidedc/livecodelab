<!doctype html>
<html>
	<head>
		<title>Livecodelab</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
			
		<script src="vendor/three.js/Three.js"></script>
		<script src="vendor/three.js/Detector.js"></script>
		<script src="vendor/three.js/Stats.js"></script>

		<script src="vendor/threex/THREEx.WindowResize.js"></script>
		<script type="text/javascript" src="coffee-script.js"></script>

		<script src="vendor/three.js/ShaderExtras.js"></script>
		<script src="vendor/three.js/postprocessing/EffectComposer.js"></script>
		<script src="vendor/three.js/postprocessing/RenderPass.js"></script>
		<script src="vendor/three.js/postprocessing/ShaderPass.js"></script>
		<!--
			 surprisingly MaskPass.js is needed even though masks are not
		     explicitely used
		-->
		<script src="vendor/three.js/postprocessing/MaskPass.js"></script>
		<script src="vendor/three.js/postprocessing/SavePass.js"></script>


		<link  href="css/main.css" rel="stylesheet"/>
		<link rel="stylesheet" href="codemirror.css">
		<script src="codemirror.js"></script>
		<link rel="stylesheet" href="night.css">
		<script src="coffeescriptModified.js"></script>
		<script src="jquery.min.js"></script>

		<style type="text/css">
		  .CodeMirror {border: none; }
		</style>

			<style type="text/css">
					a:hover {cursor: default;}
					.dd_menu {background:#323232; border-bottom: 1px; border-bottom-color: white; border-bottom-style: dotted; padding:0px; margin:0; list-style-type:none; height:30px;}
					.dd_menu li {float:left; height:30px; border-right: solid 1px white; border-right-style: dotted;}
					.dd_menu li a {padding:9px 20px; display:block; color:#fff; text-decoration:none; font:12px arial, verdana, sans-serif; font-weight: bold; }
					.dd_menu li:hover a {color:black;}
					
					.dd_menu ul { position:absolute; left:-9999px; top:-9999px; list-style-type:none;}
					.dd_menu li:hover {position:relative; background:white;}
					.dd_menu li:hover ul {left:0px; top:30px; background:#323232; padding:3px; border:0px solid white; width:160px;}
					.dd_menu li:hover ul li {height:18px; border:none; }
					.dd_menu li:hover ul li a {height:18px; padding:0px; display:block; font-size:11px; width:158px; line-height:18px; text-indent:15px; color:white; background-color:#323232; text-decoration:none;  border-top: 1px; border-top-color: #111111; border-top-style: dotted;}
					.dd_menu li:hover ul li a:hover {height:18px; background:silver; color:#000; border:solid 1px #444; }
					
					#dangerSignText {color:#323232; text-decoration:none;}
					#dangerSign:hover {background:#323232;}

					#errorMessageText {text-decoration:none;}
					#errorMessage:hover {background:#323232;}
					
					.verticalMiddleOfScreen        
						{
						color: white;
						background-color: transparent;
						text-align: center;
						position: absolute;
						top: 50%;
						left: 0px;
						width: 100%;
						height: 1px;
						overflow: visible;
						visibility: visible;
						display: block
						}
					
					.fakeAnimationContent    
						{
						font-family: Verdana, Geneva, Arial, sans-serif;
						background-color: transparent;
						margin-left: -1.5em;
						position: absolute;
						top: -1.1em;
						left: 50%;
						width: 3em;
						height: 2em;
						padding-top: 0px;
						visibility: visible
						}
    
			</style>
		<!-- end of second drop-down menu -->

		<!-- start simple modal -->
			<!-- Page styles -->
			<link type='text/css' href='simpleModal/css/demo.css' rel='stylesheet' media='screen' />			
			<!-- Contact Form CSS files -->
			<link type='text/css' href='simpleModal/css/basic.css' rel='stylesheet' media='screen' />
			<!-- Scripts -->
			<script type='text/javascript' src='simpleModal/js/jquery.js'></script>
			<script type='text/javascript' src='simpleModal/js/jquery.simplemodal.js'></script>
			<script type='text/javascript' src='simpleModal/js/basic.js'></script>
		<!-- end simple modal -->

	</head>
<body>

<div class="verticalMiddleOfScreen" id="toMove" style="font-size:30em;">
    <div class="fakeAnimationContent" >
        <p id="caption"></p>
    </div>
</div>
<div class="verticalMiddleOfScreen" id="justForFakeCursor" style="font-size:30em;">
    <div class="fakeAnimationContent" >
		<p id="fakeStartingBlinkingCursor">|</p>
    </div>
</div>

		<!-- preload the images -->
		<div style='display:none'>
			<img src='simpleModal/img/basic/x.png' alt='' />
		</div>

		<div id='startingCourtainScreen' style='width:100%; height:100%; background-color:white; position: absolute;  z-index:4; top: 0px; left: 0px;'>
		</div>


		<!-- modal content -->
		<div id="basic-modal-content">
			<h3>What&apos;s this?</h3>
			<p>This is a livecoding environment: code you type is immediately executed for you.<br><br>Try one of the examples from the "Examples".
			</div>

<div id="theMenu" style="position: absolute;  z-index:3; top: 0px; left: 0px; width:100%">

<ul class='dd_menu' >

	<li><a href="javascript:void(0)" style="text-decoration:none; color:red;">LIVECODELAB</a>
		<ul>
			<li><a href="javascript:void(0)" onclick="$('#basic-modal-content').modal();">What&apos;s this?</a></li>
		</ul>
	</li>

	<li><a href="javascript:void(0)" style="text-decoration:none;">Examples</a>
		<ul>
		
			<li><a href="javascript:void(0)" onclick="loadExample('simpleCubeExample');">Simple cube</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('twocubesExample');">Two cubes</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('cubesAndSpikes');">Cubes and spikes</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('turbineExample');">Turbine</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('yellowBackgroundExample');">Yellow background</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('littleSpiralOfCubes');">Little spiral</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('tentacleExample');">Tentacle</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('industrialMusicExample');">Industrial music</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('doOnceExample');">doOnce</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('planesExample');">Planes</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('matrixesExample');">Matrixes</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('diceExample');">Dice</a></li>
			<li><a href="javascript:void(0)" onclick="loadExample('nuclearOctopusExample');">Nuclear octopus</a></li>
		</ul>
	</li>
	<li id="dangerSign" style="border-right:none;"><a href="javascript:void(0)" id="dangerSignText" style="font-size:2em;margin-top:-0.5em;">&#9888;</a>
	</li>
	<li id="errorMessage" style="border-right:none;"><a href="javascript:void(0)" id="errorMessageText" ></a>
	</li>

</ul>
</div>





<div name="miao" id="miao" style="position: absolute;  top: 30px; left: 0px; width: 100%; font-size: 3em;">

<canvas id="backGroundCanvas" style="position: absolute; z-index:-3; top: 0px; left: 0px;" width="100" height="100"></canvas> 
<canvas id="finalRenderWithSceneAndBlendCanvas" style="position: absolute; z-index:-2; top: 0px; left: 0px;" width="100" height="100"></canvas> 



		<form id="formCode" autocapitalize="off" autocorrect="off" wrap="off"><textarea id="code" name="code" style="z-index:1;" autocapitalize="off" autocorrect="off" wrap="off" ></textarea></form>

      </div>

	<!-- three.js container -->
    	<div id="container" style="position: absolute; z-index:-1; top: 0px; left: 0px;"></div>


	<script type="text/javascript">

		var stats, scene, renderer;
		var camera;
		
		// creating a geometry is expensive
		// so we need to create ONE cube of dimensions 1,1,1
		// if we need a cube of different size, then we need to
		// scale it. Note that the scale for the specific cube shouldn't
		// influence the stack, so we need to create a scale node,
		// and then go up a node.
		var isWebGLUsed = false;
		var normalMaterial = new THREE.MeshNormalMaterial();
		
		var linesPool = [];
		var rectanglesPool = [];
		var boxesPool = [];
		var usedLines = 0;
		var usedRectangles = 0;
		var usedBoxes = 0;
		var cubeGeometry = new THREE.CubeGeometry(1,1,1);
		var planeGeometry = new THREE.PlaneGeometry(1,1);
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push(new THREE.Vertex(new THREE.Vector3(0, -0.5, 0)));
		lineGeometry.vertices.push(new THREE.Vertex(new THREE.Vector3(0, 0.5, 0)));
		
		// loads identity matrix
		var worldMatrix = new THREE.Matrix4();
		
		var forceCanvasRenderer = false;
		var backgroundScene;
		var backgroundSceneContext;
		var sceneRenderingCanvas;
		var sceneRenderingCanvasContext;
		var previousRenderForBlending;
		var previousRenderForBlendingContext;
		var finalRenderWithSceneAndBlend;
		var finalRenderWithSceneAndBlendContext;
		var useRequestAnimationFrame = true;
		// if you put to -1 then it means that
		// requestAnimationFrame will try to go as fast as it
		// can.
		var wantedFramesPerSecond = -1;
		var backGroundFraction = 15;
		var scaledBackgroundWidth;
		var scaledBackgroundHeight;
		var repaintBackroundEveryFrame = true;
		var fullScreenifyBackground = true;
		var animationModeValue = 0;
		var previousAnimationModeValue = 0;
		var currentGradientStackValue = '';
		var previousGradientStackValue = 0;
		var blendAmount = 0;
		var normal = 0;
		var retain = 1;
		var motionBlur = 2;
		
		var soundLoops = [];
		soundLoops.soundIDs = [];
		soundLoops.beatStrings = [];
		
		var programHasBasicError = false;
		var reasonOfBasicError = "";
		var consecutiveFramesWithoutRunTimeError = 0;
		var out;
		var lastStableProgram;

// Functions taken from processing.js

        
/**
   * NOTE: in releases we replace symbolic Constants.* names with their values.
   * Using Constants.* in code below is fine.  See tools/rewrite-pconstants.js.
   */
  var Constants = {
    // Color modes
    RGB:   1,
    ARGB:  2,
    HSB:   3,
    ALPHA: 4,
    CMYK:  5,

    // Blend modes
    REPLACE:    0,
    BLEND:      1 << 0,
    ADD:        1 << 1,
    SUBTRACT:   1 << 2,
    LIGHTEST:   1 << 3,
    DARKEST:    1 << 4,
    DIFFERENCE: 1 << 5,
    EXCLUSION:  1 << 6,
    MULTIPLY:   1 << 7,
    SCREEN:     1 << 8,
    OVERLAY:    1 << 9,
    HARD_LIGHT: 1 << 10,
    SOFT_LIGHT: 1 << 11,
    DODGE:      1 << 12,
    BURN:       1 << 13,

    // Color component bit masks
    ALPHA_MASK: 0xff000000,
    RED_MASK:   0x00ff0000,
    GREEN_MASK: 0x0000ff00,
    BLUE_MASK:  0x000000ff,

  };

var doFill = true,
        fillStyle = [1.0, 1.0, 1.0, 1.0],
        isFillDirty = true,
        doStroke = true,
        strokeStyle = [0.0, 0.0, 0.0, 1.0],
        isStrokeDirty = true,
        lineWidth = 1,
        colorModeA = 255,
        colorModeX = 255,
        colorModeY = 255,
        colorModeZ = 255,
        curColorMode = Constants.RGB;

/**
    * Determines the largest value in a sequence of numbers.
    *
    * @param {int|float} value1         int or float
    * @param {int|float} value2         int or float
    * @param {int|float} value3         int or float
    * @param {int|float} array          int or float array
    *
    * @returns {int|float}
    *
    * @see min
    */
    max = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[1] : arguments[0];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used
      if (! ("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var max = numbers[0],
        count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (max < numbers[i]) {
          max = numbers[i];
        }
      }
      return max;
    };

    /**
    * Determines the smallest value in a sequence of numbers.
    *
    * @param {int|float} value1         int or float
    * @param {int|float} value2         int or float
    * @param {int|float} value3         int or float
    * @param {int|float} array          int or float array
    *
    * @returns {int|float}
    *
    * @see max
    */
    min = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[0] : arguments[1];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used
      if (! ("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var min = numbers[0],
        count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (min > numbers[i]) {
          min = numbers[i];
        }
      }
      return min;
    };
    
function color$4(aValue1, aValue2, aValue3, aValue4) {
      var r, g, b, a;

      if (curColorMode === Constants.HSB) {
        var rgb = color.toRGB(aValue1, aValue2, aValue3);
        r = rgb[0];
        g = rgb[1];
        b = rgb[2];
      } else {
        r = Math.round(255 * (aValue1 / colorModeX));
        g = Math.round(255 * (aValue2 / colorModeY));
        b = Math.round(255 * (aValue3 / colorModeZ));
      }

      a = Math.round(255 * (aValue4 / colorModeA));

      // Limit values less than 0 and greater than 255
      r = (r < 0) ? 0 : r;
      g = (g < 0) ? 0 : g;
      b = (b < 0) ? 0 : b;
      a = (a < 0) ? 0 : a;
      r = (r > 255) ? 255 : r;
      g = (g > 255) ? 255 : g;
      b = (b > 255) ? 255 : b;
      a = (a > 255) ? 255 : a;

      // Create color int
      return (a << 24) & Constants.ALPHA_MASK | (r << 16) & Constants.RED_MASK | (g << 8) & Constants.GREEN_MASK | b & Constants.BLUE_MASK;
    }

    function color$2(aValue1, aValue2) {
      var a;

      // Color int and alpha
      if (aValue1 & Constants.ALPHA_MASK) {
        a = Math.round(255 * (aValue2 / colorModeA));
        // Limit values less than 0 and greater than 255
        a = (a > 255) ? 255 : a;
        a = (a < 0) ? 0 : a;

        return aValue1 - (aValue1 & Constants.ALPHA_MASK) + ((a << 24) & Constants.ALPHA_MASK);
      }
      // Grayscale and alpha
      if (curColorMode === Constants.RGB) {
        return color$4(aValue1, aValue1, aValue1, aValue2);
      }
      if (curColorMode === Constants.HSB) {
        return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, aValue2);
      }
    }

    function color$1(aValue1) {
      // Grayscale
      if (aValue1 <= colorModeX && aValue1 >= 0) {
          if (curColorMode === Constants.RGB) {
            return color$4(aValue1, aValue1, aValue1, colorModeA);
          }
          if (curColorMode === Constants.HSB) {
            return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, colorModeA);
          }
      }
      // Color int
      if (aValue1) {
        if (aValue1 > 2147483647) {
          // Java Overflow
          aValue1 -= 4294967296;
        }
        return aValue1;
      }
    }

    /**
    * Creates colors for storing in variables of the color datatype. The parameters are
    * interpreted as RGB or HSB values depending on the current colorMode(). The default
    * mode is RGB values from 0 to 255 and therefore, the function call color(255, 204, 0)
    * will return a bright yellow color. More about how colors are stored can be found in
    * the reference for the color datatype.
    *
    * @param {int|float} aValue1        red or hue or grey values relative to the current color range.
    * Also can be color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)
    * @param {int|float} aValue2        green or saturation values relative to the current color range
    * @param {int|float} aValue3        blue or brightness values relative to the current color range
    * @param {int|float} aValue4        relative to current color range. Represents alpha
    *
    * @returns {color} the color
    *
    * @see colorMode
    */
    var color = function(aValue1, aValue2, aValue3, aValue4) {
    //alert("color");

      // 4 arguments: (R, G, B, A) or (H, S, B, A)
      if (aValue1 !== undefined && aValue2 !== undefined && aValue3 !== undefined && aValue4 !== undefined) {
        return color$4(aValue1, aValue2, aValue3, aValue4);
      }

      // 3 arguments: (R, G, B) or (H, S, B)
      if (aValue1 !== undefined && aValue2 !== undefined && aValue3 !== undefined) {
        return color$4(aValue1, aValue2, aValue3, colorModeA);
      }

      // 2 arguments: (Color, A) or (Grayscale, A)
      if (aValue1 !== undefined && aValue2 !== undefined) {
        return color$2(aValue1, aValue2);
      }

      // 1 argument: (Grayscale) or (Color)
      if (typeof aValue1 === "number") {
        return color$1(aValue1);
      }

      // Default
      return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);
    };

    // Ease of use function to extract the colour bits into a string
    color.toString = function(colorInt) {
      return "rgba(" + ((colorInt & Constants.RED_MASK) >>> 16) + "," + ((colorInt & Constants.GREEN_MASK) >>> 8) +
             "," + ((colorInt & Constants.BLUE_MASK)) + "," + ((colorInt & Constants.ALPHA_MASK) >>> 24) / 255 + ")";
    };

    // Easy of use function to pack rgba values into a single bit-shifted color int.
    color.toInt = function(r, g, b, a) {
      return (a << 24) & Constants.ALPHA_MASK | (r << 16) & Constants.RED_MASK | (g << 8) & Constants.GREEN_MASK | b & Constants.BLUE_MASK;
    };

    // Creates a simple array in [R, G, B, A] format, [255, 255, 255, 255]
    color.toArray = function(colorInt) {
      return [(colorInt & Constants.RED_MASK) >>> 16, (colorInt & Constants.GREEN_MASK) >>> 8,
              colorInt & Constants.BLUE_MASK, (colorInt & Constants.ALPHA_MASK) >>> 24];
    };

    // Creates a WebGL color array in [R, G, B, A] format. WebGL wants the color ranges between 0 and 1, [1, 1, 1, 1]
    color.toGLArray = function(colorInt) {
      return [((colorInt & Constants.RED_MASK) >>> 16) / 255, ((colorInt & Constants.GREEN_MASK) >>> 8) / 255,
              (colorInt & Constants.BLUE_MASK) / 255, ((colorInt & Constants.ALPHA_MASK) >>> 24) / 255];
    };

    // HSB conversion function from Mootools, MIT Licensed
    color.toRGB = function(h, s, b) {
      // Limit values greater than range
      h = (h > colorModeX) ? colorModeX : h;
      s = (s > colorModeY) ? colorModeY : s;
      b = (b > colorModeZ) ? colorModeZ : b;

      h = (h / colorModeX) * 360;
      s = (s / colorModeY) * 100;
      b = (b / colorModeZ) * 100;

      var br = Math.round(b / 100 * 255);

      if (s === 0) { // Grayscale
        return [br, br, br];
      }
      var hue = h % 360;
      var f = hue % 60;
      var p = Math.round((b * (100 - s)) / 10000 * 255);
      var q = Math.round((b * (6000 - s * f)) / 600000 * 255);
      var t = Math.round((b * (6000 - s * (60 - f))) / 600000 * 255);
      switch (Math.floor(hue / 60)) {
      case 0:
        return [br, t, p];
      case 1:
        return [q, br, p];
      case 2:
        return [p, br, t];
      case 3:
        return [p, q, br];
      case 4:
        return [t, p, br];
      case 5:
        return [br, p, q];
      }
    };

    function colorToHSB(colorInt) {
      var red, green, blue;

      red   = ((colorInt & Constants.RED_MASK) >>> 16) / 255;
      green = ((colorInt & Constants.GREEN_MASK) >>> 8) / 255;
      blue  = (colorInt & Constants.BLUE_MASK) / 255;

      var max = max(max(red,green), blue),
          min = min(min(red,green), blue),
          hue, saturation;

      if (min === max) {
        return [0, 0, max*colorModeZ];
      }
      saturation = (max - min) / max;

      if (red === max) {
        hue = (green - blue) / (max - min);
      } else if (green === max) {
        hue = 2 + ((blue - red) / (max - min));
      } else {
        hue = 4 + ((red - green) / (max - min));
      }

      hue /= 6;

      if (hue < 0) {
        hue += 1;
      } else if (hue > 1) {
        hue -= 1;
      }
      return [hue*colorModeX, saturation*colorModeY, max*colorModeZ];
    }

    /**
    * Extracts the brightness value from a color.
    *
    * @param {color} colInt any value of the color datatype
    *
    * @returns {float} The brightness color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see hue
    * @see saturation
    */
    brightness = function(colInt){
      return colorToHSB(colInt)[2];
    };

    /**
    * Extracts the saturation value from a color.
    *
    * @param {color} colInt any value of the color datatype
    *
    * @returns {float} The saturation color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see hue
    * @see brightness
    */
    saturation = function(colInt){
      return colorToHSB(colInt)[1];
    };

    /**
    * Extracts the hue value from a color.
    *
    * @param {color} colInt any value of the color datatype
    *
    * @returns {float} The hue color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see saturation
    * @see brightness
    */
    hue = function(colInt){
      return colorToHSB(colInt)[0];
    };

    /**
    * Extracts the red value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The red color value.
    *
    * @see green
    * @see blue
    * @see alpha
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    red = function(aColor) {
      return ((aColor & Constants.RED_MASK) >>> 16) / 255 * colorModeX;
    };

    /**
    * Extracts the green value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The green color value.
    *
    * @see red
    * @see blue
    * @see alpha
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    green = function(aColor) {
      return ((aColor & Constants.GREEN_MASK) >>> 8) / 255 * colorModeY;
    };

    /**
    * Extracts the blue value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The blue color value.
    *
    * @see red
    * @see green
    * @see alpha
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    blue = function(aColor) {
      return (aColor & Constants.BLUE_MASK) / 255 * colorModeZ;
    };

    /**
    * Extracts the alpha value from a color, scaled to match current colorMode().
    * This value is always returned as a float so be careful not to assign it to an int value.
    *
    * @param {color} aColor any value of the color datatype
    *
    * @returns {float} The alpha color value.
    *
    * @see red
    * @see green
    * @see blue
    * @see >> right shift
    * @see hue
    * @see saturation
    * @see brightness
    */
    alpha = function(aColor) {
      return ((aColor & Constants.ALPHA_MASK) >>> 24) / 255 * colorModeA;
    };
    alphaZeroToOne = function(aColor) {
      return ((aColor & Constants.ALPHA_MASK) >>> 24) / 255;
    };

    /**
    * Calculates a color or colors between two colors at a specific increment.
    * The amt parameter is the amount to interpolate between the two values where 0.0
    * equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.
    *
    * @param {color} c1     interpolate from this color
    * @param {color} c2     interpolate to this color
    * @param {float} amt    between 0.0 and 1.0
    *
    * @returns {float} The blended color.
    *
    * @see blendColor
    * @see color
    */
    lerpColor = function(c1, c2, amt) {
      var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;
      var hsb1, hsb2, rgb, h, s;
      var colorBits1 = color(c1);
      var colorBits2 = color(c2);

      if (curColorMode === Constants.HSB) {
        // Special processing for HSB mode.
        // Get HSB and Alpha values for Color 1 and 2
        hsb1 = colorToHSB(colorBits1);
        a1 = ((colorBits1 & Constants.ALPHA_MASK) >>> 24) / colorModeA;
        hsb2 = colorToHSB(colorBits2);
        a2 = ((colorBits2 & Constants.ALPHA_MASK) >>> 24) / colorModeA;

        // Return lerp value for each channel, for HSB components
        h = lerp(hsb1[0], hsb2[0], amt);
        s = lerp(hsb1[1], hsb2[1], amt);
        b = lerp(hsb1[2], hsb2[2], amt);
        rgb = color.toRGB(h, s, b);
        // ... and for Alpha-range
        a = lerp(a1, a2, amt) * colorModeA;

        return (a << 24) & Constants.ALPHA_MASK |
               (rgb[0] << 16) & Constants.RED_MASK |
               (rgb[1] << 8) & Constants.GREEN_MASK |
               rgb[2] & Constants.BLUE_MASK;
      }

      // Get RGBA values for Color 1 to floats
      r1 = (colorBits1 & Constants.RED_MASK) >>> 16;
      g1 = (colorBits1 & Constants.GREEN_MASK) >>> 8;
      b1 = (colorBits1 & Constants.BLUE_MASK);
      a1 = ((colorBits1 & Constants.ALPHA_MASK) >>> 24) / colorModeA;

      // Get RGBA values for Color 2 to floats
      r2 = (colorBits2 & Constants.RED_MASK) >>> 16;
      g2 = (colorBits2 & Constants.GREEN_MASK) >>> 8;
      b2 = (colorBits2 & Constants.BLUE_MASK);
      a2 = ((colorBits2 & Constants.ALPHA_MASK) >>> 24) / colorModeA;

      // Return lerp value for each channel, INT for color, Float for Alpha-range
      r = lerp(r1, r2, amt) | 0;
      g = lerp(g1, g2, amt) | 0;
      b = lerp(b1, b2, amt) | 0;
      a = lerp(a1, a2, amt) * colorModeA;

      return (a << 24) & Constants.ALPHA_MASK |
             (r << 16) & Constants.RED_MASK |
             (g << 8) & Constants.GREEN_MASK |
             b & Constants.BLUE_MASK;
    };

    /**
    * Changes the way Processing interprets color data. By default, fill(), stroke(), and background()
    * colors are set by values between 0 and 255 using the RGB color model. It is possible to change the
    * numerical range used for specifying colors and to switch color systems. For example, calling colorMode(RGB, 1.0)
    * will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the
    * parameters range1, range2, range3, and range 4.
    *
    * @param {MODE} mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness
    * @param {int|float} range              range for all color elements
    * @param {int|float} range1             range for the red or hue depending on the current color mode
    * @param {int|float} range2             range for the green or saturation depending on the current color mode
    * @param {int|float} range3             range for the blue or brightness depending on the current color mode
    * @param {int|float} range4             range for the alpha
    *
    * @returns none
    *
    * @see background
    * @see fill
    * @see stroke
    */
    colorMode = function() { // mode, range1, range2, range3, range4
      curColorMode = arguments[0];
      if (arguments.length > 1) {
        colorModeX   = arguments[1];
        colorModeY   = arguments[2] || arguments[1];
        colorModeZ   = arguments[3] || arguments[1];
        colorModeA   = arguments[4] || arguments[1];
      }
    };

    /**
    * Blends two color values together based on the blending mode given as the MODE parameter.
    * The possible modes are described in the reference for the blend() function.
    *
    * @param {color} c1 color: the first color to blend
    * @param {color} c2 color: the second color to blend
    * @param {MODE} MODE Either BLEND, ADD, SUBTRACT, DARKEST, LIGHTEST, DIFFERENCE, EXCLUSION, MULTIPLY,
    * SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, or BURN
    *
    * @returns {float} The blended color.
    *
    * @see blend
    * @see color
    */
    blendColor = function(c1, c2, mode) {
      if (mode === Constants.REPLACE) {
        return modes.replace(c1, c2);
      } else if (mode === Constants.BLEND) {
        return modes.blend(c1, c2);
      } else if (mode === Constants.ADD) {
        return modes.add(c1, c2);
      } else if (mode === Constants.SUBTRACT) {
        return modes.subtract(c1, c2);
      } else if (mode === Constants.LIGHTEST) {
        return modes.lightest(c1, c2);
      } else if (mode === Constants.DARKEST) {
        return modes.darkest(c1, c2);
      } else if (mode === Constants.DIFFERENCE) {
        return modes.difference(c1, c2);
      } else if (mode === Constants.EXCLUSION) {
        return modes.exclusion(c1, c2);
      } else if (mode === Constants.MULTIPLY) {
        return modes.multiply(c1, c2);
      } else if (mode === Constants.SCREEN) {
        return modes.screen(c1, c2);
      } else if (mode === Constants.HARD_LIGHT) {
        return modes.hard_light(c1, c2);
      } else if (mode === Constants.SOFT_LIGHT) {
        return modes.soft_light(c1, c2);
      } else if (mode === Constants.OVERLAY) {
        return modes.overlay(c1, c2);
      } else if (mode === Constants.DODGE) {
        return modes.dodge(c1, c2);
      } else if (mode === Constants.BURN) {
        return modes.burn(c1, c2);
      }
    };

    var currentFillAlpha = 1;
    var currentFillColor = 0xFFFFFF;
    fill = function() {
      var c = color(arguments[0], arguments[1], arguments[2], arguments[3]);
      var crgb = color(red(c), green(c), blue(c));
      var ca = alphaZeroToOne(c);
      //console.log("crgb ca "+crgb + " " + ca);
      if(crgb === currentFillColor && ca === currentFillAlpha && doFill) {
        return;
      }
      doFill = true;
      currentFillColor = crgb;
      currentFillAlpha = ca;
    };

/**
     * The noFill() function disables filling geometry. If both <b>noStroke()</b> and <b>noFill()</b>
     * are called, no shapes will be drawn to the screen.
     *
     * @see #fill()
     *
     */
    noFill = function() {
      doFill = false;
    };

    /**
     * The stroke() function sets the color used to draw lines and borders around shapes. This color
     * is either specified in terms of the RGB or HSB color depending on the
     * current <b>colorMode()</b> (the default color space is RGB, with each
     * value in the range from 0 to 255).
     * <br><br>When using hexadecimal notation to specify a color, use "#" or
     * "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six
     * digits to specify a color (the way colors are specified in HTML and CSS).
     * When using the hexadecimal notation starting with "0x", the hexadecimal
     * value must be specified with eight characters; the first two characters
     * define the alpha component and the remainder the red, green, and blue
     * components.
     * <br><br>The value for the parameter "gray" must be less than or equal
     * to the current maximum value as specified by <b>colorMode()</b>.
     * The default maximum value is 255.
     *
     * @param {int|float} gray    number specifying value between white and black
     * @param {int|float} value1  red or hue value
     * @param {int|float} value2  green or saturation value
     * @param {int|float} value3  blue or brightness value
     * @param {int|float} alpha   opacity of the stroke
     * @param {Color} color       any value of the color datatype
     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)
     *
     * @see #fill()
     * @see #noStroke()
     * @see #tint()
     * @see #background()
     * @see #colorMode()
     */
	var currentStrokeAlpha = 1;
    var currentStrokeColor = 0x000000;
    var stroke = function() {
      var c = color(arguments[0], arguments[1], arguments[2], arguments[3]);
      var crgb = color(red(c), green(c), blue(c));
      var ca = alphaZeroToOne(c);
      //console.log("crgb ca "+crgb + " " + ca);
      if(crgb === currentStrokeColor && ca === currentStrokeAlpha && doStroke) {
        return;
      }
      doStroke = true;
      currentStrokeColor = crgb;
      currentStrokeAlpha = ca;
    };

	/**
     * The noStroke() function disables drawing the stroke (outline). If both <b>noStroke()</b> and
     * <b>noFill()</b> are called, no shapes will be drawn to the screen.
     *
     * @see #stroke()
     */
    noStroke = function() {
      doStroke = false;
    };
    // enf of functions from processing.js
		// init the scene
		function init(){

			scaledBackgroundWidth = Math.floor(window.innerWidth / backGroundFraction);
			scaledBackgroundHeight = Math.floor(window.innerHeight / backGroundFraction);

			if( Detector.webgl && !forceCanvasRenderer ){

				sceneRenderingCanvas = document.createElement('canvas');
				
				renderer = new THREE.WebGLRenderer({
					canvas: sceneRenderingCanvas,
					antialias		: true,	// to get smoother output					
					preserveDrawingBuffer	: false,	// to allow screenshot
					clearColor: 0x000000, clearAlpha: 0, antialias: false
				});
			   
			   //renderer.autoClearColor = false;
			   //renderer.autoClear = false;
			   isWebGLUsed = true;
			   
			   // this is really a bad hack, but chrome goes twice
			   // as fast with this, while safari doesn't work,
			   // and firefox is the fastest no matter what
			   if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
			   	//renderer.autoClear = false;
			   }
			   
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.getElementById('container').appendChild(sceneRenderingCanvas);
				//document.getElementById('finalRenderWithSceneAndBlendCanvas').appendChild(finalRenderWithSceneAndBlend);


			}else{
			
			
			 // we always draw the 3d scene off-screen
				sceneRenderingCanvas = document.createElement('canvas');
				sceneRenderingCanvasContext = sceneRenderingCanvas.getContext('2d');
				renderer	= new THREE.CanvasRenderer({
					canvas: sceneRenderingCanvas,
					antialias		: true,	// to get smoother output					
					preserveDrawingBuffer	: false	// to allow screenshot
				});
			   	
			   	//renderer.autoClear = true;
			   	//renderer.setClearColorHex( 0x000000, 1 );


				previousRenderForBlending = document.createElement('canvas');
				previousRenderForBlending.width = window.innerWidth;
				previousRenderForBlending.height = window.innerHeight;
				previousRenderForBlendingContext = previousRenderForBlending.getContext('2d');
		
				finalRenderWithSceneAndBlend = document.getElementById('finalRenderWithSceneAndBlendCanvas');  
				//finalRenderWithSceneAndBlend.width = scaledBackgroundWidth;
				//finalRenderWithSceneAndBlend.height = scaledBackgroundHeight;
				finalRenderWithSceneAndBlend.width = window.innerWidth;
				finalRenderWithSceneAndBlend.height = window.innerWidth;
				finalRenderWithSceneAndBlendContext = finalRenderWithSceneAndBlend.getContext('2d');
				
				renderer.setSize( window.innerWidth, window.innerHeight );
				//document.getElementById('container').appendChild(sceneRenderingCanvas);
			}


				backgroundScene = document.getElementById('backGroundCanvas');  
				backgroundScene.width = scaledBackgroundWidth;
				backgroundScene.height = scaledBackgroundHeight;
				backgroundSceneContext = backgroundScene.getContext('2d');



			// add Stats.js - https://github.com/mrdoob/stats.js
			stats = new Stats();
			// Align bottom-left
			stats.getDomElement().style.position = 'absolute';
			stats.getDomElement().style.right = '0px';
			stats.getDomElement().style.top = '0px';
			document.body.appendChild( stats.getDomElement() );

			scene = new THREE.Scene();
			scene.matrixAutoUpdate = false;


			// put a camera in the scene
			camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.set(0, 0, 5);
			scene.add(camera);

			// transparently support window resize
			THREEx.WindowResize.bind(renderer, camera);
			
			if (isWebGLUsed) {
				buildPostprocessingChain();
			}

}

buildPostprocessingChain = function () {
	renderTargetParameters = { format: THREE.RGBAFormat, stencilBuffer: true };
	
	renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, renderTargetParameters );			
	effectSaveTarget = new THREE.SavePass( new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, renderTargetParameters ) );
	effectSaveTarget.clear = false;
	
	fxaaPass = new THREE.ShaderPass( THREE.ShaderExtras[ "fxaa" ] );
	fxaaPass.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
	
	effectBlend = new THREE.ShaderPass( THREE.ShaderExtras[ "blend" ], "tDiffuse1" );   
	screenPass = new THREE.ShaderPass( THREE.ShaderExtras[ "screen" ] );
	
	// motion blur
	effectBlend.uniforms[ 'tDiffuse2' ].texture = effectSaveTarget.renderTarget;
	effectBlend.uniforms[ 'mixRatio' ].value = 0;
	
	var renderModel = new THREE.RenderPass( scene, camera );    
	
	composer = new THREE.EffectComposer( renderer, renderTarget );
	
	composer.addPass( renderModel );
	//composer.addPass( fxaaPass );	
	composer.addPass( effectBlend );
	composer.addPass( effectSaveTarget );
	composer.addPass( screenPass );
	screenPass.renderToScreen = true;
}

		

		function render() {


			/*
			// need a light for the meshlambert material
			var light = new THREE.PointLight( 0xFFFFFF );
			light.position.set( 10, 0, 10 );
			scene.add( light );
			*/



			////////////////////////

			if (isWebGLUsed) {
				composer.render( );
				//renderer.render(scene,camera);
			}

			else {
			
			
				// the renderer draws into an offscreen canvas called sceneRenderingCanvas
				renderer.render( scene, camera );
								
				// clear the final render context
				finalRenderWithSceneAndBlendContext.globalAlpha = 1.0;
				finalRenderWithSceneAndBlendContext.clearRect(0, 0, window.innerWidth,window.innerHeight)
				
				// draw the rendering of the scene on the final render
				// clear the final render context
				finalRenderWithSceneAndBlendContext.globalAlpha = blendAmount;
				finalRenderWithSceneAndBlendContext.drawImage(previousRenderForBlending, 0, 0);

				finalRenderWithSceneAndBlendContext.globalAlpha = 1.0;
				finalRenderWithSceneAndBlendContext.drawImage(sceneRenderingCanvas, 0, 0);
				
				//previousRenderForBlendingContext.clearRect(0, 0, window.innerWidth,window.innerHeight)
				previousRenderForBlendingContext.globalCompositeOperation = 'copy';
				previousRenderForBlendingContext.drawImage(finalRenderWithSceneAndBlend, 0, 0);
				
				// clear the renderer's canvas to transparent black
				sceneRenderingCanvasContext.clearRect(0, 0, window.innerWidth,window.innerHeight)



			}

				
		}
		
		
var drawLoopTimer = null;
var frame = 0;
var doLNOnce = [];

if( !init() )	animate();

// By doing some profiling it is apparent that
// adding and removing objects has a big cost.
// So instead of adding/removing objects every frame,
// objects are only added at creation and they are
// never removed from the scene. They are
// only made invisible. This routine combs the
// scene and finds the objects that.
// TODO a way to shrink the scene if it's been a
// long time that only a handful of lines/meshes
// have been used.

function combDisplayList() {
	
	for(var i = 0; i < scene.objects.length; ++i) {
			var sceneObject = scene.objects[i];
			if (sceneObject.isLine){
				if (usedLines > 0) {
					sceneObject.visible = true;
					usedLines--;
				}
				else {
					sceneObject.visible = false;
				}
			}
			else if (sceneObject.isMesh){
				if (usedRectangles > 0) {
					sceneObject.visible = true;
					usedRectangles--;
				}
				else {
					sceneObject.visible = false;
				}
			}
			else if (sceneObject.isBox){
				if (usedBoxes > 0) {
					sceneObject.visible = true;
					usedBoxes--;
				}
				else {
					sceneObject.visible = false;
				}
			}
	}
}


function clearDisplayList() {
	/*
	for(var i = 0; i < scene.objects.length; ++i) {
			scene.remove(scene.objects[i]);
			i--;
	}
	*/
}

function registerCode() {
    

      try {
      
        var editorContent = editor.getValue();
        
        if (editorContent !== '' && fakeText === true) {
        	shrinkFakeText();
        }
        
        if (editorContent === '' && !fakeText) {
    		fakeText = true;
    		window.location.hash = '';
    	
			$("#formCode").animate({opacity: 0}, "fast");
			//$("#formCode").css('opacity',0);
			//setTimeout('if (editor.getValue() !== "") $("#formCode").css("opacity",0);',10);
			console.log('unshrinking');
			$("#justForFakeCursor").show();
			$("#toMove").show();			
			$('#caption').html('|');

		  
		  $("#toMove").animate(
			  {
				opacity: 1,
				margin: 0,
				fontSize:350,
				left: 0
			  },
			  "fast",
			  function() {
							$('#caption').html('');
							$('#fakeStartingBlinkingCursor').html('|');
							//fakeCursorInterval = setInterval ( "fakeCursorBlinking()", 800 );
						}
		  );

        }
        
        var copyOfEditorContent;
        var programIsMangled = false;
        var programContainsStringsOrComments = false;
        var characterBeingExamined;
        var nextCharacterBeingExamined;
        
		// a check mark is added to the left of
		// doOnce statements that have been executed
		// but in reality those check marks
		// are just single-line comments, so replace here.

		editorContent = editorContent.replace(/^(\s)*âœ“[ ]*doOnce[ ]*\-\>[ ]*$/gm,"$1if false");
		editorContent = editorContent.replace("\u2713","//");
        
        // according to jsperf, this is the fastest way to count for
        // occurrences of a character. We count apostrophes


		// check whether the program potentially
		// contains strings or comments
		// if it doesn't then we can do some
		// simple syntactic checks that are likely
		// to be much faster than attempting a
		// coffescript to javascript translation
        copyOfEditorContent = editorContent;

        /*
        if (chromeHackUncaughtReferenceNames !== []) {
			//alert("there is at least one undefined, actually: " + chromeHackUncaughtReferenceNames.length);

			var lengthToCheck = chromeHackUncaughtReferenceNames.length;
			for (var iteratingOverSource = 0; iteratingOverSource < lengthToCheck; iteratingOverSource++) {
						copyOfEditorContent = copyOfEditorContent.replace(new RegExp( '\\s+'+chromeHackUncaughtReferenceNames[iteratingOverSource]+'\\s+', "g" ),"ERROR");
			}
	
			if (copyOfEditorContent.indexOf('ERROR') > -1) {
				alert("found some old undefineds");
				return;
			}
			
			// if we are here it means that
			// all the previous undefineds are not
			// found anymore
			// TODO this wouldn't work if one uses a function name
			// and then one defines it. We should also check
			// whether there is a function definition
			chromeHackUncaughtReferenceNames = [];

		}
		*/


		while (copyOfEditorContent.length) {
			characterBeingExamined = copyOfEditorContent.charAt(0);
			nextCharacterBeingExamined = copyOfEditorContent.charAt(1);
		  if (characterBeingExamined === "'" ||
		  	characterBeingExamined === '"' ||
		  	(characterBeingExamined === "/" &&
		  		(
		  		nextCharacterBeingExamined === "*" ||
		  		nextCharacterBeingExamined === "/"
		  		)
		  	)
		  	) {
			  programContainsStringsOrComments = true;
			  //alert('program contains strings or comments');
			  break;
		   }
		   copyOfEditorContent = copyOfEditorContent.slice(1);
		}

        // let's do a quick check:
        // these groups of characters should be in even number:
        // ", ', (), {}, []
        
		if (programContainsStringsOrComments) {
			// OK the program contains comments and/or strings
			// so this is what we are going to do:
			// first we remove all the comments for good
			// then we create a version without the strings
			// so we can perform some basic syntax checking.
			// Note that when we remove the comments we also need to
			// take into account strings because otherwise we mangle a line like
       	 	// print "frame/100 //"
       	 	// where we need to now that that single comment is actually the content
       	 	// of a string.
		
			// modified from Processing.js (search for: "masks strings and regexs")
			// this is useful to remove all comments but keeping all the strings
			// the difference is that here I don't treat regular expressions.
			// Note that string take precedence over comments i.e.
			// is a string, not half a string with a quote in a comment

			// get rid of the comments for good.
			editorContent = editorContent.replace(/("(?:[^"\\\n]|\\.)*")|('(?:[^'\\\n]|\\.)*')|(\/\/[^\n]*\n)|(\/\*(?:(?!\*\/)(?:.|\n))*\*\/)/g,
			function(all, quoted, aposed, singleComment, comment) {
			  // strings are kept as they are
			  if(quoted) {
				return quoted;
			  }
			  else if(aposed) {
				return aposed;
			  }
			  else if(singleComment) {
			  	// preserve the line because
			  	// the doOnce mechanism needs to retrieve
			  	// the line where it was
				return "\n";
			  }
			  // eliminate multiline comments preserving the lines
			  else {
			  	var numberOfLinesInMultilineComment = comment.split("\n").length-1;
			  	//alert('rebuilding multilines: '+ numberOfLinesInMultilineComment);
			  	var rebuiltNewLines = '';
			  	for (var cycleToRebuildNewLines = 0; cycleToRebuildNewLines < numberOfLinesInMultilineComment; cycleToRebuildNewLines++){
			  		rebuiltNewLines = rebuiltNewLines + "\n";
			  	}
			  	//alert('rebuilding multilines: '+ rebuiltNewLines);
				return rebuiltNewLines;
			  }
			});
			
			// ok now in the version we use for syntax checking we delete all the strings
			copyOfEditorContent = editorContent.replace(/("(?:[^"\\\n]|\\.)*")|('(?:[^'\\\n]|\\.)*')/g,"");

		}
		else {
		    copyOfEditorContent = editorContent;
		}
		
			var aposCount = 0;
			var quoteCount = 0;
			var roundBrackCount = 0;
			var curlyBrackCount = 0;
			var squareBrackCount = 0;
			
			while (copyOfEditorContent.length) {
				characterBeingExamined = copyOfEditorContent.charAt(0)
			
			  if ( characterBeingExamined === "'") {
				  aposCount += 1;
				}
			  else if (characterBeingExamined === '"') {
				  quoteCount += 1;
				}
			  else if (characterBeingExamined === '(' || characterBeingExamined === ')' ) {
				  roundBrackCount += 1;
				}
			  else if (characterBeingExamined === '{' || characterBeingExamined === '}' ) {
				  curlyBrackCount += 1;
				}
			  else if (characterBeingExamined === '[' || characterBeingExamined === ']' ) {
				  squareBrackCount += 1;
				}
			   copyOfEditorContent = copyOfEditorContent.slice(1);
			}
			
			// according to jsperf, the fastest way to check if number is even/odd
			if (
				aposCount & 1 ||
				quoteCount & 1 ||
				roundBrackCount & 1 ||
				curlyBrackCount & 1 ||
				squareBrackCount & 1
			){
				programHasBasicError = true;
				//alert("basic error");
				//alert("p:" + $('#dangerSignText').css('color'));
				$('#dangerSignText').css('color','red')

			if (aposCount & 1) reasonOfBasicError = "Missing '";
			if (quoteCount & 1) reasonOfBasicError = 'Missing "';
			if (roundBrackCount & 1) reasonOfBasicError = "Unbalanced ()";
			if (curlyBrackCount & 1) reasonOfBasicError = "Unbalanced {}";
			if (squareBrackCount & 1) reasonOfBasicError = "Unbalanced []";

				$('#errorMessageText').text(reasonOfBasicError)
				
				
				return;
			}
					
        
      	// indent the code
        var elaboratedSource = "\t"+editorContent.replace(
			new RegExp( "\\n", "g" ), "\n\t"
		);
        elaboratedSource = "draw = ->\n" + elaboratedSource;
        
        // little trick. This is mangled up in the translation from coffeescript
        // (1).times ->
        // But this isn't:
        // (1+0).times ->
        // So here is the little replace.
        
        // TODO: you should be a little smarter about the substitution of the draw method
        // You can tell a method declaration because the line below is indented
        // so you should check that.
        
        
        //elaboratedSource =  elaboratedSource.replace(/^([a-z]+[a-zA-Z0-9]+)\s*$/gm, "$1 = ->" );
        
        // some replacements add a semicolon for the
        // following reason: coffeescript allows you to split arguments
        // over multiple lines.
        // So if you have:
        //   rotate 0,0,1
        //   box
        // and you want to add a scale like so:
        //   scale 2,2,2
        //   rotate 0,0,1
        //   box
        // What happens is that as you are in the middle of typing:
        //   scale 2,
        //   rotate 0,0,1
        //   box
        // coffeescript takes the rotate as the second argument of scale
        // causing mayhem.
        // Instead, all is good if rotate is prepended with a semicolon.
        
        
        elaboratedSource =  elaboratedSource.replace(/(\d+)\s+times[ ]*\->/g, ";( $1 + 0).times ->" );


        // if there is at least one doOnce:
        // split the source in lines
        // add all the line numbers info
        // regroup the lines into a single string again
        
        //alert('soon before replacing doOnces'+elaboratedSource);
        if (elaboratedSource.indexOf('doOnce') > -1){
        	//alert("a doOnce is potentially executable");
			elaboratedSourceByLine = elaboratedSource.split("\n");
			//alert('splitting: ' + elaboratedSourceByLine.length );
			for (var iteratingOverSource = 0; iteratingOverSource < elaboratedSourceByLine.length; iteratingOverSource++) {
				//alert('iterating: ' + iteratingOverSource );
				elaboratedSourceByLine[iteratingOverSource] = elaboratedSourceByLine[iteratingOverSource].replace(/^(\s*)doOnce[ ]*\->[ ]*(.+)$/gm, "$1;doLNOnce.push("+(iteratingOverSource-1)+"); (1+0).times -> $2" );
				
				if (elaboratedSourceByLine[iteratingOverSource].match(/^(\s*)doOnce[ ]*\->[ ]*$/gm)) {
					//alert('doOnce multiline!');
					elaboratedSourceByLine[iteratingOverSource] = elaboratedSourceByLine[iteratingOverSource].replace(/^(\s*)doOnce[ ]*\->[ ]*$/gm, "$1(1+0).times ->" );
					elaboratedSourceByLine[iteratingOverSource+1] = elaboratedSourceByLine[iteratingOverSource+1].replace(/^(\s*)(.+)$/gm, "$1;doLNOnce.push("+(iteratingOverSource-1)+"); $2" );
				}
				
			}
			elaboratedSource = elaboratedSourceByLine.join("\n");
        	//alert('soon after replacing doOnces'+elaboratedSource);
        }
        


        elaboratedSource =  elaboratedSource.replace(/^(\s*)([a-z]+[a-zA-Z0-9]+)[ ]*$/gm, "$1;$2()" );
        
        // this takes care of when a token that it's supposed to be
        // a function is inlined with something else e.g.
        // doOnce frame = 0; box
        // 2 times -> box
        elaboratedSource =  elaboratedSource.replace(/;\s*([a-z]+[a-zA-Z0-9]+)[ ]*([;\n]+)/g, ";$1()$2" );
        // this takes care of when a token that it's supposed to be
        // a function is inlined like so:
        // 2 times -> box
        elaboratedSource =  elaboratedSource.replace(/\->\s*([a-z]+[a-zA-Z0-9]+)[ ]*([;\n]+)/g, ";$1()$2" );

			// draw() could just be called by mistake and it's likely
			// to be disastrous. User doesn't even have visibility of such method,
			// why should he/she call it?
			// TODO: call draw() something else that the user is not
			// likely to use by mistake and take away this check.
			if (
				elaboratedSource.match(/[\s\+\;]+draw\s*\(/) ||
				false
			){
				programHasBasicError = true;
				$('#dangerSignText').css('color','red');
				$('#errorMessageText').text("You can't call draw()");
				return;
			}


        // we don't want if and for to undergo the same tratment as, say, box
        // so put those back to normal.
        elaboratedSource =  elaboratedSource.replace(/;if\(\)/g, ";if" );
        elaboratedSource =  elaboratedSource.replace(/;for\(\)/g, ";for" );

        elaboratedSource =  elaboratedSource.replace(/\/\//g, "#" );
        elaboratedSource =  elaboratedSource.replace(/scale(\s)+/g, ";scale$1" );
        elaboratedSource =  elaboratedSource.replace(/rotate(\s)+/g, ";rotate$1" );
        elaboratedSource =  elaboratedSource.replace(/translate(\s)+/g, ";translate$1" );
        elaboratedSource =  elaboratedSource.replace(/rect(\s)+/g, ";rect$1" );
        elaboratedSource =  elaboratedSource.replace(/line(\s)+/g, ";line$1" );
        elaboratedSource =  elaboratedSource.replace(/bpm(\s)+/g, ";bpm$1" );
        elaboratedSource =  elaboratedSource.replace(/addSound(\s)+/g, ";addSound$1" );
        elaboratedSource =  elaboratedSource.replace(/pushMatrix(\s)+/g, ";pushMatrix$1" );
        elaboratedSource =  elaboratedSource.replace(/popMatrix(\s)+/g, ";popMatrix$1" );
        elaboratedSource =  elaboratedSource.replace(/resetMatrix(\s)+/g, ";resetMatrix$1" );
        elaboratedSource =  elaboratedSource.replace(/fill(\s)+/g, ";fill$1" );
        elaboratedSource =  elaboratedSource.replace(/noFill(\s)+/g, ";noFill$1" );
        elaboratedSource =  elaboratedSource.replace(/stroke(\s)+/g, ";stroke$1" );
        elaboratedSource =  elaboratedSource.replace(/noStroke(\s)+/g, ";noStroke$1" );
        elaboratedSource =  elaboratedSource.replace(/animationMode(\s)+/g, ";animationMode$1" );
        elaboratedSource =  elaboratedSource.replace(/simpleGradient(\s)+/g, ";simpleGradient$1" );
        elaboratedSource =  elaboratedSource.replace(/color(\s)+/g, ";color$1" );

        // the semicolon mangles the first line of the function definitions
        // coffeescript doesn't like that
        elaboratedSource =  elaboratedSource.replace(/->(\s+);/g, "->$1" );
        
      
        //alert(elaboratedSource );
        out = CoffeeScript.compile(elaboratedSource, {
          bare: "on"
        });
        //alert("in javascript: " + out);
        
      } catch (e) {
			$('#dangerSignText').css('color','red')
			$('#errorMessageText').text(""+e)
        return;
      }


      // FINDS USED METHODS WHICH ARE NOT DECLARED
	  var matchDeclaredMethod = /([a-z]+[a-zA-Z0-9]*) = function/ ;
	  var declaredMethods = [];
	  var mc;
	  var copyOfOut = out;
	  while ((mc = copyOfOut.match( matchDeclaredMethod  ))) {
        declaredMethods.push(mc[1]);
        copyOfOut = RegExp.rightContext;
      }
      //alert("found declared methods " + declaredMethods.length);
      //alert("out:"+out)


	  var usedMethods = [];
	  var md;
	  copyOfOut = out;
	  while ((md = copyOfOut.match(  /\s([a-z]+[a-zA-Z0-9]*)\(/ ))) {
        usedMethods.push(md[1]);
        copyOfOut = RegExp.rightContext;
      }
      //alert("found used methods " + usedMethods.length);
      
	  var error = false;
      for (var scanningUsedMethods = 0; scanningUsedMethods < usedMethods.length; scanningUsedMethods++){
		  if (
			  usedMethods[scanningUsedMethods] === "function" ||
			  usedMethods[scanningUsedMethods] === "rotate" ||
			  usedMethods[scanningUsedMethods] === "rect" ||
			  usedMethods[scanningUsedMethods] === "line" ||
			  usedMethods[scanningUsedMethods] === "box" ||
			  usedMethods[scanningUsedMethods] === "translate" ||
			  usedMethods[scanningUsedMethods] === "scale" ||
			  usedMethods[scanningUsedMethods] === "alert" ||
			  usedMethods[scanningUsedMethods] === "bpm" ||
			  usedMethods[scanningUsedMethods] === "addSound" ||
			  usedMethods[scanningUsedMethods] === "pushMatrix" ||
			  usedMethods[scanningUsedMethods] === "popMatrix" ||
			  usedMethods[scanningUsedMethods] === "resetMatrix" ||
			  usedMethods[scanningUsedMethods] === "fill" ||
			  usedMethods[scanningUsedMethods] === "noFill" ||
			  usedMethods[scanningUsedMethods] === "stroke" ||
			  usedMethods[scanningUsedMethods] === "noStroke" ||
			  usedMethods[scanningUsedMethods] === "animationMode" ||
			  usedMethods[scanningUsedMethods] === "simpleGradient" ||
			  usedMethods[scanningUsedMethods] === "color" ||
			  false
		  ){
		  	continue;
		  }
      	  if (declaredMethods.length == 0){
			  error = true;
			  //alert("used method not declared: " + usedMethods[scanningUsedMethods]);
			  $('#dangerSignText').css('color','red');
			  $('#errorMessageText').text(usedMethods[scanningUsedMethods] + " used but not defined");
			  return;
      	  }
		  for (var scanningDeclaredMethods = 0; scanningDeclaredMethods < declaredMethods.length; scanningDeclaredMethods++){
		  	//alert ("comparing >" + usedMethods[scanningUsedMethods]  + "< , >" + declaredMethods[scanningDeclaredMethods] +"<");
		  	if (usedMethods[scanningUsedMethods] === declaredMethods[scanningDeclaredMethods]){
		  		break;
		  	}
		  	else if (scanningDeclaredMethods == declaredMethods.length - 1) {
			  error = true;
			  //alert("used method not declared: " + usedMethods[scanningUsedMethods]);
			  $('#dangerSignText').css('color','red');
			  $('#errorMessageText').text(usedMethods[scanningUsedMethods] + " used but not defined");
			  return;
		  	}
		  }
      }


				programHasBasicError = false;
				reasonOfBasicError = "";
				$('#dangerSignText').css('color','#323232')
				$('#errorMessageText').text(reasonOfBasicError)

	// see here for the deepest examination ever of "eval"
	// http://perfectionkills.com/global-eval-what-are-the-options/
	// note that exceptions are caught by the window.onerror callback
	consecutiveFramesWithoutRunTimeError = 0;
	
	// so it turns out that when you ASSIGN to the frame variable inside
	// the coffeescript, it declares a local one, which makes changing
	// it impossible.
	// TODO: There must be a way to tell coffeescript to accept
	// some variables as global, for the time being let's put
	// the cheap hack in place.
	out = out.replace(/var frame/,";");
	
    //alert("out:"+out);
	window.eval(out);

      
}

//var chromeHackUncaughtReferenceName = '';
//var chromeHackUncaughtReferenceNames = [];

window.onerrord=function(msg, url, linenumber){
 $('#dangerSignText').css('color','red');
 $('#errorMessageText').text(msg);
 
 // ok so this is kind of a hack that we need to put
 // in place for Chrome (both Windows and Mac)
 // what Chrome does is: when there is a function call,
 // it evaluates the arguments
 // of a function even if the function is undefined
 // so for example
 // doO alert "miao"
 // alerts a miao, because it's translated into
 // doO(alert("miao))
 // and even if doO is undefined, the argumen is evaluated
 // This is a problem because doOnce would encourage
 // the following use: misspell doOnce until the rest of the
 // line is finished, then correct the mispell to actually
 // run the line once.
 // But unfortunately because of the quirk described above,
 // that wouldn't work in Chrome.
 
 /*
 if (msg.indexOf("Uncaught ReferenceError") > -1) {
 	chromeHackUncaughtReferenceName = msg.split(' ')[2];

	var lengthToCheck = chromeHackUncaughtReferenceNames.length;
	if (lengthToCheck == 0){
		chromeHackUncaughtReferenceNames.push(chromeHackUncaughtReferenceName);
	}
	else {
		for (var iteratingOverSource = 0; iteratingOverSource < lengthToCheck; iteratingOverSource++) {
			if (chromeHackUncaughtReferenceNames[iteratingOverSource].indexOf(chromeHackUncaughtReferenceName) > -1) {
				break;
			}
			else if (iteratingOverSource == lengthToCheck-1) {
			 // if we are here it means that the variable is not in the array
			 chromeHackUncaughtReferenceNames.push(chromeHackUncaughtReferenceName);
			}
		}
	}
 }
 */
 
 // we set this to 6 because we save it as stable
 // when it's 5, so we avoid re-saving.
 consecutiveFramesWithoutRunTimeError = 6;
 window.eval(lastStableProgram);

 return true
}

function background(red, green, blue) {

			clearDisplayList();

			// canvas renderer
			theColor = new THREE.Color();
			theColor.setRGB(red, green,blue);
			renderer.setClearColor(theColor,1);



}

// animation loop
		var loopInterval;
    	function animate() {

			// loop on request animation loop
			// - it has to be at the begining of the function
			// - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
			// requestAnimationFrame seems to only do 60 fps, which in my case is too much,
			// I rather prefer to have a slower framerate but steadier.
			
			if (useRequestAnimationFrame) {
				if (wantedFramesPerSecond === -1) {
					requestAnimationFrame( animate );
				}
				else {
					//setTimeout("window.requestAnimationFrame(animate)",
                    //       1000 / wantedFramesPerSecond);
                    if (loopInterval === undefined) {
						loopInterval = setInterval("window.requestAnimationFrame(animate)",
							   1000 / wantedFramesPerSecond);
                    }
				}
			}
			else {
				setTimeout( 'animate();', 1000 / wantedFramesPerSecond );
			}

			//clearDisplayList();
			matrixStack = [];
			worldMatrix.identity();

			// the sound list needs to be cleaned
			// and the beatsPerMinute set to zero
			// so that the user program can create its own from scratch
			beatsPerMinute = 0;
			soundLoops.soundIDs = [];
			soundLoops.beatStrings = [];


			//rootObject = new THREE.Object3D();
			//scene.add(rootObject);
			//parentObject = rootObject;

			if (typeof(draw) != "undefined") { 
			  doLNOnce = [];
			  usedLines = 0;
			  usedRectangles = 0;
			  animationModeValue = normal;
			  resetGradientStack();
			  draw();
			  animationModeUpdateIfChanged();
			  simpleGradientUpdateIfChanged();
			  frame++;
			  consecutiveFramesWithoutRunTimeError++;
			  if (consecutiveFramesWithoutRunTimeError == 5) {
			  	lastStableProgram = out;
			  	//chromeHackUncaughtReferenceName = '';
			  }
			}

			// do the render
			combDisplayList();
			render();
			//clearDisplayList();

			// update stats
			stats.update();
			
			
			if (doLNOnce.length !== 0){
				//alert("a doOnce has been ran");
				elaboratedSource = editor.getValue();
				elaboratedSourceByLine = elaboratedSource.split("\n");
				//alert('splitting: ' + elaboratedSourceByLine.length );
				for (var iteratingOverSource = 0; iteratingOverSource < doLNOnce.length; iteratingOverSource++) {
					//alert('iterating: ' + iteratingOverSource );
					elaboratedSourceByLine[doLNOnce[iteratingOverSource]] = elaboratedSourceByLine[doLNOnce[iteratingOverSource]].replace(/^(\s*)doOnce([ ]*\->[ ]*.+)$/gm, "$1\u2713doOnce$2" );
					elaboratedSourceByLine[doLNOnce[iteratingOverSource]] = elaboratedSourceByLine[doLNOnce[iteratingOverSource]].replace(/^(\s*)doOnce([ ]*\->[ ]*)$/gm, "$1\u2713doOnce$2" );
				}
				elaboratedSource = elaboratedSourceByLine.join("\n");
				
				var cursorPositionBeforeAddingCheckMark = editor.getCursor();
				cursorPositionBeforeAddingCheckMark.ch = cursorPositionBeforeAddingCheckMark.ch + 1;
				editor.setValue(elaboratedSource);
				editor.setCursor(cursorPositionBeforeAddingCheckMark);
				
				// we want to avoid that another frame is run with the old
				// code, as this would mean that the
				// runOnce code is run more than once,
				// so we need to register the new code.
				// TODO: ideally we don't want to register the
				// new code by getting the code from codemirror again
				// because we don't know what that entails. We should
				// just pass the code we already have.
				// Also registerCode() may split the source code by line, so we can
				// avoid that since we've just split it, we could pass
				// the already split code.
				registerCode();
        	}

			
		}

	var lastkey = 0
	var fakeText = true;
	document.onkeypress = function(e){

		if (fakeText && editor.getValue() !== "") shrinkFakeText(e);
	
	};
	
    var shrinkFakeText = function(e) {

		if (e !== undefined){
			var theEvent = e || window.event;
			var key = theEvent.keyCode || theEvent.which;
			key = String.fromCharCode( key ); 
		}
		else key = '';

	    var currentCaption = $('#caption').html();
	    var shorterCaption  = currentCaption.substring(0,currentCaption.length - 1);
	    $('#caption').html( shorterCaption + key + "|");
	    $('#fakeStartingBlinkingCursor').html('');
	    
		  $("#toMove").animate(
		  {
			opacity: 0,
			margin: -100,
			fontSize:300,
			left: 0
		  }, "fast");
		  
		  setTimeout('$("#formCode").animate({opacity: 1}, "fast");',120);
		  setTimeout('$("#justForFakeCursor").hide();',200);
		  setTimeout('$("#toMove").hide();',200);
		  //setTimeout('clearTimeout(fakeCursorInterval);',200);
		  fakeText = false;

    }
    

var parentObject, rootObject, rotate, translate;
parentObject = 0;
rootObject = 0;
var currentObject;
var beatsPerMinute = 0;
var oldBeatsPerMinute = 0;
var soundLoopTimer;
var beatNumber = 0;

bpm = function(a) {

	beatsPerMinute = a;
	if (oldBeatsPerMinute !== a){
		//alert('changing beats per minute old ' + oldBeatsPerMinute + ' new: ' + a);
		clearTimeout(soundLoopTimer);
		
		if (beatsPerMinute !== 0) {
				soundLoopTimer = setInterval('soundLoop();',(1000*60)/beatsPerMinute);
		}
    	oldBeatsPerMinute = beatsPerMinute;
    }
	//alert('AFTER old ' + oldBeatsPerMinute + ' new: ' + a);

}

soundLoop = function() {
			//clearTimeout(soundLoopTimer);
			//alert('soundLoop');
			
			//if (beatsPerMinute !== 0) {
			//		soundLoopTimer = setTimeout('soundLoop();',(1000*60)/beatsPerMinute);
			//}
			
			beatNumber++;
			beatNumber = beatNumber % 16;

			//alert(' '+soundLoops.soundIDs.length);
			for(var i in soundLoops.soundIDs){
				var playOrNoPlay;
				playOrNoPlay = soundLoops.beatStrings[i].charAt(beatNumber);
				//alert('soundID: ' + soundLoops.soundIDs[i]);
				if (playOrNoPlay === 'x') {
					soundManager.play(soundLoops.soundIDs[i])
				}
			}
}


addSound = function(soundID,beatString) {

    		soundLoops.soundIDs[soundLoops.soundIDs.length] = soundID;
    		soundLoops.beatStrings[soundLoops.beatStrings.length] = beatString;

}

var matrixStack = [];
pushMatrix = function(){
	matrixStack.push(worldMatrix);
	worldMatrix = (new THREE.Matrix4()).copy(worldMatrix);
}

popMatrix = function(){
	if (matrixStack.length !== 0)
		worldMatrix = matrixStack.pop();
	else
		worldMatrix.identity();
}

resetMatrix = function(){
	worldMatrix.identity();
}

translate = function(a, b, c) {
  /*
  currentObject = new THREE.Object3D();
  currentObject.position.x = a;
  currentObject.position.y = b;
  currentObject.position.z = c;
  parentObject.add(currentObject);
  parentObject = currentObject;
  */
  worldMatrix.translate(new THREE.Vector3(a,b,c));
};

rotate = function(a, b, c) {

  if(arguments.length == 0){
  	  return;
  }
  else if(arguments.length == 1){
  	  b=a; c=a;
  }
  else if(arguments.length == 2){
  	  c=0;
  }

  /*
  currentObject = new THREE.Object3D();
  currentObject.rotation.x = a;
  currentObject.rotation.y = b;
  currentObject.rotation.z = c;
  parentObject.add(currentObject);
  parentObject = currentObject;
  */
  //worldMatrix.setRotationFromEuler(new THREE.Vector3(a,b,c));
  worldMatrix.rotateX(a).rotateY(b).rotateZ(c);

};

scale = function(a, b, c) {
  if(arguments.length == 0){
  	  return;
  }
  else if(arguments.length == 1){
  	  b=a; c=a;
  }
  else if(arguments.length == 2){
  	  c=1;
  }
  
  // odd things happen setting scale to zero
  if (a < 0.000000001) a = 0.000000001;
  if (b < 0.000000001) b = 0.000000001;
  if (c < 0.000000001) c = 0.000000001;

  /*
  currentObject = new THREE.Object3D();
  currentObject.scale.x = a;
  currentObject.scale.y = b;
  currentObject.scale.z = c;
  parentObject.add(currentObject);
  parentObject = currentObject;
  */
  worldMatrix.scale(new THREE.Vector3(a,b,c));

};


  line = function(a) {
  	
  	if (!doStroke) {
  		return;
  	}
  	
  	if(a === undefined){
  	  a=1;
  	  }

    
    var mesh = linesPool[usedLines];
    if ( mesh === undefined){
		var lineBasicMaterialCOL = new THREE.LineBasicMaterial({
			color: currentStrokeColor,
			opacity: currentStrokeAlpha,
		});

      mesh = new THREE.Line(lineGeometry, lineBasicMaterialCOL);
      mesh.isLine = true;
      mesh.isMesh = false;
      mesh.isBox = false;
      linesPool.push(mesh);
      scene.add(mesh);
    }
    else {
    	//mesh.geometry = lineGeometry;
    	//mesh.material = lineBasicMaterialCOL;
    	mesh.material.color.setHex(currentStrokeColor);
		mesh.material.opacity = currentStrokeAlpha;
    }
    usedLines++;
    
    // old unpooled mechanism
    //var mesh = new THREE.Line(lineGeometry, lineBasicMaterialCOL);

    mesh.matrixAutoUpdate = false;
    mesh.matrix.copy(worldMatrix);
    mesh.matrixWorldNeedsUpdate = true;
  	if( a !== 1){
      mesh.matrix.scale(new THREE.Vector3(1,a,1));
      // in theory the docs say that we should change the boundradius
      // but I don't think that we need it...
      //mesh.boundRadiusScale = Math.max(a,b,c);
    }
    
    //scene.add(mesh);

  }


  rect = function(a,b) {
  	
  	if(a === undefined){
  	  a=1; b=1;
  	  }
  	  
  	else if(arguments.length === 1){
  	  b=a;
  	  }
  	  
	if (doFill) {
		var mesh = rectanglesPool[usedRectangles];
		var rectMaterialCOL;
		if ( mesh === undefined){
		  rectMaterialCOL = new THREE.MeshBasicMaterial({
				color: currentFillColor,
				opacity: currentFillAlpha,
			});
		  mesh = new THREE.Mesh(planeGeometry, rectMaterialCOL);
		  mesh.isLine = false;
		  mesh.isMesh = true;
	      mesh.isBox = false;
		  rectanglesPool.push(mesh);
		  mesh.doubleSided = true;
		  scene.add(mesh);
		}
		else {
			mesh.material.color.setHex(currentFillColor);
			mesh.material.opacity = currentFillAlpha;
			mesh.material.wireframe = false;
			mesh.doubleSided = true;
		}
		usedRectangles++;
		mesh.matrixAutoUpdate = false;
		mesh.matrix.copy(worldMatrix);
		mesh.matrixWorldNeedsUpdate = true;
    }

//
/////  Now for the wireframe part
//

	if (doStroke) {
		var mesh2 = rectanglesPool[usedRectangles];
		var rectWireframeMaterialCOL;
		if ( mesh2 === undefined){
		  rectWireframeMaterialCOL = new THREE.MeshBasicMaterial( {
				color: currentStrokeColor,
				opacity: currentStrokeAlpha,
				wireframe: true
			} )
		  mesh2 = new THREE.Mesh(planeGeometry, rectWireframeMaterialCOL);
		  mesh2.isLine = false;
		  mesh2.isMesh = true;
	      mesh2.isBox = false;
		  rectanglesPool.push(mesh2);
		  // note that for webgl this wireframe is visible from the back
		  // even if doublesided is false.
		  // not so for canvas renderer.
		  // TODO tell the three.js people
		  mesh2.doubleSided = true;
		  scene.add(mesh2);
		}
		else {
			//mesh.geometry = lineGeometry;
			mesh2.material.wireframe = true;
			mesh2.material.color.setHex(currentStrokeColor);
			mesh2.material.opacity = currentStrokeAlpha;
		  // note that for webgl this wireframe is visible from the back
		  // even if doublesided is false.
		  // not so for canvas renderer.
		  // TODO tell the three.js people
			mesh2.doubleSided = true;
		}
		usedRectangles++;
		mesh2.matrixAutoUpdate = false;
		mesh2.matrix.copy(worldMatrix);
		mesh2.matrixWorldNeedsUpdate = true;
    }


	// now combine the two meshes
	// note that I did try to see whether grouping the two meshes
	// is faster, as in: https://github.com/mrdoob/three.js/blob/dev/src/extras/SceneUtils.js#L29
	// but it seems to be much slower...

  	if( a !== 1 || b !== 1){
      if (doFill) mesh.matrix.scale(new THREE.Vector3(a,b,1));
      if (doStroke) mesh2.matrix.scale(new THREE.Vector3(a,b,1));
      // in theory the docs say that we should change the boundradius
      // but I don't think that we need it...
    }
    
  }

  var gradStack = [];

  resetGradientStack = function() {
  	currentGradientStackValue = "";
  	// we could be more efficient and
  	// reuse the previous stack elements
  	// but I don't think it matters here
  	gradStack = [];

	simpleGradient(color(70),color(30),color(0),1);

  }

  simpleGradient = function(a,b,c,d) {
	currentGradientStackValue = currentGradientStackValue + ""+a+""+b+""+c+""+d;
	gradStack.push(
		{
			gradStacka: a,
			gradStackb: b,
			gradStackc: c,
			gradStackd: d
		}
	);
	
  }

  var simpleGradientUpdateIfChanged = function() {

	//alert('simpleGradientUpdateIfChanged curr '+currentGradientStackValue + " prev " +previousGradientStackValue );
	if ((currentGradientStackValue === previousGradientStackValue) ) {
  		return;
  	}
  	else {

				previousGradientStackValue = currentGradientStackValue;
				//console.log('repainting background');
				var diagonal = Math.sqrt(Math.pow(scaledBackgroundWidth/2,2)+ Math.pow( scaledBackgroundHeight/2,2));
				var radgrad;
				for (var scanningGradStack = 0; scanningGradStack < gradStack.length; scanningGradStack++) {
					radgrad = backgroundSceneContext.createLinearGradient(scaledBackgroundWidth/2, 0, scaledBackgroundWidth/2, scaledBackgroundHeight);  
					radgrad.addColorStop(0, color.toString(gradStack[scanningGradStack].gradStacka));  
					radgrad.addColorStop(0.5, color.toString(gradStack[scanningGradStack].gradStackb));  
					radgrad.addColorStop(1, color.toString(gradStack[scanningGradStack].gradStackc));    
					
					backgroundSceneContext.globalAlpha = 1.0;
					backgroundSceneContext.fillStyle = radgrad;
					backgroundSceneContext.beginPath();
					backgroundSceneContext.rect(0,0,scaledBackgroundWidth,scaledBackgroundHeight);
					backgroundSceneContext.closePath();
					backgroundSceneContext.fill();
				}				
  	}

  }


  animationMode = function(a) {
  	// turns out when you type normal that the first two letters "no"
  	// are sent as "false"
    if (a===false) return;
  	if (a===undefined) return;
  	animationModeValue = a;
  }


  animationModeUpdateIfChanged = function() {
  	//alert("actual called " + a);

	if ((animationModeValue !== previousAnimationModeValue) ) {
  		//alert("actual changed!");
  	}
  	else {
  		//alert("no change");
  		return;
  	}

  	previousAnimationModeValue = animationModeValue;
  	
  	if (isWebGLUsed && animationModeValue === motionBlur) {
  		effectBlend.uniforms[ 'mixRatio' ].value = 0.7;
  	}
  	else if (!isWebGLUsed && animationModeValue === motionBlur) {
  		blendAmount = 0.6;
  		//alert('motion blur canvas');
  	}

  	if (isWebGLUsed && animationModeValue === retain) {
  		effectBlend.uniforms[ 'mixRatio' ].value = 1;
  	}
  	else if (!isWebGLUsed && animationModeValue === retain) {
  		blendAmount = 1;
  		//alert('retain canvas');
  	}

  	if (isWebGLUsed && animationModeValue === normal) {
  		effectBlend.uniforms[ 'mixRatio' ].value = 0;
  	}
  	else if (!isWebGLUsed && animationModeValue === normal) {
  		blendAmount = 0;
  		//alert('normal canvas');
  	}
  		
  }

    
  box = function(a,b,c) {
  	
  	if(a === undefined){
  	  //alert('cube!')
  	  a=1; b=1; c=1;
  	  }
  	  
  	else if(arguments.length === 1){
  	  b=a; c=a;
  	  }

	if (doFill) {
		var mesh = boxesPool[usedBoxes];
		var rectMaterialCOL;
		if ( mesh === undefined){
		  rectMaterialCOL = new THREE.MeshBasicMaterial({
				color: currentFillColor,
				opacity: currentFillAlpha,
			});
		  mesh = new THREE.Mesh(cubeGeometry, rectMaterialCOL);
		  mesh.isLine = false;
		  mesh.isMesh = false;
		  mesh.isBox = true;
		  boxesPool.push(mesh);
		  mesh.doubleSided = false;
		  scene.add(mesh);
		}
		else {
			mesh.material.color.setHex(currentFillColor);
			mesh.material.opacity = currentFillAlpha;
			mesh.material.wireframe = false;
			mesh.doubleSided = false;
		}
		usedBoxes++;
		mesh.matrixAutoUpdate = false;
		mesh.matrix.copy(worldMatrix);
		mesh.matrixWorldNeedsUpdate = true;
    }

//
/////  Now for the wireframe part
//

	if (doStroke) {
		var mesh2 = boxesPool[usedBoxes];
		var rectWireframeMaterialCOL;
		if ( mesh2 === undefined){
		  rectWireframeMaterialCOL = new THREE.MeshBasicMaterial( {
				color: currentStrokeColor,
				opacity: currentStrokeAlpha,
				wireframe: true
			} )
		  mesh2 = new THREE.Mesh(cubeGeometry, rectWireframeMaterialCOL);
		  mesh2.isLine = false;
		  mesh2.isMesh = false;
		  mesh2.isBox = true;
		  boxesPool.push(mesh2);
		  // meshes with wireframe material don't
		  // need this flag  to be set so let's leave the default.
		  mesh2.doubleSided = false;
		  scene.add(mesh2);
		}
		else {
			//mesh.geometry = lineGeometry;
			mesh2.material.wireframe = true;
			mesh2.material.color.setHex(currentStrokeColor);
			mesh2.material.opacity = currentStrokeAlpha;
			mesh2.doubleSided = false;
		}
		usedBoxes++;
		mesh2.matrixAutoUpdate = false;
		mesh2.matrix.copy(worldMatrix);
		mesh2.matrixWorldNeedsUpdate = true;
    }


	// now combine the two meshes
	// note that I did try to see whether grouping the two meshes
	// is faster, as in: https://github.com/mrdoob/three.js/blob/dev/src/extras/SceneUtils.js#L29
	// but it seems to be much slower...

  	if( a !== 1 || b !== 1 || c !== 1){
      if (doFill) mesh.matrix.scale(new THREE.Vector3(a,b,c));
    }
    // TODO: meshes should be built from geometries that are
    // ever so slight larger than the "fill" mesh so there
    // is no z-fighting...
    // constant 0.001 below is to avoid z-fighting
    if (doStroke) mesh2.matrix.scale(new THREE.Vector3(a+0.001,b+0.001,c+0.001));
      // in theory the docs say that we should change the boundradius
      // but I don't think that we need it...


  }



/**
 * extend the Number prototype
 * @param func
 * @param scope [optional]
 */
Number.prototype.times = function(func, scope){
    var v = this.valueOf();
    for (var i=0; i < v; i++){
        func.call(scope||window,i);
    }
};


/*


To set the flash security settings:
http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html

/////////////////////////////

bpm 350
//addSound 's12','zzzzzzzzzzzzzzzx'
addSound 'additional13'  ,'zzx z zzzzxzzzzzzx'
addSound 'additional9'  ,'zxzx z zxzzxxxxxxx'
addSound 'additional7'  ,'zzxz z zzzxzzzzzzx'
addSound 'additional1'  ,'zzxz z zzzzzzzzzzx'
addSound 'additional8'  ,'xzzx z zzxzzzxzzxz'
addSound 'additional6' ,'xxzz x zxzxzxxxxxx'
addSound 'additional4' ,'zxzxzzzxzxxzzzxx'
scale 2*Math.sin(frame/33)
rotate frame/10,frame/250,frame/50
box

//////////////////////////////

*/

var simpleCubeExample = ""+
	"rotate 0, 1, frame/100\n"+
	"box\n" + 
	"\n" + 
	"// see next example, click here below:\n" +
	"// example:two_cubes \n";

var twocubesExample = ""+
""+		"2 times ->\n"+
"\t"+		"rotate 0, 1, frame/200\n"+
"\t"+		"box\n";

var cubesAndSpikes = ""+
""+		"scale 2.1\n"+
""+		"5 times ->\n"+
"\t"+			"rotate 0,1,frame/500\n"+
"\t"+			"box 0.1,0.1,0.1\n"+
"\t"+			"translate 0,0.1,0.1\n"+
"\t"+			"3 times ->\n"+
"\t\t"+				"rotate 0,1,1\n"+
"\t\t"+				"box 0.01,0.01,1\n";

var turbineExample = ""+
""+		"70 times ->\n"+
"\t"+		"rotate frame/101,1,frame/1000\n"+
"\t"+		"box\n";

var yellowBackgroundExample = ""+
""+		"background 255,255,0\n"+
""+		"rotate 0,frame/20,frame/20\n"+
""+		"box\n";

var littleSpiralOfCubes = ""+
""+		"scale 0.1\n"+
""+		"10 times ->\n"+
"\t"+		"rotate 0,1,frame/100\n"+
"\t"+		"translate 1,1,1\n"+
"\t"+		"box\n";

var tentacleExample = ""+
""+		"scale 0.1\n"+
""+		"3 times ->\n"+
"\t"+		"rotate 0,1,1\n"+
"\t"+		"10 times ->\n"+
"\t\t"+		"rotate 0,1,frame/100\n"+
"\t\t"+		"scale 0.9\n"+
"\t\t"+		"translate 1,1,1\n"+
"\t\t"+		"box\n";

var industrialMusicExample = ""+
""+		"bpm 350\n"+
""+		"addSound 'additional13'  ,'zzx z zzzzxzzzzzzx'\n"+
""+		"addSound 'additional9'  ,'zxzx z zxzzxxxxxxx'\n"+
""+		"addSound 'additional7'  ,'zzxz z zzzxzzzzzzx'\n"+
""+		"addSound 'additional1'  ,'zzxz z zzzzzzzzzzx'\n"+
""+		"addSound 'additional8'  ,'xzzx z zzxzzzxzzxz'\n"+
""+		"addSound 'additional6' ,'xzxz x zxzxxxzxxxx'\n"+
""+		"addSound 'additional4' ,'zxzxzzzxxzzzzzxx'\n";

var doOnceExample = ""+
""+		"rotate frame/100\n"+
""+		"// comment\n"+
""+		"/* another\n"+
""+		"comment */\n"+
""+		"âœ“doOnce ->\n"+
"\t"+	   "frame = 0 ; box\n"+
""+		"âœ“doOnce -> alert 'miao'\n";

var planesExample = ""+
""+		"scale 0.3\n"+
""+		"3 times ->\n"+
"\t"+		"translate 0,0,0.5\n"+
"\t"+		"5 times ->\n"+
"\t\t"+		"rotate frame/100\n"+
"\t\t"+	   "translate 0.7,0,0\n"+
"\t\t"+		"rect";

var matrixesExample = ""+
""+		"rotate frame/100\n"+
""+		"line\n"+
""+		"pushMatrix\n"+
""+		"translate 0.5,0,0\n"+
""+		"line\n"+
""+		"popMatrix\n"+
""+		"translate -0.5,0,0\n"+
""+		"line\n"+
""+		"resetMatrix\n"+
""+		"line";

var diceExample = ""+
""+		"animationMode motionBlur\n"+
""+		"simpleGradient color(255),color(255,255,0),color(255,255,0)\n"+
""+		"stroke 255,100,100,255\n"+
""+		"fill 255,0,0,155\n"+
""+		"translate -0.5,0,0\n"+
""+		"scale 0.3\n"+
""+		"3 times ->\n"+
"\t"+		"translate 0,0,0.5\n"+
"\t"+		"1 times ->\n"+
"\t\t"+		"rotate frame/50\n"+
"\t\t"+		"translate 2,0,0\n"+
"\t\t"+		"box";


var nuclearOctopusExample = ""+
""+		"simpleGradient 0,color(frame*15%255,0,0),0\n"+
""+		"scale 0.2\n"+
""+		"translate 3\n"+
""+		"rotate frame/90\n"+
""+		"animationMode motionBlur\n"+
""+		"//animationMode retain\n"+
""+		"stroke 255,0,0,120\n"+
""+		"fill frame*10%255,0,0\n"+
""+		"pushMatrix\n"+
""+		"count = 0\n"+
""+		"3 times ->\n"+
"\t"+		"count++\n"+
"\t"+		"pushMatrix\n"+
"\t"+		"rotate count+3+frame,2+count + frame/100,4+count\n"+
"\t"+		"120 times ->\n"+
"\t\t"+		"scale 0.9\n"+
"\t\t"+		"translate 1,1,0\n"+
"\t\t"+		"rotate frame/100\n"+
"\t\t"+		"box\n"+
"\t"+		"popMatrix";


function loadExample(whichExample) {

	// set the example as a hash state
	// so that ideally people can link directly to
	// a specific example they like.
	// (in the document.ready function we check for
	// this hash value and load the correct example)
	window.location.hash =  'example='+whichExample;

	if (fakeText) shrinkFakeText();
	undimEditor();
	

	switch(whichExample) {
		case 'simpleCubeExample':
			editor.setValue(simpleCubeExample);
			break;
		case 'twocubesExample':
			editor.setValue(twocubesExample);
			break;
		case 'cubesAndSpikes':
			editor.setValue(cubesAndSpikes);
			break;
		case 'turbineExample':
			editor.setValue(turbineExample);
			break;
		case 'yellowBackgroundExample':
			editor.setValue(yellowBackgroundExample);
			break;
		case 'littleSpiralOfCubes':
			editor.setValue(littleSpiralOfCubes);
			break;
		case 'tentacleExample':
			editor.setValue(tentacleExample);
			break;
		case 'industrialMusicExample':
			editor.setValue(industrialMusicExample);
			break;
		case 'doOnceExample':
			editor.setValue(doOnceExample);
			break;
		case 'planesExample':
			editor.setValue(planesExample);
			break;
		case 'matrixesExample':
			editor.setValue(matrixesExample);
			break;
		case 'diceExample':
			editor.setValue(diceExample);
			break;
		case 'nuclearOctopusExample':
			editor.setValue(nuclearOctopusExample);
			break;

	}
	
	// setting the value of the editor triggers the
	// codeMirror onChange callback, and that runs
	// the example.
}

	</script>
	
	<script>
  var changesHappened = false;
  
  // way to add links taken form here:
  // http://groups.google.com/group/codemirror/browse_thread/thread/a96bb56548815163/87a3869e2cfd0a37?lnk=gst&q=links#87a3869e2cfd0a37
  CodeMirror.defineMode("links", function(config, parserConfig) { 
    return { 
    token: function(stream, state) {
      if (stream.match(/\/\/\s*(example:([^\s]+))\b/)) 
      { 
           return "link"; 
      } 
            stream.skipToEnd(); 
    
    } 
  }; 
}); 


  var cursorActivity = true;
  var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
    lineNumbers: false,
        tabSize: 2,
        indentUnit: 2,
        indentWithTabs: true,
        lineWrapping: true,
        // We want the code editor to always have focus
        // since there is nothing else to type into.
        // One of those little wonders: you have to pause a little
        // before giving the editor focus, otherwise for some reason
        // the focus is not regained. Go figure.
        onBlur: (function(){ setTimeout('editor.focus()',30) }),
        onChange: (function(){registerCode();}),
        mode: "links",
        onCursorActivity: (function(){undimIfCursorActivity();}),
        //onScroll: (function(){alert('scroll')})
  });

  
  $('#formCode').delegate(".cm-link", "click", function(event) {
  //alert('clicked');
  var url;
  url = $(event.target).text();
  url = url.replace(/\/\/\s*example:/,"");
  url = url.replace("_","");
  //alert(""+url);
  loadExample(url+"Example");
});

  editor.setOption("theme", 'night');
  function selectTheme(node) {
    var theme = node.options[node.selectedIndex].innerHTML;
    editor.setOption("theme", theme);
  }

// resizing the text area is necessary otherwise
// as the user types to the end of it, instead of just scrolling
// the content leaving all the other parts of the page where
// they are, it expands and it pushes down
// the view of the page, meaning that the canvas goes up and
// the menu disappears
// so we have to resize it at launch and also every time the window
// is resized.

function adjustCodeMirrorHeight() {
	//alert("code height:" + $('#code').height());
	//alert("window height:" + window.innerHeight);
	//alert("code height:" + $('.CodeMirror-scroll').css('height'));
	//alert("menu height:" + $('#theMenu').height());
	$('.CodeMirror-scroll').css('height',window.innerHeight - $('#theMenu').height()); 
}

var fakeCursorInterval;

function fakeCursorBlinking() 
{
  $("#fakeStartingBlinkingCursor").animate(
  {
    opacity: 0
  }, "fast", "swing").animate(
  {
    opacity: 1
  }, "fast", "swing");
}

function undimIfCursorActivity(){
	if (fakeText || editor.getValue() === '') return;
	console.log('cursor activity! opacity: ' + $("#formCode").css('opacity'));
	cursorActivity = true;
	undimEditor();
}

function undimEditor(){
	if (fakeText || editor.getValue() === '') $("#formCode").css('opacity',0);
	if ($("#formCode").css('opacity') < 0.99) {
		console.log('undimming the editor');
		$("#formCode").animate(
		  {
			opacity: 1
		  }, "fast");
	}
}

function dimEditor(){
		if ($("#formCode").css('opacity') > 0.200001) {
			console.log('starting fadeout animation');
			$("#formCode").animate(
			  {
				opacity: 0.2
			  }, "slow");
		  }
}

function dimIfNoCursorActivity(){
	if (fakeText || editor.getValue() === '') return;
	if (cursorActivity) {
		console.log('marking cursor act = false and check again in a second');
		cursorActivity = false;
		return;
	}
	else {
		console.log('no activity in the last second and opacity: ' + $("#formCode").css('opacity') );
		dimEditor();

	}
}

$(document).ready(function(){
	editor.focus();
	adjustCodeMirrorHeight();
	
	// check if the url points to a particular example,
	// in which case we load the example directly.
	// otherwise we do as usual.
	if (window.location.hash.indexOf("example")!==-1){
		var exampleToLoad = window.location.hash.substring(9);
		//setTimeout ( "loadExample('"+exampleToLoad+"');",500);
		loadExample(exampleToLoad);
	}
	fakeCursorInterval = setInterval ( "fakeCursorBlinking()", 800 );
	setInterval ( "dimIfNoCursorActivity()", 2000 );
});


///////////////////////////////////////////////

window.addEventListener(
    'load',
    function () {
        //alert('resizing canvas');
        var canvas = document.getElementById('backGroundCanvas');

        if (fullScreenifyBackground) {
        	fullscreenify(canvas);
        }
		resetGradientStack();
		simpleGradientUpdateIfChanged();
		

		$('#startingCourtainScreen').fadeOut();

		  $("#formCode").css('opacity',0);

    },
    false
);

function fullscreenify(canvas) {
    var style = canvas.getAttribute('style') || '';
    //alert('style: ' +  style);
    
    window.addEventListener('resize', function () {	adjustCodeMirrorHeight(); resize(canvas);}, false);

    resize(canvas);

    function resize(canvas) {
        var scale = {x: 1, y: 1};
        scale.x = (window.innerWidth + 40) / canvas.width;
        scale.y = (window.innerHeight + 40) / canvas.height;
        
        scale = scale.x + ', ' + scale.y;
        
        // this code below is if one wants to keep the aspect ratio
        // but I mean one doesn't necessarily resize the window
        // keeping the same aspect ratio.
        /*
        if (scale.x < 1 || scale.y < 1) {
            scale = '1, 1';
        } else if (scale.x < scale.y) {
            scale = scale.x + ', ' + scale.x;
        } else {
            scale = scale.y + ', ' + scale.y;
        }
        */
        
        canvas.setAttribute('style', style + ' ' + '-ms-transform-origin: left top; -webkit-transform-origin: left top; -moz-transform-origin: left top; -o-transform-origin: left top; transform-origin: left top; -ms-transform: scale(' + scale + '); -webkit-transform: scale3d(' + scale + ', 1); -moz-transform: scale(' + scale + '); -o-transform: scale(' + scale + '); transform: scale(' + scale + ');');
		
		// TODO In theory we want to re-draw the background because the
		// aspect ration might have changed.
		// But for the time being we only have vertical
		// gradients so that's not going to be a problem.

    }
}

</script>




<script type="text/javascript" src="./script/soundmanager2.js"></script>
<script type="text/javascript" src="./script/mpc.js"></script>



</body>
</html>
